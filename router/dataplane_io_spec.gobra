// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package router

import (
	"sync"
	io "github.com/scionproto/scion/verification/io"
)

type SharedArg struct {
	Place *io.Place // Existential for the current place
	State *io.IO_dp3s_state_local // Existential for the current model state
	IBufY, OBufY ElemRA // Parameters of the resoure algebra (is not necessary to understand to verify I/O spec)
}

pred SharedInv(ghost y SharedArg) {
	acc(y.Place) && acc(y.State) && // existentials are expressed using ghost pointers
	io.token(*y.Place) && io.dp3s_iospec_ordered(*y.State, *y.Place) && 
	ElemAuth((*y.State).ibuf, y.IBufY) && ElemAuth((*y.State).obuf, y.OBufY)
}

// initialize the shared invariant:

ghost 
requires io.token(p) && io.dp3s_iospec_ordered(s, p)
ensures  m.LockP() && m.LockInv() == SharedInv!< y !>;
func InitSharedInv(ghost p io.Place, ghost s io.IO_dp3s_state_local) (ghost m *sync.Mutex, ghost y SharedArg) {
	mV@ := sync.Mutex{}
	m = &mV
	pE@ := p
	sE@ := s
	yI := InitElemAuth(s.ibuf)
	yO := InitElemAuth(s.obuf)
	y := SharedArg{&pE, &sE, yI, yO}
	fold SharedInv!< y !>()
	m.SetInv(SharedInv!< y !>)
}

/////////////////////////////////////// MultiBio ///////////////////////////////////////

pred MultiReadBio(ghost t io.Place, n int) {
  (n > 0 ==> read_bio(t) && MultiReadBio(read_bio_next(t), n-1))
}

ghost 
decreases m
requires m <= n && acc(MultiReadBio(t, n), _)
pure func MutliReadBio_next(ghost t io.Place, n, m int) (ghost tn io.Place) {
  return m <= 0 ? t : unfolding acc(MultiReadBio(t, n), _) in MutliReadBio_next(read_bio_next(t), n-1, m-1)
}

ghost 
decreases m
requires m <= n && acc(MultiReadBio(t, ), _)
pure func MutliReadBio_correctIfs(ghost t io.Place, n, m int, ghost k Key) bool {
  return m <= 0 ? true : unfolding acc(MultiReadBio(t, ), _) in k == read_bio_ifs(t) && MutliReadBio_correctIfs(read_bio_next(t), n-1, m-1, k)
}

ghost 
decreases m
requires 0 <= m && m <= n && acc(MultiReadBio(t, ), _)
ensures len(res) == m
pure func MutliReadBio_Pkts(ghost t io.Place, n, m int) (ghost res seq[Elem]) {
  return m <= 0 ? seq[Elem]{} : unfolding acc(MultiReadBio(t,n), _) in seq[Elem]{read_bio_pkt(t)} ++ MutliReadBio_Pkts(read_bio_next(t), n-1, m-1)
}

ghost 
decreases m
requires m <= n && acc(MultiReadBio(t,n), _)
pure func MultiReadBio_Upd(ghost t io.Place, n, m int, ghost s io.IO_dp3s_state_local) io.IO_dp3s_state_local {
  return m <= 0 ? s : unfolding acc(MultiReadBio(t,n), _) in MultiReadBio_Upd(read_bio_next(t), n-1, m-1, io.dp3s_add_ibuf(s, read_bio_ifs(t), read_bio_pkt(t)))
}

ghost 
decreases len(es)
pure func MultiIBuf_Upd(ghost k Key, ghost es seq[Elem], ghost s io.IO_dp3s_state_local) io.IO_dp3s_state_local {
  return len(es) == 0 ? s : MultiIBuf_Upd(k, es[1:], io.dp3s_add_ibuf(s, k, es[0]))
}

ghost
decreases n
requires io.dp3s_iospec_ordered(s,t) 
ensures  MultiReadBio(t,n) && io.dp3s_iospec_ordered(MultiReadBio_Upd(t,n,n,s), MutliReadBio_next(t,n,n))
func ExtractMultiReadBio(ghost t io.Place, n int, ghost s io.IO_dp3s_state_local) {
  if n > 0 {
    unfold io.dp3s_iospec_ordered(s,t)
    unfold io.dp3s_iospec_bio3s_recv(s,t)
    ExtractMultiReadBio(read_bio_next(t), n-1, io.dp3s_add_ibuf(s, read_bio_ifs(t), read_bio_pkt(t)))
  } 
  fold MultiReadBio(t,n)
}

ghost 
decreases len(es)
requires ElemAuth(s.ibuf, y.IBufY) && ElemAuth(s.obuf, y.OBufY)
ensures  ElemAuth(MultiIBuf_Upd(k,es,s).ibuf, y.IBufY) && ElemAuth(MultiIBuf_Upd(k,es,s).obuf, y.OBufY)
ensures  MultiElemWitness(y.IBufY, k, es)
func MultiUpdateElemWitness(ghost k Key, ghost es seq[Elem], ghost s io.IO_dp3s_state_local, ghost y SharedArg) {
  if len(es) > 0 {
    UpdateElemWitness(s.ibuf, y.IBufY, k, es[0])
    MultiUpdateElemWitness(k, es[1:], io.dp3s_add_ibuf(s, k, es[0]), y)
  } 
  fold MultiElemWitness(y.IBufY, k, es)
}


ghost 
decreases n
requires 0 < p && acc(MultiReadBio(t,n), p) 
ensures  acc(MultiReadBio(t,n), p)
requires ElemAuth(s.ibuf, y.IBufY) && ElemAuth(s.obuf, y.OBufY)
ensures  ElemAuth(MultiReadBio_Upd(t,n,n,s).ibuf, y.IBufY) && ElemAuth(MultiReadBio_Upd(t,n,n,s).obuf, y.OBufY)
ensures  0 <= m && m <= n && MutliReadBio_correctIfs(t,n,m,k) ==> MultiElemWitness(y.IBufY, k, MutliReadBio_Pkts(t,n,m))
func MultiUpdateElemWitness2(ghost t io.Place, n, m int, ghost k Key, ghost s io.IO_dp3s_state_local, ghost y SharedArg, ghost p perm) {
  unfold acc(MultiReadBio(t,n), p/2)

  if n > 0 {
    UpdateElemWitness(s.ibuf, y.IBufY, read_bio_ifs(t), read_bio_pkt(t))
    MultiUpdateElemWitness2(read_bio_next(t), n-1, m-1, k, io.dp3s_add_ibuf(s, read_bio_ifs(t), read_bio_pkt(t)), y, p/2)
  } 

  if 0 <= m && m <= n && MutliReadBio_correctIfs(t,n,m,k) {
    if m > 0 {
      fold acc(MultiReadBio(t,n), p/4)
      unfold acc(MultiReadBio(t,n), p/4)
      assert MutliReadBio_Pkts(t,n,m) == seq[Elem]{read_bio_pkt(t)} ++ MutliReadBio_Pkts(read_bio_next(t),n-1,m-1)
    }
    fold MultiElemWitness(y.IBufY, k, MutliReadBio_Pkts(t,n,m))
  }

  fold acc(MultiReadBio(t,n), p/2)
}

pred MultiElemWitness(ghost y ElemRA, ghost k Key, ghost es seq[Elem]) { 
  // cannot be quantified because there might be multiple witnesses for the same element
  len(es) > 0 ==> ElemWitness(y, k, es[0]) && MultiElemWitness(y, k, es[1:])
}

pred MultiElemWitness0(ghost y ElemRA, ghost k Key, ghost es seq[Elem], i int) { 
  0 <= i && i < len(es) ==> ElemWitness(y, k, es[i]) && MultiElemWitness0(y, k, es, i+1)
}


ghost 
decreases 
requires MultiElemWitness(y,k,es)
ensures  MultiElemWitness0(y,k,es,0)
func MultiElemWitnessConv(ghost y ElemRA, ghost k Key, ghost es seq[Elem]) {
  multiElemWitnessConvAux(y,k,es,0)
}

ghost
decreases len(es)-i
requires i >= 0 
requires MultiElemWitness(y,k,es[i:])
ensures  MultiElemWitness0(y,k,es,i)
func multiElemWitnessConvAux(ghost y ElemRA, ghost k Key, ghost es seq[Elem], i int) {
  unfold MultiElemWitness(y,k,es[i:])
  if i < len(es) {
    multiElemWitnessConvAux(y,k,es,i+1)
  }
  fold MultiElemWitness0(y,k,es,i)
}


/////////////////////////////////////// BIOs ///////////////////////////////////////

pred read_bio(ghost t io.Place)

ghost
decreases
requires acc(read_bio(t), _)
pure func read_bio_ifs(ghost t io.Place) (ghost k Key)

ghost
decreases
requires acc(read_bio(t), _)
pure func read_bio_pkt(ghost t io.Place) (ghost e Elem)

ghost
decreases
requires acc(read_bio(t), _)
pure func read_bio_next(ghost t io.Place) (ghost nt io.Place)


pred send_bio(ghost t io.Place, ghost k Key, ghost e Elem)

ghost
decreases
requires acc(send_bio(t, k, e), _)
pure func send_bio_next(ghost t io.Place, ghost k Key, ghost e Elem) (ghost nt io.Place)

pred exit_bio(ghost t io.Place, ghost kFrom, kTo Key, ghost e1, e2 Elem)

ghost
decreases
requires acc(exit_bio(t, kFrom, kTo, e1, e2), _)
pure func exit_bio_next(ghost t io.Place, ghost kFrom, kTo Key, ghost e1, e2 Elem) (ghost nt io.Place)



/////////////////////////////////////// Dependencies ///////////////////////////////////////

ghost
decreases
pure func insert(buf dict[option[io.IO_ifs]](set[io.IO_pkt3]), k option[io.IO_ifs], v io.IO_pkt3) dict[option[io.IO_ifs]](set[io.IO_pkt3]) {
	return let newSet := (k in domain(buf)? (let pre := buf[k] in pre union set[io.IO_pkt3]{v}) : set[io.IO_pkt3]{v}) in
		buf[k = newSet]
}

/////////////////////////////////////// RA definitions ///////////////////////////////////////

type Key = option[io.IO_ifs]
type Val = set[io.IO_pkt3]
type Elem = io.IO_pkt3

type ElemRA domain{} 

pred ElemAuth(ghost m dict[Key]Val, ghost y ElemRA) 

pred ElemWitness(ghost y ElemRA, ghost k Key, ghost e Elem) 

ghost
decreases 
requires ElemAuth(m, y) && ElemWitness(y, k, e)
ensures  ElemAuth(m, y) && ElemWitness(y, k, e) && k in domain(m) && e in AsSet(m[k])
func ApplyElemWitness(ghost m dict[Key]Val, ghost y ElemRA, ghost k Key, ghost e Elem) 

ghost 
decreases
requires ElemAuth(m, y) 
ensures  ElemAuth(insert(m, k, e), y) && ElemWitness(y, k, e)
func UpdateElemWitness(ghost m dict[Key]Val, ghost y ElemRA, ghost k Key, ghost e Elem) 

ghost
decreases
ensures ElemAuth(m, y)
func InitElemAuth(ghost m dict[Key]Val) (ghost y ElemRA) 


/////////////////////////////////////// Utility ///////////////////////////////////////

ghost 
decreases
pure func AsSet(s set[Elem]) set[Elem] {
	return s
}
