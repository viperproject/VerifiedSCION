// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package router

import (
	"sync"
	"github.com/scionproto/scion/pkg/slayers/path"
	"github.com/scionproto/scion/pkg/slayers/path/scion"
	"github.com/scionproto/scion/pkg/slayers"
	"verification/dependencies/encoding/binary"
	io "verification/io"
	sl "github.com/scionproto/scion/verification/utils/slices"
	. "verification/utils/definitions"
)

ghost
preserves dp.Valid()
preserves acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R55)
ensures validPktMetaHdr(raw) ==>
	absIO_val(dp, raw, ingressID).isIO_val_Pkt2 &&
	absIO_val(dp, raw, ingressID).IO_val_Pkt2_2 == absPkt(dp, raw) &&
	len(absPkt(dp, raw).CurrSeg.Future) > 0
decreases
func absIO_valLemma(dp io.DataPlaneSpec, raw []byte, ingressID uint16) {
	if(validPktMetaHdr(raw)){
		absIO := reveal absIO_val(dp, raw, ingressID)
		assert absIO.isIO_val_Pkt2
		assert absIO.IO_val_Pkt2_2 == reveal absPkt(dp, raw)
		reveal validPktMetaHdr(raw)
		hdr := (unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56) in binary.BigEndian.Uint32(raw[0:4]))
		metaHdr := scion.DecodedFrom(hdr)
		currINFIdx := int(metaHdr.CurrINF)
		currHFIdx := int(metaHdr.CurrHF)
		seg1Len := int(metaHdr.SegLen[0])
		seg2Len := int(metaHdr.SegLen[1])
		seg3Len := int(metaHdr.SegLen[2])
		segLen := lengthOfCurrSeg(currHFIdx, seg1Len, seg2Len, seg3Len)
		prevSegLen := lengthOfPrevSeg(currHFIdx, seg1Len, seg2Len, seg3Len)
		numINF := numInfoFields(seg1Len, seg2Len, seg3Len)
		offset := hopFieldOffset(numINF, 0)
		assert absIO.IO_val_Pkt2_2.CurrSeg == reveal currSeg(raw, offset+prevSegLen, currINFIdx, currHFIdx-prevSegLen, segLen)
		assert len(absIO.IO_val_Pkt2_2.CurrSeg.Future) > 0
	}
}

ghost
preserves dp.Valid()
preserves acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R55)
preserves validPktMetaHdr(raw)
ensures let leftseg := absPkt(dp, raw).LeftSeg in
	leftseg != none[io.IO_seg2] ==>
		len(get(leftseg).History) == 0 && len(get(leftseg).Future) > 0
decreases
func absPktNextSegmentHistory(dp io.DataPlaneSpec, raw []byte) {
	pkt := reveal absPkt(dp, raw)
	reveal validPktMetaHdr(raw)
	hdr := (unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56) in binary.BigEndian.Uint32(raw[0:4]))
	metaHdr := scion.DecodedFrom(hdr)
	currINFIdx := int(metaHdr.CurrINF)
	currHFIdx := int(metaHdr.CurrHF)
	seg1Len := int(metaHdr.SegLen[0])
	seg2Len := int(metaHdr.SegLen[1])
	seg3Len := int(metaHdr.SegLen[2])
	segLen := lengthOfCurrSeg(currHFIdx, seg1Len, seg2Len, seg3Len)
	prevSegLen := lengthOfPrevSeg(currHFIdx, seg1Len, seg2Len, seg3Len)
	numINF := numInfoFields(seg1Len, seg2Len, seg3Len)
	offset := hopFieldOffset(numINF, 0)
	assert pkt.LeftSeg == reveal leftSeg(raw, currINFIdx + 1, seg1Len, seg2Len , seg3Len)
	if(pkt.LeftSeg != none[io.IO_seg2]) {
		assert len(get(pkt.LeftSeg).Future) > 0
		assert len(get(pkt.LeftSeg).History) == 0
	}
}

ghost
opaque
requires acc(p.scionLayer.Mem(ub), R50)
requires acc(&p.d, R55) && acc(p.d.Mem(), _)
requires acc(&p.ingressID, R55)
decreases
pure func (p *scionPacketProcessor) DstIsLocalIngressID(ub []byte) bool {
	return (unfolding acc(p.scionLayer.Mem(ub), R50) in
		(unfolding acc(p.scionLayer.HeaderMem(ub[slayers.CmnHdrLen:]), R55) in
		p.scionLayer.DstIA) == (unfolding acc(p.d.Mem(), _) in p.d.localIA)) ==> p.ingressID != 0
}

//TODO: Does not work with --disableNL --unsafeWildcardoptimization
ghost
requires acc(p.scionLayer.Mem(ub), R50)
requires acc(&p.d, R55) && acc(p.d.Mem(), _)
requires acc(&p.ingressID, R55)
requires p.DstIsLocalIngressID(ub)
requires (unfolding acc(p.scionLayer.Mem(ub), R50) in
		(unfolding acc(p.scionLayer.HeaderMem(ub[slayers.CmnHdrLen:]), R55) in
		p.scionLayer.DstIA) == (unfolding acc(p.d.Mem(), _) in p.d.localIA))
ensures acc(p.scionLayer.Mem(ub), R50)
ensures acc(&p.d, R55) && acc(p.d.Mem(), _)
ensures acc(&p.ingressID, R55)
ensures p.ingressID != 0
decreases
func (p* scionPacketProcessor) GetIngressIDNotZero(ub []byte) {
	reveal p.DstIsLocalIngressID(ub)
}

// TODO: prove
ghost
requires 0 <= start && start <= end && end <= len(ub)
requires acc(&p.path, R55) && acc(p.path.Mem(ub[start:end]), R55)
requires unfolding acc(p.path.Mem(ub[start:end]), R55) in p.path.Base.IsXoverSpec()
requires dp.Valid()
requires acc(sl.AbsSlice_Bytes(ub, 0, len(ub)), R55)
requires validPktMetaHdr(ub)
ensures acc(&p.path, R55) && acc(p.path.Mem(ub[start:end]), R55)
ensures dp.Valid()
ensures acc(sl.AbsSlice_Bytes(ub, 0, len(ub)), R55)
ensures validPktMetaHdr(ub)
ensures absPkt(dp, ub).LeftSeg != none[io.IO_seg2]
ensures len(absPkt(dp, ub).CurrSeg.Future) == 1
decreases
func (p* scionPacketProcessor) XoverLemma(ub []byte, start int, end int, dp io.DataPlaneSpec)


ghost
opaque
requires acc(&p.hopField, R55)
requires len(pkt.CurrSeg.Future) > 0
decreases
pure func (p* scionPacketProcessor) EQAbsHopField(pkt io.IO_pkt2) bool {
	return let absHop := p.hopField.ToIO_HF() in
		let currHF := pkt.CurrSeg.Future[0] in
		absHop.InIF2 == currHF.InIF2 &&
		absHop.EgIF2 == currHF.EgIF2 &&
		absHop.HVF == currHF.HVF
}


ghost
opaque
requires acc(&p.infoField, R55)
decreases
pure func (p* scionPacketProcessor) EQAbsInfoField(pkt io.IO_pkt2) bool {
	return let absInf := p.infoField.ToIntermediateAbsInfoField() in
		let currseg := pkt.CurrSeg in
		absInf.AInfo == currseg.AInfo &&
		absInf.UInfo == currseg.UInfo &&
		absInf.ConsDir == currseg.ConsDir &&
		absInf.Peer == currseg.Peer
}