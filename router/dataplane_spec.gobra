// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package router

import (
	"net"
	"hash"
	"github.com/scionproto/scion/verification/utils/slices"
	"github.com/scionproto/scion/verification/utils/definitions"
	"github.com/scionproto/scion/pkg/scrypto"
)

pred nonNilErr(e error) {
	isComparable(e) && e != nil && e.ErrorMem()
}

pred (d *DataPlane) MacFactoryOperational() {
	acc(&d.macFactory, 1/2) &&
	acc(&d.key, 1/2) &&
	acc(d.key, 1/2) &&
	acc(slices.AbsSlice_Bytes(*d.key, 0, len(*d.key)), _) &&
	scrypto.ValidKeyForHash(*d.key) &&
	d.macFactory implements MacFactorySpec{d.key}
}

pred MutexInvariant(d *DataPlane) {
	// access to the field 'mtx' ommited
	acc(&d.external,          1/2) &&
	acc(&d.linkTypes,         1/2) &&
	acc(&d.neighborIAs,       1/2) &&
	acc(&d.internal,          1/2) &&
	acc(&d.internalIP,        1/2) &&
	acc(&d.internalNextHops,  1/2) &&
	acc(&d.svc,               1/2) &&
	acc(&d.macFactory,        1/2) &&
	acc(&d.bfdSessions,       1/2) &&
	acc(&d.localIA,           1/2) &&
	acc(&d.running,           1/2) &&
	acc(&d.Metrics,           1/2) &&
	acc(&d.forwardingMetrics, 1/2) &&
	acc(&d.key,               1/2) &&
	acc(d.key,                1/2) &&
	(d.external    != nil       ==> AccBatchConn(d.external))           &&
	(d.linkTypes   != nil       ==> acc(d.linkTypes, 1/2))              &&
	(d.neighborIAs != nil       ==> acc(d.neighborIAs, 1/2))            &&
	(d.internal != nil          ==> d.internal.Mem())                   &&
	(d.internalIP != nil        ==> d.internalIP.Mem())                 &&
	(d.internalNextHops != nil  ==> AccAddr(d.internalNextHops))        &&
	(d.svc != nil               ==> acc(d.svc.Mem(), _))                &&
	(d.macFactory != nil        ==> acc(slices.AbsSlice_Bytes(*d.key, 0, len(*d.key)), _)) &&
	(d.macFactory != nil        ==> scrypto.ValidKeyForHash(*d.key)) &&
	(d.macFactory != nil        ==> d.macFactory implements MacFactorySpec{d.key}) &&
	(d.bfdSessions != nil       ==> AccBfdSession(d.bfdSessions))       &&
	(d.Metrics != nil           ==> acc(d.Metrics.Mem(), _))            &&
	// The following permissions are enough to call all methods needed in fields
	// of forwardingMetrics
	(d.forwardingMetrics != nil ==> AccForwardingMetrics(d.forwardingMetrics))
}

// TODO: reorganize permissions consistently

// TODO: use lower case for these predicates' names?
pred AccAddr(addrs map[uint16]*net.UDPAddr) {
	acc(addrs, 1/2) &&
	forall a *net.UDPAddr :: a in range(addrs) ==> acc(a.Mem(), _)
}

pred AccBatchConn(batchConns map[uint16]BatchConn) {
	acc(batchConns, 1/2) &&
	forall b BatchConn :: b in range(batchConns) ==> b.Mem()
}

pred AccBfdSession(bfdSessions map[uint16]bfdSession) {
	acc(bfdSessions, 1/2) &&
	forall bfd bfdSession :: bfd in range(bfdSessions) ==> (bfd != nil && acc(bfd.Mem(), _))
}

pred AccForwardingMetrics(metrics map[uint16]forwardingMetrics) {
	acc(metrics, 1/2) &&
	forall fm forwardingMetrics :: fm in range(metrics) ==> acc(forwardingMetricsMem(fm), _)
}

pred forwardingMetricsMem(v forwardingMetrics) {
	v.InputBytesTotal.Mem()      &&
	v.OutputBytesTotal.Mem()     &&
	v.InputPacketsTotal.Mem()    &&
	v.OutputPacketsTotal.Mem()   &&
	v.DroppedPacketsTotal.Mem()
}

// useful for hidding permissions to avoid incompletenesses of Gobra
pred (d *DataPlane) HalfLinkTypes() {
	acc(&d.linkTypes, 1/2) && (d.linkTypes != nil ==> acc(d.linkTypes, 1/2))
}

pred (p *scionPacketProcessor) initMem() {
	acc(&p.d) &&
	acc(&p.ingressID) &&
	acc(&p.buffer) &&
	acc(&p.mac) &&
	acc(p.scionLayer.InitPathPool()) &&
	acc(&p.hbhLayer) &&
	acc(&p.e2eLayer) &&
	acc(&p.lastLayer) &&
	acc(&p.path) &&
	acc(&p.hopField) &&
	acc(&p.infoField) &&
	acc(&p.segmentChange) &&
	acc(&p.cachedMac) &&
	acc(&p.macBuffers) &&
	acc(&p.bfdLayer)
}

//type KeyHolder struct { key []byte }

//pred (k *KeyHolder) Inv() {
//	len(k.key) > 0 &&
//	slices.AbsSlice_Bytes(k.key, 0, len(k.key))
//}

requires acc(key, definitions.ReadL15) && acc(slices.AbsSlice_Bytes(*key, 0, len(*key)), _)
requires scrypto.ValidKeyForHash(*key)
ensures  acc(key, definitions.ReadL15) && acc(slices.AbsSlice_Bytes(*key, 0, len(*key)), _)
ensures  res.Mem()
decreases
func MacFactorySpec(ghost key *[]byte) (res hash.Hash)
