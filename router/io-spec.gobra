// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package router

import (
	"github.com/scionproto/scion/pkg/slayers/path"
	"github.com/scionproto/scion/pkg/slayers/path/scion"
	"github.com/scionproto/scion/private/topology"
	"golang.org/x/net/ipv4"

	"verification/dependencies/encoding/binary"
	"verification/io"
	sl "verification/utils/slices"
	. "verification/utils/definitions"
)

ghost
decreases
pure func numInfoFields(seg1Len int, seg2Len int, seg3Len int) int {
	return seg3Len > 0 ? 3 : (seg2Len > 0 ? 2 : 1)
}

ghost
decreases
pure func hopFieldOffset(numINF int, currHF int) int {
	return path.InfoFieldOffset(numINF) + path.HopLen * currHF
}

ghost
decreases
pure func pktLen(seg1Len int, seg2Len int, seg3Len int) int {
	return hopFieldOffset(numInfoFields(seg1Len, seg2Len, seg3Len), 0) +
		path.HopLen * (seg1Len + seg2Len + seg3Len)
}


ghost
decreases
pure func lengthOfCurrSeg(currHF int, seg1Len int, seg2Len int, seg3Len int) int {
	return seg1Len > currHF ? seg1Len : ((seg1Len + seg2Len) > currHF ? seg2Len : seg3Len)
}

ghost
requires 0 <= currHF
ensures  res <= currHF
decreases
pure func lengthOfPrevSeg(currHF int, seg1Len int, seg2Len int, seg3Len int) (res int) {
	return seg1Len > currHF ? 0 : ((seg1Len + seg2Len) > currHF ? seg1Len : seg1Len + seg2Len)
}

ghost
requires  0 <= offset
requires  0 <= currHFIdx && currHFIdx < segLen
requires  offset + path.HopLen * segLen <= len(raw)
requires  acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
ensures   len(res) == segLen - currHFIdx
decreases segLen - currHFIdx
pure func hopFieldsConsDir(
	raw []byte,
	offset int,
	currHFIdx int,
	segLen int) (res seq[io.IO_HF]) {
	return currHFIdx == segLen ? seq[io.IO_HF]{} :
		let hf := path.BytesToIO_HF(raw, offset + path.HopLen * currHFIdx, len(raw)) in
		seq[io.IO_HF]{hf} ++ hopFieldsConsDir(raw, offset, currHFIdx + 1, segLen)
}

ghost
requires  0 <= offset
requires  -1 <= currHFIdx
requires  offset + path.HopLen * currHFIdx + path.HopLen <= len(raw)
requires  acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
ensures   len(res) == currHFIdx + 1
decreases currHFIdx + 1
pure func hopFieldsNotConsDir(
	raw []byte,
	offset int,
	currHFIdx int) (res seq[io.IO_HF]) {
	return currHFIdx == -1 ? seq[io.IO_HF]{} :
		let hf :=  path.BytesToIO_HF(raw, offset + path.HopLen * currHFIdx, len(raw)) in
		hopFieldsNotConsDir(raw, offset, currHFIdx - 1) ++ seq[io.IO_HF]{hf}
}

ghost
requires -1 <= currHFIdx && currHFIdx < len(hopfields)
decreases currHFIdx + 1
pure func segPast(hopfields seq[io.IO_HF], currHFIdx int) seq[io.IO_HF] {
	return currHFIdx == -1  ?
		seq[io.IO_HF]{} :
		seq[io.IO_HF]{hopfields[currHFIdx]} ++ segPast(hopfields, currHFIdx - 1)
}

ghost
requires 0 <= currHFIdx && currHFIdx <= len(hopfields)
decreases len(hopfields) - currHFIdx
pure func segFuture(hopfields seq[io.IO_HF], currHFIdx int) seq[io.IO_HF] {
	return currHFIdx == len(hopfields) ? seq[io.IO_HF]{} :
		seq[io.IO_HF]{hopfields[currHFIdx]} ++ segFuture(hopfields, currHFIdx + 1)
}

ghost
requires -1 <= currHFIdx && currHFIdx < len(hopfields)
decreases currHFIdx + 1
pure func segHistory(hopfields seq[io.IO_HF], currHFIdx int) seq[io.IO_ahi] {
	return currHFIdx == -1 ? seq[io.IO_ahi]{} :
		seq[io.IO_ahi]{hopfields[currHFIdx].Toab()} ++ segHistory(hopfields, currHFIdx - 1)
}

ghost
requires 0 <= offset
requires 0 < segLen
requires 0 <= currHFIdx && currHFIdx <= segLen
requires offset + path.HopLen * segLen <= len(raw)
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func segment(raw []byte,
	offset int,
	currHFIdx int,
	ainfo io.IO_ainfo,
	uinfo set[io.IO_msgterm],
	consDir bool,
	peer bool,
	segLen int) io.IO_seg2 {
	return let hopfields := consDir ?
		hopFieldsConsDir(raw, offset, 0, segLen) :
		hopFieldsNotConsDir(raw, offset, segLen - 1) in
		io.IO_seg2(io.IO_seg3_{
			AInfo :ainfo,
			UInfo : uinfo,
			ConsDir : consDir,
			Peer : peer,
			Past : segPast(hopfields, currHFIdx - 1),
			Future : segFuture(hopfields, currHFIdx),
			History : segHistory(hopfields, currHFIdx - 1),
		})
}

ghost
opaque
requires path.InfoFieldOffset(currINFIdx) + path.InfoLen <= offset
requires 0 < segLen
requires offset + path.HopLen * segLen <= len(raw)
requires 0 <= currHFIdx && currHFIdx <= segLen
requires 0 <= currINFIdx && currINFIdx < 3
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func currSeg(raw []byte,
	offset int,
	currINFIdx int,
	currHFIdx int,
	segLen int) io.IO_seg3 {
	return let ainfo := path.Timestamp(raw, currINFIdx) in
		let consDir := path.ConsDir(raw, currINFIdx) in
		let peer := path.Peer(raw, currINFIdx) in
		let uinfo := path.AbsUinfo(raw, currINFIdx) in
		segment(raw, offset, currHFIdx, ainfo, uinfo, consDir, peer, segLen)
}

ghost
opaque
requires 0 < seg1Len
requires 0 <= seg2Len
requires 0 <= seg3Len
requires pktLen(seg1Len, seg2Len, seg3Len) <= len(raw)
requires 1 <= currINFIdx && currINFIdx < 4
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func leftSeg(
	raw []byte,
	currINFIdx int,
	seg1Len int,
	seg2Len int,
	seg3Len int) option[io.IO_seg3] {
	return let offset := hopFieldOffset(numInfoFields(seg1Len, seg2Len, seg3Len), 0) in
		(currINFIdx == 1 && seg2Len > 0) ?
			some(currSeg(raw, offset + path.HopLen * seg1Len, currINFIdx, 0, seg2Len)) :
			((currINFIdx == 2 && seg2Len > 0 && seg3Len > 0) ?
				some(currSeg(raw, offset + path.HopLen * (seg1Len + seg2Len), currINFIdx, 0, seg3Len)) :
				none[io.IO_seg3])
}

ghost
opaque
requires 0 < seg1Len
requires 0 <= seg2Len
requires 0 <= seg3Len
requires pktLen(seg1Len, seg2Len, seg3Len) <= len(raw)
requires -1 <= currINFIdx && currINFIdx < 2
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func rightSeg(
	raw []byte,
	currINFIdx int,
	seg1Len int,
	seg2Len int,
	seg3Len int) option[io.IO_seg3] {
	return let offset := hopFieldOffset(numInfoFields(seg1Len, seg2Len, seg3Len), 0) in
		(currINFIdx == 1 && seg2Len > 0 && seg3Len > 0) ?
			some(currSeg(raw, offset + path.HopLen * seg1Len, currINFIdx, seg2Len, seg2Len)) :
			(currINFIdx == 0 && seg2Len > 0) ?
				some(currSeg(raw, offset, currINFIdx, seg1Len, seg1Len)) :
				none[io.IO_seg3]
}

ghost
opaque
requires 0 < seg1Len
requires 0 <= seg2Len
requires 0 <= seg3Len
requires pktLen(seg1Len, seg2Len, seg3Len) <= len(raw)
requires 2 <= currINFIdx && currINFIdx < 5
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func midSeg(
	raw []byte,
	currINFIdx int,
	seg1Len int,
	seg2Len int,
	seg3Len int) option[io.IO_seg3] {
	return let offset := hopFieldOffset(numInfoFields(seg1Len, seg2Len, seg3Len), 0) in
		(currINFIdx == 4 && seg2Len > 0) ?
			some(currSeg(raw, offset, 0, seg1Len, seg1Len)) :
			((currINFIdx == 2 && seg2Len > 0 && seg3Len > 0) ?
				some(currSeg(raw, offset + path.HopLen * (seg1Len + seg2Len), currINFIdx, 0, seg3Len)) :
				none[io.IO_seg3])
}

ghost
opaque
requires dp.Valid()
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
requires validPktMetaHdr(raw)
// ensures res != none[io.IO_pkt2] ==> len(get(res).CurrSeg.Future) > 0
opaque
decreases
pure func absPkt(dp io.DataPlaneSpec, raw []byte) (res option[io.IO_pkt2]) {
	return let _ := reveal validPktMetaHdr(raw) in
		let hdr := (unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56) in binary.BigEndian.Uint32(raw[0:4])) in
		let metaHdr := scion.DecodedFrom(hdr) in
		let currINFIdx := int(metaHdr.CurrINF) in
		let currHFIdx := int(metaHdr.CurrHF) in
		let seg1Len := int(metaHdr.SegLen[0]) in
		let seg2Len := int(metaHdr.SegLen[1]) in
		let seg3Len := int(metaHdr.SegLen[2]) in
		let segLen := lengthOfCurrSeg(currHFIdx, seg1Len, seg2Len, seg3Len) in
		let prevSegLen := lengthOfPrevSeg(currHFIdx, seg1Len, seg2Len, seg3Len) in
		let numINF := numInfoFields(seg1Len, seg2Len, seg3Len) in
		let offset := hopFieldOffset(numINF, 0) in
		some(io.IO_pkt2(io.IO_Packet2{
			CurrSeg : currSeg(raw, offset+prevSegLen, currINFIdx, currHFIdx-prevSegLen, segLen),
			LeftSeg : leftSeg(raw, currINFIdx + 1, seg1Len, seg2Len , seg3Len),
			MidSeg : midSeg(raw, currINFIdx + 2, seg1Len, seg2Len , seg3Len),
			RightSeg : rightSeg(raw, currINFIdx - 1, seg1Len, seg2Len , seg3Len),
		}))
}

ghost
requires len(hopfield.HVF.MsgTerm_Hash_.MsgTerm_MPair_2.MsgTerm_L_) > 0
decreases
pure func hvfSet(hopfield io.IO_HF) set[io.IO_msgterm] {
	return let l := hopfield.HVF.MsgTerm_Hash_.MsgTerm_MPair_2.MsgTerm_L_ in
		l[len(l) - 1].MsgTerm_FS_
}

ghost
requires 0 < len(hopfields)
requires 0 <= currHFIdx && currHFIdx <= len(hopfields)
requires forall idx int :: {hopfields[idx]} 0 <= idx && idx < len(hopfields) ==>
	len(hopfields[idx].HVF.MsgTerm_Hash_.MsgTerm_MPair_2.MsgTerm_L_) > 0
decreases
pure func uInfo(hopfields seq[io.IO_HF], currHFIdx int, consDir bool) set[io.IO_msgterm] {
	return currHFIdx + 1 >= len(hopfields) ?
		hvfSet(hopfields[len(hopfields)-1]) :
		(consDir ?
			hvfSet(hopfields[currHFIdx]) :
			hvfSet(hopfields[currHFIdx+1]))
}

ghost
decreases
pure func ifsToIO_ifs(ifs uint16) option[io.IO_ifs]{
	return ifs == 0 ? none[io.IO_ifs] : some(io.IO_ifs(ifs))
}

ghost
opaque
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func validPktMetaHdr(raw []byte) bool {
	return len(raw) > 4 &&
		unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56) in
		let hdr := binary.BigEndian.Uint32(raw[0:4]) in
		let metaHdr := scion.DecodedFrom(hdr) in
		let seg1 := int(metaHdr.SegLen[0]) in
		let seg2 := int(metaHdr.SegLen[1]) in
		let seg3 := int(metaHdr.SegLen[2]) in
		let base := scion.Base{metaHdr,
			numInfoFields(seg1, seg2, seg3),
			seg1 + seg2 + seg3} in
		metaHdr.InBounds() &&
		0 < metaHdr.SegLen[0] &&
		base.ValidCurrInfSpec() &&
		base.ValidCurrHfSpec() &&
		pktLen(seg1, seg2, seg3) <= len(raw)
}

ghost
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
ensures val.isIO_val_Unsupported
ensures val.IO_val_Unsupported_1 == ifsToIO_ifs(ingressID)
decreases
pure func absIO_val_Unsupported(raw []byte, ingressID uint16) (val io.IO_val) {
	return io.IO_val(io.IO_val_Unsupported{
		ifsToIO_ifs(ingressID),
		io.Unit(io.Unit_{}),
	})
}

ghost
opaque
requires dp.Valid()
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
ensures val.isIO_val_Pkt2 || val.isIO_val_Unsupported
decreases
pure func absIO_val(dp io.DataPlaneSpec, raw []byte, ingressID uint16) (val io.IO_val) {
	return (reveal validPktMetaHdr(raw) && absPkt(dp, raw) != none[io.IO_pkt2]) ?
		io.IO_val(io.IO_val_Pkt2{ifsToIO_ifs(ingressID), get(absPkt(dp, raw))}) :
		absIO_val_Unsupported(raw, ingressID)
}

ghost
requires acc(&d.localIA, _)
decreases
pure func (d *DataPlane) dpSpecWellConfiguredLocalIA(dp io.DataPlaneSpec) bool {
	return io.IO_as(d.localIA) == dp.Asid()
}

ghost
requires acc(&d.neighborIAs, _) && (d.neighborIAs != nil ==> acc(d.neighborIAs, _))
decreases
pure func (d *DataPlane) dpSpecWellConfiguredNeighborIAs(dp io.DataPlaneSpec) bool {
	return forall ifs uint16 :: {ifs in domain(d.neighborIAs)} ifs in domain(d.neighborIAs) ==>
		io.IO_ifs(ifs) in domain(dp.GetNeighborIAs()) &&
		io.IO_as(d.neighborIAs[ifs]) == dp.GetNeighborIA(io.IO_ifs(ifs))
}

ghost
decreases
pure func absLinktype(link topology.LinkType) io.IO_Link {
	 return link == topology.Core ? io.IO_Link(io.IO_PeerOrCore{}) :
		link == topology.Parent ? io.IO_Link(io.IO_CustProv{}) :
		link == topology.Child ? io.IO_Link(io.IO_ProvCust{}) :
		link == topology.Peer ? io.IO_Link(io.IO_PeerOrCore{}) :
		io.IO_Link(io.IO_NoLink{})
}

ghost
requires acc(&d.linkTypes, _) && (d.linkTypes != nil ==> acc(d.linkTypes, _))
decreases
pure func (d *DataPlane) dpSpecWellConfiguredLinkTypes(dp io.DataPlaneSpec) bool {
	return forall ifs uint16 :: {ifs in domain(d.linkTypes)} ifs in domain(d.linkTypes) ==>
		io.IO_ifs(ifs) in domain(dp.GetLinkTypes()) &&
		absLinktype(d.linkTypes[ifs]) == dp.GetLinkType(io.IO_ifs(ifs))
}

ghost
opaque
requires acc(d.Mem(), _)
decreases
pure func (d *DataPlane) DpAgreesWithSpec(dp io.DataPlaneSpec) bool {
	return unfolding acc(d.Mem(), _) in
		d.dpSpecWellConfiguredLocalIA(dp)     &&
		d.dpSpecWellConfiguredNeighborIAs(dp) &&
		d.dpSpecWellConfiguredLinkTypes(dp)
}

ghost
requires dp.Valid()
requires acc(msg.Mem(), R50)
decreases
pure func MsgToAbsVal(dp io.DataPlaneSpec, msg *ipv4.Message, ingressID uint16) (res io.IO_val) {
	return unfolding acc(msg.Mem(), R50) in
		absIO_val(dp, msg.Buffers[0], ingressID)
}
