// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package router

import (
	"github.com/scionproto/scion/pkg/slayers"
	"github.com/scionproto/scion/pkg/slayers/path"
	"github.com/scionproto/scion/pkg/slayers/path/scion"
	"github.com/scionproto/scion/private/topology"
	"github.com/scionproto/scion/pkg/addr"
	"golang.org/x/net/ipv4"

	"verification/dependencies/encoding/binary"
	"verification/io"
	sl "verification/utils/slices"
	. "verification/utils/definitions"
)

ghost
opaque
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
requires slayers.ValidPktMetaHdr(raw)
decreases
pure func absPkt(raw []byte) (res io.IO_pkt2) {
	return let _ := reveal slayers.ValidPktMetaHdr(raw) in
		let headerOffset := slayers.GetAddressOffset(raw) in
		let headerOffsetWithMetaLen := headerOffset + scion.MetaLen in
		let hdr := (unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56) in
			binary.BigEndian.Uint32(raw[headerOffset:headerOffset+scion.MetaLen])) in
		let metaHdr := scion.DecodedFrom(hdr) in
		let currInfIdx := int(metaHdr.CurrINF) in
		let currHfIdx := int(metaHdr.CurrHF) in
		let seg1Len := int(metaHdr.SegLen[0]) in
		let seg2Len := int(metaHdr.SegLen[1]) in
		let seg3Len := int(metaHdr.SegLen[2]) in
		let segLen := scion.LengthOfCurrSeg(currHfIdx, seg1Len, seg2Len, seg3Len) in
		let prevSegLen := scion.LengthOfPrevSeg(currHfIdx, seg1Len, seg2Len, seg3Len) in
		let numINF := scion.NumInfoFields(seg1Len, seg2Len, seg3Len) in
		let offset := scion.HopFieldOffset(numINF, 0, headerOffsetWithMetaLen) in
		io.IO_pkt2(io.IO_Packet2{
			CurrSeg : scion.CurrSeg(raw, offset + path.HopLen * prevSegLen, currInfIdx, currHfIdx-prevSegLen, segLen, headerOffsetWithMetaLen),
			LeftSeg : scion.LeftSeg(raw, currInfIdx + 1, seg1Len, seg2Len , seg3Len, headerOffsetWithMetaLen),
			MidSeg : scion.MidSeg(raw, currInfIdx + 2, seg1Len, seg2Len , seg3Len, headerOffsetWithMetaLen),
			RightSeg : scion.RightSeg(raw, currInfIdx - 1, seg1Len, seg2Len , seg3Len, headerOffsetWithMetaLen),
		})
}

ghost
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
ensures val.isIO_val_Unsupported
ensures val.IO_val_Unsupported_1 == path.ifsToIO_ifs(ingressID)
decreases
pure func absIO_val_Unsupported(raw []byte, ingressID uint16) (val io.IO_val) {
	return io.IO_val(io.IO_val_Unsupported{
		path.ifsToIO_ifs(ingressID),
		io.Unit(io.Unit_{}),
	})
}

ghost
opaque
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
ensures val.isIO_val_Pkt2 || val.isIO_val_Unsupported
decreases
pure func absIO_val(raw []byte, ingressID uint16) (val io.IO_val) {
	return (reveal slayers.ValidPktMetaHdr(raw) && slayers.IsSupportedPkt(raw)) ?
		io.IO_val(io.IO_val_Pkt2{path.ifsToIO_ifs(ingressID), absPkt(raw)}) :
		absIO_val_Unsupported(raw, ingressID)
}

ghost
requires respr.OutPkt != nil ==>
	acc(sl.AbsSlice_Bytes(respr.OutPkt, 0, len(respr.OutPkt)), R56)
decreases
pure func absReturnErr(respr processResult) (val io.IO_val) {
	return respr.OutPkt == nil ? io.IO_val_Unit{} :
		absIO_val(respr.OutPkt, respr.EgressID)
}

ghost
requires acc(&d.localIA, _)
decreases
pure func (d *DataPlane) dpSpecWellConfiguredLocalIA(dp io.DataPlaneSpec) bool {
	return io.IO_as(d.localIA) == dp.Asid()
}

ghost
requires acc(&d.neighborIAs, _) && (d.neighborIAs != nil ==> acc(d.neighborIAs, _))
decreases
pure func (d *DataPlane) dpSpecWellConfiguredNeighborIAs(dp io.DataPlaneSpec) bool {
	return forall ifs uint16 :: {ifs in domain(d.neighborIAs)} ifs in domain(d.neighborIAs) ==>
		io.IO_ifs(ifs) in domain(dp.GetNeighborIAs()) &&
		io.IO_as(d.neighborIAs[ifs]) == dp.GetNeighborIA(io.IO_ifs(ifs))
}

ghost
decreases
pure func absLinktype(link topology.LinkType) io.IO_Link {
	 return link == topology.Core ? io.IO_Link(io.IO_Core{}) :
		link == topology.Parent ? io.IO_Link(io.IO_CustProv{}) :
		link == topology.Child ? io.IO_Link(io.IO_ProvCust{}) :
		link == topology.Peer ? io.IO_Link(io.IO_Core{}) :
		io.IO_Link(io.IO_NoLink{})
}

ghost
requires acc(&d.linkTypes, _) && (d.linkTypes != nil ==> acc(d.linkTypes, _))
decreases
pure func (d *DataPlane) dpSpecWellConfiguredLinkTypes(dp io.DataPlaneSpec) bool {
	return forall ifs uint16 :: {ifs in domain(d.linkTypes)} ifs in domain(d.linkTypes) ==>
		io.IO_ifs(ifs) in domain(dp.GetLinkTypes()) &&
		absLinktype(d.linkTypes[ifs]) == dp.GetLinkType(io.IO_ifs(ifs))
}

ghost
opaque
requires acc(d.Mem(), _)
decreases
pure func (d *DataPlane) DpAgreesWithSpec(dp io.DataPlaneSpec) bool {
	return unfolding acc(d.Mem(), _) in
		d.dpSpecWellConfiguredLocalIA(dp)     &&
		d.dpSpecWellConfiguredNeighborIAs(dp) &&
		d.dpSpecWellConfiguredLinkTypes(dp)
}

ghost
requires acc(d.Mem(), _)
requires d.DpAgreesWithSpec(dp)
requires d.WellConfigured()
ensures  acc(&d.linkTypes, _)
ensures  d.linkTypes != nil ==> acc(d.linkTypes, _) && !(0 in domain(d.linkTypes))
ensures  d.dpSpecWellConfiguredLinkTypes(dp)
decreases
func (d *DataPlane) LinkTypesLemma(dp io.DataPlaneSpec) {
	reveal d.WellConfigured()
	reveal d.DpAgreesWithSpec(dp)
	assert !(0 in d.getDomLinkTypes())
	unfold acc(d.Mem(), _)
	assert !(0 in domain(d.linkTypes))
}

ghost
requires acc(d.Mem(), _)
requires d.DpAgreesWithSpec(dp)
requires d.WellConfigured()
requires egressID in d.getDomExternal()
ensures  egressID != 0
ensures  io.IO_ifs(egressID) in domain(dp.GetNeighborIAs())
decreases
func (d *DataPlane) EgressIDNotZeroLemma(egressID uint16, dp io.DataPlaneSpec) {
	reveal d.WellConfigured()
	reveal d.DpAgreesWithSpec(dp)
}

ghost
requires acc(d.Mem(), _)
requires acc(&d.external, _)
requires d.external != nil ==> acc(d.external, _)
ensures  acc(d.Mem(), _)
ensures  acc(&d.external, _)
ensures  d.external != nil ==> acc(d.external, _)
ensures  d.getDomExternal() == domain(d.external)
decreases
func (d *DataPlane) getDomExternalLemma() {
	if (d.external != nil) {
		assert reveal d.getDomExternal() == unfolding acc(d.Mem(), _) in
			(unfolding acc(accBatchConn(d.external), _) in
					domain(d.external))
	} else {
		assert reveal d.getDomExternal() ==
			unfolding acc(d.Mem(), _) in set[uint16]{}
	}
}

ghost
requires acc(msg.Mem(), R50)
decreases
pure func MsgToAbsVal(msg *ipv4.Message, ingressID uint16) (res io.IO_val) {
	return unfolding acc(msg.Mem(), R50) in
		absIO_val(msg.Buffers[0], ingressID)
}
