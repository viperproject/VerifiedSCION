// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package router

import (
	"github.com/scionproto/scion/pkg/slayers"
	"github.com/scionproto/scion/pkg/slayers/path"
	"github.com/scionproto/scion/pkg/slayers/path/scion"
	io "verification/io"
	sl "github.com/scionproto/scion/verification/utils/slices"
	. "verification/utils/definitions"
)

ghost
requires  acc(&p.d, R50) && acc(p.d.Mem(), _)
requires  acc(&p.path, R21)
requires  acc(sl.AbsSlice_Bytes(ub, 0, len(ub)), R20)
requires  acc(sl.AbsSlice_Bytes(ubPath, 0, len(ubPath)), R20)
requires  acc(p.path.Mem(ubPath), R20)
requires  acc(p.scionLayer.Mem(ub), R20)
requires  p.path === p.scionLayer.GetPath(ub)
requires  acc(&p.hopField, R20)
requires  p.path.CorrectlyDecodedHF_RawOffsetIndex(p.hopField, ubPath)
requires  dp.Valid()
requires  slayers.ValidPktMetaHdr(ub) && p.scionLayer.EqAbsHeader(ub)
requires  len(absPkt(dp, ub).CurrSeg.Future) > 0
ensures   acc(sl.AbsSlice_Bytes(ub, 0, len(ub)), R20)
ensures   acc(sl.AbsSlice_Bytes(ubPath, 0, len(ubPath)), R20)
ensures   acc(p.scionLayer.Mem(ub), R20)
ensures   acc(&p.path, R21)
ensures   acc(p.path.Mem(ub), R20)
ensures   acc(&p.d, R50)
ensures   acc(&p.hopField, R20)
ensures   slayers.ValidPktMetaHdr(ub) && p.scionLayer.EqAbsHeader(ub)
ensures   len(absPkt(dp, ub).CurrSeg.Future) > 0
ensures   p.EqAbsHopField(absPkt(dp, ub))
decreases
func (p *scionPacketProcessor) CurrentHopFieldBytesLemma(dp io.DataPlaneSpec , ub []byte, ubPath []byte)
