// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package router

import (
	sl "verification/utils/slices"
	"verification/io"
	. "verification/utils/definitions"
	"verification/dependencies/encoding/binary"
	"github.com/scionproto/scion/pkg/slayers"
	"github.com/scionproto/scion/pkg/slayers/path"
	"github.com/scionproto/scion/pkg/slayers/path/scion"
)

// Some things in this file can be simplified. Nonetheless, the important definition here
// is absIO_valWidenLemma. Everything else can be seen as an implementation detail.
ghost
requires  0 <= length && length <= len(raw)
requires  acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R49)
requires  acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), R49)
preserves dp.Valid()
ensures   acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R49)
ensures   acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), R49)
ensures   absIO_val(dp, raw[:length], ingressID).isIO_val_Pkt2 ==>
	absIO_val(dp, raw[:length], ingressID) == absIO_val(dp, raw, ingressID)
decreases
func absIO_valWidenLemma(dp io.DataPlaneSpec, raw []byte, ingressID uint16, length int) {
	var ret1 io.IO_val
	var ret2 io.IO_val

	if (slayers.ValidPktMetaHdr(raw[:length]) && slayers.IsSupportedPkt(raw[:length])) {
		ValidPktMetaHdrWidenLemma(raw, length)
		assert slayers.ValidPktMetaHdr(raw)
		IsSupportedPktWidenLemma(raw, length)
		assert slayers.IsSupportedPkt(raw)
		absPktWidenLemma(dp, raw, length)

		ret1 = io.IO_val(io.IO_val_Pkt2{path.ifsToIO_ifs(ingressID), absPkt(dp, raw)})
		ret2 = io.IO_val(io.IO_val_Pkt2{path.ifsToIO_ifs(ingressID), absPkt(dp, raw[:length])})
		assert ret1 == reveal absIO_val(dp, raw, ingressID)
		assert ret2 == reveal absIO_val(dp, raw[:length], ingressID)
		assert ret1 == ret2
		assert absIO_val(dp, raw[:length], ingressID).isIO_val_Pkt2 ==>
			absIO_val(dp, raw[:length], ingressID) == absIO_val(dp, raw, ingressID)
	} else {
		assert !(reveal absIO_val(dp, raw[:length], ingressID).isIO_val_Pkt2)
	}
}

ghost
requires 0 <= length && length <= len(raw)
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R51)
requires acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), R51)
requires slayers.ValidPktMetaHdr(raw[:length])
ensures  acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R51)
ensures  acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), R51)
ensures  slayers.ValidPktMetaHdr(raw)
decreases
func ValidPktMetaHdrWidenLemma(raw []byte, length int) {
	unfold acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
	unfold acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), R56)
	reveal slayers.ValidPktMetaHdr(raw[:length])
	ret1 := reveal slayers.ValidPktMetaHdr(raw)
	ret2 := reveal slayers.ValidPktMetaHdr(raw[:length])
	assert ret1 == ret2
	fold acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
	fold acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), R56)
}

ghost
requires 0 <= length && length <= len(raw)
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R51)
requires acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), R51)
requires slayers.IsSupportedPkt(raw[:length])
ensures  acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R51)
ensures  acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), R51)
ensures  slayers.IsSupportedPkt(raw)
decreases
func IsSupportedPktWidenLemma(raw []byte, length int) {
	unfold acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
	unfold acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), R56)
	reveal slayers.IsSupportedPkt(raw[:length])
	ret1 := reveal slayers.IsSupportedPkt(raw)
	ret2 := reveal slayers.IsSupportedPkt(raw[:length])
	assert ret1 == ret2
	fold acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
	fold acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), R56)
}

ghost
requires  0 <= length && length <= len(raw)
requires dp.Valid()
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R50)
requires acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), R50)
requires slayers.ValidPktMetaHdr(raw)
requires slayers.ValidPktMetaHdr(raw[:length])
ensures  acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R50)
ensures  acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), R50)
ensures  slayers.ValidPktMetaHdr(raw)
ensures  slayers.ValidPktMetaHdr(raw[:length])
ensures  absPkt(dp, raw) == absPkt(dp, raw[:length])
decreases
func absPktWidenLemma(dp io.DataPlaneSpec, raw []byte, length int) {

	reveal slayers.ValidPktMetaHdr(raw)
	reveal slayers.ValidPktMetaHdr(raw[:length])
	headerOffset1 := slayers.GetAddressOffset(raw)
	headerOffset2 := slayers.GetAddressOffset(raw[:length])

	assert forall k int :: {&raw[k]} headerOffset1 <= k && k < headerOffset1 + scion.MetaLen ==>
		&raw[headerOffset1:headerOffset1+scion.MetaLen][k-headerOffset1] == &raw[k]
	assert forall k int :: {&raw[:length][k]} headerOffset2 <= k && k < headerOffset2 + scion.MetaLen ==>
		&raw[headerOffset2:headerOffset2+scion.MetaLen][k-headerOffset2] == &raw[k]
	hdr1 := unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R51) in binary.BigEndian.Uint32(raw[headerOffset1:headerOffset1+scion.MetaLen])
	hdr2 := unfolding acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), R51) in binary.BigEndian.Uint32(raw[:length][headerOffset2:headerOffset2+scion.MetaLen])
	assert unfolding acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), R51) in binary.BigEndian.Uint32(raw[:length][headerOffset2:headerOffset2+scion.MetaLen]) == unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R51) in binary.BigEndian.Uint32(raw[headerOffset1:headerOffset1+scion.MetaLen])
	assert hdr1 == hdr2

	metaHdr1 := scion.DecodedFrom(hdr1)
	metaHdr2 := scion.DecodedFrom(hdr2)
	assert metaHdr1 == metaHdr2

	currINFIdx1 := int(metaHdr1.CurrINF)
	currINFIdx2 := int(metaHdr2.CurrINF)
	assert currINFIdx1 == currINFIdx2

	currHFIdx1 := int(metaHdr1.CurrHF)
	currHFIdx2 := int(metaHdr2.CurrHF)
	assert currHFIdx1 == currHFIdx2

	seg1Len1 := int(metaHdr1.SegLen[0])
	seg1Len2 := int(metaHdr2.SegLen[0])
	assert seg1Len1 == seg1Len2

	seg2Len1 := int(metaHdr1.SegLen[1])
	seg2Len2 := int(metaHdr2.SegLen[1])
	assert seg2Len1 == seg2Len2

	seg3Len1 := int(metaHdr1.SegLen[2])
	seg3Len2 := int(metaHdr2.SegLen[2])
	assert seg3Len1 == seg3Len2

	segLen1 := scion.LengthOfCurrSeg(currHFIdx1, seg1Len1, seg2Len1, seg3Len1)
	segLen2 := scion.LengthOfCurrSeg(currHFIdx2, seg1Len2, seg2Len2, seg3Len2)
	assert segLen1 == segLen2

	prevSegLen1 := scion.LengthOfPrevSeg(currHFIdx1, seg1Len1, seg2Len1, seg3Len1)
	prevSegLen2 := scion.LengthOfPrevSeg(currHFIdx2, seg1Len2, seg2Len2, seg3Len2)
	assert prevSegLen1 == prevSegLen2

	numINF1 := scion.NumInfoFields(seg1Len1, seg2Len1, seg3Len1)
	numINF2 := scion.NumInfoFields(seg1Len2, seg2Len2, seg3Len2)
	assert numINF1 == numINF2

	offset1 := scion.HopFieldOffset(numINF1, 0, headerOffset1)
	offset2 := scion.HopFieldOffset(numINF2, 0, headerOffset2)
	assert offset1 == offset2

	currSegWidenLemma(raw, offset1+prevSegLen1, currINFIdx1, currHFIdx1-prevSegLen1, segLen1, headerOffset1, length)
	currSeg1 := scion.CurrSeg(raw, offset1+prevSegLen1, currINFIdx1, currHFIdx1-prevSegLen1, segLen1, headerOffset1)
	currSeg2 := scion.CurrSeg(raw[:length], offset2+prevSegLen2, currINFIdx2, currHFIdx2-prevSegLen2, segLen2, headerOffset2)
	assert currSeg1 == currSeg2
	
	leftSegWidenLemma(raw, currINFIdx1 + 1, seg1Len1, seg2Len1 , seg3Len1, headerOffset1, length)
	leftSeg1 := scion.LeftSeg(raw, currINFIdx1 + 1, seg1Len1, seg2Len1 , seg3Len1, headerOffset1)
	leftSeg2 := scion.LeftSeg(raw[:length], currINFIdx2 + 1, seg1Len2, seg2Len2 , seg3Len2, headerOffset2)
	assert leftSeg1 == leftSeg2
	
	midSegWidenLemma(raw, currINFIdx1 + 2, seg1Len1, seg2Len1 , seg3Len1, headerOffset1, length)
	midSeg1 := scion.MidSeg(raw, currINFIdx1 + 2, seg1Len1, seg2Len1 , seg3Len1, headerOffset1)
	midSeg2 := scion.MidSeg(raw[:length], currINFIdx2 + 2, seg1Len2, seg2Len2 , seg3Len2, headerOffset2)
	assert midSeg1 == midSeg2
	
	rightSegWidenLemma(raw, currINFIdx1 - 1, seg1Len1, seg2Len1 , seg3Len1, headerOffset1, length)
	rightSeg1 := scion.RightSeg(raw, currINFIdx1 - 1, seg1Len1, seg2Len1 , seg3Len1, headerOffset1)
	rightSeg2 := scion.RightSeg(raw[:length], currINFIdx2 - 1, seg1Len2, seg2Len2 , seg3Len2, headerOffset2)
	assert rightSeg1 == rightSeg2
	
	ret1 := io.IO_pkt2(io.IO_Packet2{
		CurrSeg : currSeg1,
		LeftSeg : leftSeg1,
		MidSeg : midSeg1,
		RightSeg : rightSeg1,
	})
	ret2 := io.IO_pkt2(io.IO_Packet2{
		CurrSeg : currSeg2,
		LeftSeg : leftSeg2,
		MidSeg : midSeg2,
		RightSeg : rightSeg2,
	})
	
	reveal absPkt(dp, raw)
	reveal absPkt(dp, raw[:length])
	assert ret1 == absPkt(dp, raw)
	assert ret2 == absPkt(dp, raw[:length])
	assert ret1 == ret2
}

ghost
requires  0 <= headerOffset
requires  path.InfoFieldOffset(currINFIdx, headerOffset) + path.InfoLen <= offset
requires  0 < segLen
requires  offset + path.HopLen * segLen <= length
requires length <= len(raw)
requires  0 <= currHFIdx && currHFIdx <= segLen
requires  0 <= currINFIdx && currINFIdx < 3
preserves acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R51)
preserves acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), R51)
ensures   scion.CurrSeg(raw, offset, currINFIdx, currHFIdx, segLen, headerOffset) ==
	scion.CurrSeg(raw[:length], offset, currINFIdx, currHFIdx, segLen, headerOffset)
decreases
func currSegWidenLemma(raw []byte, offset int, currINFIdx int, currHFIdx int, segLen int, headerOffset int, length int) {
	unfold acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R53)
	unfold acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), R53)

	ainfo1 := path.Timestamp(raw, currINFIdx, headerOffset)
	ainfo2 := path.Timestamp(raw[:length], currINFIdx, headerOffset)
	assert ainfo1 == ainfo2

	uinfo1 := path.AbsUinfo(raw, currINFIdx, headerOffset)
	uinfo2 := path.AbsUinfo(raw[:length], currINFIdx, headerOffset)
	assert uinfo1 == uinfo2

	consDir1 := path.ConsDir(raw, currINFIdx, headerOffset)
	consDir2 := path.ConsDir(raw[:length], currINFIdx, headerOffset)
	assert consDir1 == consDir2

	peer1 := path.Peer(raw, currINFIdx, headerOffset)
	peer2 := path.Peer(raw[:length], currINFIdx, headerOffset)
	assert peer1 == peer2

	segmentWidenLemma(raw, offset, currHFIdx, ainfo1, uinfo1, consDir1, peer1, segLen, length)
	ret1 := scion.segment(raw, offset, currHFIdx, ainfo1, uinfo1, consDir1, peer1, segLen)
	ret2 := scion.segment(raw[:length], offset, currHFIdx, ainfo2, uinfo2, consDir2, peer2, segLen)
	assert ret1 == reveal scion.CurrSeg(raw, offset, currINFIdx, currHFIdx, segLen, headerOffset)
	assert ret2 == reveal scion.CurrSeg(raw[:length], offset, currINFIdx, currHFIdx, segLen, headerOffset)
	assert ret1 == ret2
	fold acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R53)
	fold acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), R53)
}

ghost
requires 0 <= offset
requires 0 < segLen
requires 0 <= currHFIdx && currHFIdx <= segLen
requires length <= len(raw)
requires offset + path.HopLen * segLen <= length
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R52)
requires acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), R52)
ensures  acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R52)
ensures  acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), R52)
ensures  scion.segment(raw, offset, currHFIdx, ainfo, uinfo, consDir, peer, segLen) ==
	scion.segment(raw[:length], offset, currHFIdx, ainfo, uinfo, consDir, peer, segLen)
decreases
func segmentWidenLemma(raw []byte, offset int, currHFIdx int, ainfo io.IO_ainfo, uinfo set[io.IO_msgterm], consDir bool, peer bool, segLen int, length int) {
	newP := (R52 + R53)/2
	assert R53 < newP && newP < R52
	hopFieldsWidenLemma(raw, offset, 0, segLen, length, newP)
	hopfields1 := scion.hopFields(raw, offset, 0, segLen)
	hopfields2 := scion.hopFields(raw[:length], offset, 0, segLen)
	assert hopfields1 == hopfields2

	ret1 := io.IO_seg2(io.IO_seg3_{
		AInfo :ainfo,
		UInfo : uinfo,
		ConsDir : consDir,
		Peer : peer,
		Past : scion.segPast(hopfields1, currHFIdx - 1),
		Future : scion.segFuture(hopfields1, currHFIdx),
		History : scion.segHistory(hopfields1, currHFIdx - 1),
	})
	ret2 := io.IO_seg2(io.IO_seg3_{
		AInfo :ainfo,
		UInfo : uinfo,
		ConsDir : consDir,
		Peer : peer,
		Past : scion.segPast(hopfields2, currHFIdx - 1),
		Future : scion.segFuture(hopfields2, currHFIdx),
		History : scion.segHistory(hopfields2, currHFIdx - 1),
	})
	assert ret1 == scion.segment(raw, offset, currHFIdx, ainfo, uinfo, consDir, peer, segLen)
	assert ret2 == scion.segment(raw[:length], offset, currHFIdx, ainfo, uinfo, consDir, peer, segLen)
	assert ret1 == ret2
}

ghost
requires  0 <= middle
requires  middle + path.HopLen <= length
requires  length <= len(raw)
preserves acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R54)
preserves acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), R54)
ensures   path.BytesToIO_HF(raw, 0, middle, len(raw)) ==
	path.BytesToIO_HF(raw[:length], 0, middle, length)
decreases
func BytesToIO_HFWidenLemma(raw []byte, middle int, length int) {
	unfold acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R55)
	unfold acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), R55)
	hfBytes1 := path.BytesToIO_HF(raw, 0, middle, len(raw))
	hfBytes2 := path.BytesToIO_HF(raw[:length], 0, middle, length)
	assert hfBytes1.EgIF2 == hfBytes2.EgIF2
	assert hfBytes1.InIF2 == hfBytes2.InIF2
	assert hfBytes1.HVF == hfBytes2.HVF
	fold acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R55)
	fold acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), R55)
}

ghost
requires  R53 < p
requires  0 <= offset
requires  0 <= currHFIdx && currHFIdx <= segLen
requires  offset + path.HopLen * segLen <= length
requires  length <= len(raw)
preserves acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), p)
preserves acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), p)
ensures   scion.hopFields(raw, offset, currHFIdx, segLen) ==
	scion.hopFields(raw[:length], offset, currHFIdx, segLen)
decreases segLen - currHFIdx
func hopFieldsWidenLemma(raw []byte, offset int, currHFIdx int, segLen int, length int, p perm) {
	if currHFIdx == segLen {
		ret := seq[io.IO_HF]{}
		assert ret == scion.hopFields(raw, offset, currHFIdx, segLen)
		assert ret == scion.hopFields(raw[:length], offset, currHFIdx, segLen)
	} else {
		BytesToIO_HFWidenLemma(raw, offset + path.HopLen * currHFIdx, length)
		hf1 := path.BytesToIO_HF(raw, 0, offset + path.HopLen * currHFIdx, len(raw))
		hf2 := path.BytesToIO_HF(raw[:length], 0, offset + path.HopLen * currHFIdx, length)
		assert hf1 == hf2

		newP := (p + R53)/2
		assert R53 < newP && newP < p
		hopFieldsWidenLemma(raw, offset, currHFIdx + 1, segLen, length, newP)
		ret1 := seq[io.IO_HF]{hf1} ++ scion.hopFields(raw, offset, currHFIdx + 1, segLen)
		ret2 := seq[io.IO_HF]{hf2} ++ scion.hopFields(raw[:length], offset, currHFIdx + 1, segLen)
		assert ret1 == scion.hopFields(raw, offset, currHFIdx, segLen)
		assert ret2 == scion.hopFields(raw[:length], offset, currHFIdx, segLen)
		assert ret1 == ret2
	}
}

ghost
requires  0 <= headerOffset
requires  0 < seg1Len
requires  0 <= seg2Len
requires  0 <= seg3Len
requires  0 <= length && length <= len(raw)
requires  scion.pktLen(seg1Len, seg2Len, seg3Len, headerOffset) <= length
requires 1 <= currINFIdx && currINFIdx < 4
preserves acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R51)
preserves acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), R51)
ensures   scion.LeftSeg(raw, currINFIdx, seg1Len, seg2Len, seg3Len, headerOffset) ==
	scion.LeftSeg(raw[:length], currINFIdx, seg1Len, seg2Len, seg3Len, headerOffset)
decreases
func leftSegWidenLemma(raw []byte, currINFIdx int, seg1Len int, seg2Len int, seg3Len int, headerOffset int, length int) {
	offset := scion.HopFieldOffset(scion.NumInfoFields(seg1Len, seg2Len, seg3Len), 0, headerOffset)
	if currINFIdx == 1 && seg2Len > 0 {
		currSegWidenLemma(raw, offset + path.HopLen * seg1Len, currINFIdx, 0, seg2Len, headerOffset, length)
		ret1 := some(scion.CurrSeg(raw, offset + path.HopLen * seg1Len, currINFIdx, 0, seg2Len, headerOffset))
		ret2 := some(scion.CurrSeg(raw[:length], offset + path.HopLen * seg1Len, currINFIdx, 0, seg2Len, headerOffset))
		assert ret1 == reveal scion.LeftSeg(raw, currINFIdx, seg1Len, seg2Len, seg3Len, headerOffset)
		assert ret2 == reveal scion.LeftSeg(raw[:length], currINFIdx, seg1Len, seg2Len, seg3Len, headerOffset)
		assert ret1 == ret2
	} else if currINFIdx == 2 && seg2Len > 0 && seg3Len > 0 {
		currSegWidenLemma(raw, offset + path.HopLen * (seg1Len + seg2Len), currINFIdx, 0, seg3Len, headerOffset, length)
		ret1 := some(scion.CurrSeg(raw, offset + path.HopLen * (seg1Len + seg2Len), currINFIdx, 0, seg3Len, headerOffset))
		ret2 := some(scion.CurrSeg(raw[:length], offset + path.HopLen * (seg1Len + seg2Len), currINFIdx, 0, seg3Len, headerOffset))
		assert ret1 == reveal scion.LeftSeg(raw, currINFIdx, seg1Len, seg2Len, seg3Len, headerOffset)
		assert ret2 == reveal scion.LeftSeg(raw[:length], currINFIdx, seg1Len, seg2Len, seg3Len, headerOffset)
		assert ret1 == ret2
	} else {
		ret := none[io.IO_seg3]
		assert ret == reveal scion.LeftSeg(raw, currINFIdx, seg1Len, seg2Len, seg3Len, headerOffset)
		assert ret == reveal scion.LeftSeg(raw[:length], currINFIdx, seg1Len, seg2Len, seg3Len, headerOffset)
	}
}

ghost
requires  0 <= headerOffset
requires  0 < seg1Len
requires  0 <= seg2Len
requires  0 <= seg3Len
requires  0 <= length && length <= len(raw)
requires  scion.pktLen(seg1Len, seg2Len, seg3Len, headerOffset) <= length
requires  -1 <= currINFIdx && currINFIdx < 2
preserves acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R51)
preserves acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), R51)
ensures   scion.RightSeg(raw, currINFIdx, seg1Len, seg2Len, seg3Len, headerOffset) ==
	scion.RightSeg(raw[:length], currINFIdx, seg1Len, seg2Len, seg3Len, headerOffset)
decreases
func rightSegWidenLemma(raw []byte, currINFIdx int, seg1Len int, seg2Len int, seg3Len int, headerOffset int, length int) {
	offset := scion.HopFieldOffset(scion.NumInfoFields(seg1Len, seg2Len, seg3Len), 0, headerOffset)
	if currINFIdx == 1 && seg2Len > 0 && seg3Len > 0 {
		currSegWidenLemma(raw, offset + path.HopLen * seg1Len, currINFIdx, seg2Len, seg2Len, headerOffset, length)
		ret1 := some(scion.CurrSeg(raw, offset + path.HopLen * seg1Len, currINFIdx, seg2Len, seg2Len, headerOffset))
		ret2 := some(scion.CurrSeg(raw[:length], offset + path.HopLen * seg1Len, currINFIdx, seg2Len, seg2Len, headerOffset))
		assert ret1 == reveal scion.RightSeg(raw, currINFIdx, seg1Len, seg2Len, seg3Len, headerOffset)
		assert ret2 == reveal scion.RightSeg(raw[:length], currINFIdx, seg1Len, seg2Len, seg3Len, headerOffset)
		assert ret1 == ret2
	} else if currINFIdx == 0 && seg2Len > 0 {
		currSegWidenLemma(raw, offset, currINFIdx, seg1Len, seg1Len, headerOffset, length)
		ret1 := some(scion.CurrSeg(raw, offset, currINFIdx, seg1Len, seg1Len, headerOffset))
		ret2 := some(scion.CurrSeg(raw[:length], offset, currINFIdx, seg1Len, seg1Len, headerOffset))
		assert ret1 == reveal scion.RightSeg(raw, currINFIdx, seg1Len, seg2Len, seg3Len, headerOffset)
		assert ret2 == reveal scion.RightSeg(raw[:length], currINFIdx, seg1Len, seg2Len, seg3Len, headerOffset)
		assert ret1 == ret2
	} else {
		ret := none[io.IO_seg3]
		assert ret == reveal scion.RightSeg(raw, currINFIdx, seg1Len, seg2Len, seg3Len, headerOffset)
		assert ret == reveal scion.RightSeg(raw[:length], currINFIdx, seg1Len, seg2Len, seg3Len, headerOffset)
	}
}


ghost
requires  0 <= headerOffset
requires  0 < seg1Len
requires  0 <= seg2Len
requires  0 <= seg3Len
requires  2 <= currINFIdx && currINFIdx < 5
requires  0 <= length && length <= len(raw)
requires  scion.pktLen(seg1Len, seg2Len, seg3Len, headerOffset) <= length
preserves acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R51)
preserves acc(sl.AbsSlice_Bytes(raw[:length], 0, len(raw[:length])), R51)
ensures   scion.MidSeg(raw, currINFIdx, seg1Len, seg2Len, seg3Len, headerOffset) ==
	scion.MidSeg(raw[:length], currINFIdx, seg1Len, seg2Len, seg3Len, headerOffset)
decreases
func midSegWidenLemma(raw []byte, currINFIdx int, seg1Len int, seg2Len int, seg3Len int, headerOffset int, length int) {
	offset := scion.HopFieldOffset(scion.NumInfoFields(seg1Len, seg2Len, seg3Len), 0, headerOffset)
	if currINFIdx == 4 && seg2Len > 0 {
		currSegWidenLemma(raw, offset, 0, seg1Len, seg1Len, headerOffset, length)
		ret1 := some(scion.CurrSeg(raw, offset, 0, seg1Len, seg1Len, headerOffset))
		ret2 := some(scion.CurrSeg(raw[:length], offset, 0, seg1Len, seg1Len, headerOffset))
		assert ret1 == reveal scion.MidSeg(raw, currINFIdx, seg1Len, seg2Len, seg3Len, headerOffset)
		assert ret2 == reveal scion.MidSeg(raw[:length], currINFIdx, seg1Len, seg2Len, seg3Len, headerOffset)
		assert ret1 == ret2
	} else if currINFIdx == 2 && seg2Len > 0 && seg3Len > 0 {
		currSegWidenLemma(raw, offset + path.HopLen * (seg1Len + seg2Len), currINFIdx, 0, seg3Len, headerOffset, length)
		ret1 := some(scion.CurrSeg(raw, offset + path.HopLen * (seg1Len + seg2Len), currINFIdx, 0, seg3Len, headerOffset))
		ret2 := some(scion.CurrSeg(raw[:length], offset + path.HopLen * (seg1Len + seg2Len), currINFIdx, 0, seg3Len, headerOffset))
		assert ret1 == reveal scion.MidSeg(raw, currINFIdx, seg1Len, seg2Len, seg3Len, headerOffset)
		assert ret2 == reveal scion.MidSeg(raw[:length], currINFIdx, seg1Len, seg2Len, seg3Len, headerOffset)
		assert ret1 == ret2
	} else {
		ret := none[io.IO_seg3]
		assert ret == reveal scion.MidSeg(raw, currINFIdx, seg1Len, seg2Len, seg3Len, headerOffset)
		assert ret == reveal scion.MidSeg(raw[:length], currINFIdx, seg1Len, seg2Len, seg3Len, headerOffset)
	}
}
