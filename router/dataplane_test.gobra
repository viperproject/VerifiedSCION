// +gobra

package router

import (
    "github.com/scionproto/scion/pkg/addr"
    "github.com/scionproto/scion/private/topology"
    "github.com/scionproto/scion/verification/utils/slices"
    "hash"
    "net"
    "sync"
)

// done
// error case
// fails after serve
// VERIFIES
func TestDataPlaneAddInternalInterface1(d *DataPlane, conn BatchConn, ip net.IP) { // mock passed as parameter
	tmpD := &DataPlane{
        external:          map[uint16]BatchConn(nil),
        linkTypes:         map[uint16]topology.LinkType(nil),
        neighborIAs:       map[uint16]addr.IA(nil),
        internal:          BatchConn(nil),
        internalIP:        net.IP(nil),
        internalNextHops:  map[uint16]*net.UDPAddr(nil),
        svc:               (*services)(nil),
        //macFactory:        (func() hash.Hash)(nil),
        bfdSessions:       map[uint16]bfdSession(nil),
        localIA:           0x0,
        mtx:               sync.Mutex{},
        running:           true,
        Metrics:           (*Metrics)(nil),
        forwardingMetrics: map[uint16]forwardingMetrics(nil),
    }
	tmpIp := net.IP{}

	assume d == tmpD
    assume ip === tmpIp

    inhale acc(d.Mem(), OutMutexPerm)
    inhale !d.IsRunning()
    inhale !d.InternalConnIsSet()
    inhale  conn != nil && conn.Mem()
    inhale ip.Mem()
    inhale d.mtx.LockP()
    inhale d.mtx.LockInv() == MutexInvariant!<d!>

	err := d.AddInternalInterface(conn, ip)

	assert err != nil
}

// done
// no error case
// single set works
// VERIFIES
func TestDataPlaneAddInternalInterface3(d *DataPlane, conn BatchConn, ip net.IP) {
    tmpD := &DataPlane{
        external:          map[uint16]BatchConn(nil),
        linkTypes:         map[uint16]topology.LinkType(nil),
        neighborIAs:       map[uint16]addr.IA(nil),
        internal:          BatchConn(nil),
        internalIP:        net.IP(nil),
        internalNextHops:  map[uint16]*net.UDPAddr(nil),
        svc:               (*services)(nil),
        //macFactory:        (func() hash.Hash)(nil),
        bfdSessions:       map[uint16]bfdSession(nil),
        localIA:           0x0,
        mtx:               sync.Mutex{},
        running:           false,
        Metrics:           (*Metrics)(nil),
        forwardingMetrics: map[uint16]forwardingMetrics(nil),
    }
    tmpIp := net.IP{}

    assume d == tmpD
    assume ip === tmpIp

    inhale acc(d.Mem(), OutMutexPerm)
    inhale !d.IsRunning()
    inhale !d.InternalConnIsSet()
    inhale  conn != nil && conn.Mem()
    inhale ip.Mem()
    inhale d.mtx.LockP()
    inhale d.mtx.LockInv() == MutexInvariant!<d!>

    //refute false

    err := d.AddInternalInterface(conn, ip)

    assert err == nil // ERROR: might not hold
}

// TODO
// setting nil value is not allowed
// doesn't verify
func TestDataPlaneAddInternalInterface2() {
	d := &DataPlane{}
    fold d.Mem() // has to be inserted to satisfy precondition acc(d.Mem(), OutMutexPerm)
	err := d.AddInternalInterface(nil, nil) // precondition conn != nil might not hold
	assert err != nil
}

// single set works
// doesn't verify
requires conn != nil && conn.Mem() // has to be added to satisfy precondition
func TestDataPlaneAddInternalInterface3gr(conn BatchConn) { // mock passed as parameter
	d := &DataPlane{}
    fold d.Mem() // has to be inserted to satisfy precondition
	fold MutexInvariant!<d!>() // has to be inserted to satisfy precondition
	d.mtx.SetInv(MutexInvariant!<d!>) // has to be inserted to satisfy precondition

	ip := net.IP{}
	fold ip.Mem() // has to be inserted to satisfy precondition, fails because len(ip) == IPv4len || len(ip) == IPv6len might not hold

	err := d.AddInternalInterface(conn, ip)
	assert err == nil
}

// double set fails
// doesn't verify
requires conn != nil && conn.Mem() // has to be added to satisfy precondition conn != nil && conn.Mem()
func TestDataPlaneAddInternalInterface4(conn BatchConn) { // mock passed as parameter
	d := &DataPlane{}
    fold d.Mem() // has to be inserted to satisfy precondition acc(d.Mem(), OutMutexPerm)
    fold MutexInvariant!<d!>() // has to be inserted to satisfy precondition
    d.mtx.SetInv(MutexInvariant!<d!>) // has to be inserted to satisfy precondition

	ip := net.IP{}
    fold ip.Mem() // has to be inserted to satisfy precondition, fails because len(ip) == IPv4len || len(ip) == IPv6len might not hold

	err1 := d.AddInternalInterface(conn, ip)
	err2 := d.AddInternalInterface(conn, ip)

    assert err1 == nil
	assert err2 != nil
}

// fails after serve
// doesn't verify because precondition not satisfied
func TestDataPlaneSetKey1() {
	d := &DataPlane{}
	d.running = true
    key := []byte("dummy")

    fold slices.Bytes(key, 0, len(key))
	fold d.Mem() // has to be inserted to satisfy precondition acc(d.Mem(), OutMutexPerm)
    fold MutexInvariant!<d!>() // has to be inserted to satisfy precondition
    d.mtx.SetInv(MutexInvariant!<d!>) // has to be inserted to satisfy precondition

	err := d.SetKey(key)  // precondition not met (!d.IsRunning() does not hold)

	assert err != nil
}

// setting nil value is not allowed
// doesn't verify because precondition not satisfied
func TestDataPlaneSetKey2() {
	d := &DataPlane{}
	fold d.Mem() // has to be inserted to satisfy precondition acc(d.Mem(), OutMutexPerm)
    fold MutexInvariant!<d!>() // has to be inserted to satisfy precondition
    d.mtx.SetInv(MutexInvariant!<d!>) // has to be inserted to satisfy precondition

	err := d.SetKey(nil)  // precondition not met (len(key) > 0 does not hold)

	assert err != nil
}

// single set works
// doesn't verify
func TestDataPlaneSetKey3() {
	d := &DataPlane{}

    key := []byte("dummy key xxxxxx")
    fold slices.Bytes(key, 0, len(key))
    fold d.Mem() // has to be inserted to satisfy precondition acc(d.Mem(), OutMutexPerm)
    fold MutexInvariant!<d!>() // has to be inserted to satisfy precondition
    d.mtx.SetInv(MutexInvariant!<d!>) // has to be inserted to satisfy precondition

	err := d.SetKey(key)

	assert err == nil // might not hold
}

// double set fails
// doesn't verify
func TestDataPlaneSetKey4() {
	d := &DataPlane{}

    key := []byte("dummy key xxxxxx")
    fold slices.Bytes(key, 0, len(key))
    fold d.Mem() // has to be inserted to satisfy precondition acc(d.Mem(), OutMutexPerm)
    fold MutexInvariant!<d!>() // has to be inserted to satisfy precondition
    d.mtx.SetInv(MutexInvariant!<d!>) // has to be inserted to satisfy precondition

	err1 := d.SetKey(key)
	err2 := d.SetKey(key) // precondition !d.KeyIsSet() might not hold

    assert err1 == nil
    assert err2 != nil
}
