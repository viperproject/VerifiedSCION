// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra


package io


type Abs_Dataplane adt {
	Abs_Dataplane_ {
		//external          seq[IO_ifs]
		linkTypes         dict[IO_ifs]IO_Link
		neighborIAs       dict[IO_ifs]IO_as
		internal          IO_ifs //TODO: propably not needed, = 0
		localIA           IO_as
		running           bool //TODO: needed?
	}
}

// ghost 
// requires acc(dp, _)
// pure func (dp *Abs_Dataplane) (ifs IO_ifs) seq[IO_ifs] {
// 	return dp.external
// }

ghost
//requires acc(dp, _)
requires ifs in domain(dp.linkTypes)
pure func (dp Abs_Dataplane) getLinkType(ifs IO_ifs) IO_Link {
	return dp.linkTypes[ifs]
}

ghost
//requires acc(dp, _)
requires ifs in domain(dp.neighborIAs)
pure func (dp Abs_Dataplane) getNeighborIA(ifs IO_ifs) IO_as {
	return dp.neighborIAs[ifs]
}

ghost
//requires acc(dp, _)
pure func (dp Abs_Dataplane) getLocalIA() IO_as {
	return dp.localIA
}

ghost
//requires acc(dp, _)
pure func (dp Abs_Dataplane) isRunning() bool {
	return dp.running
}