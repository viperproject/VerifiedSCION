// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package io

ghost
pure
decreases
func inc_seg2(currseg, traversedseg IO_seg2, hf1 IO_HF, fut seq[HFSchemeAhiT]) bool /*{
	return Future(currseg) === seq[HFSchemeAhiT]{hf1} ++ fut &&
		Future(traversedseg) === fut &&
		Past(traversedseg) === seq[HFSchemeAhiT]{hf1} ++ Past(currseg) &&
		true // TODO: no clue what toab hf1 means; case not defined
}
*/

ghost
pure
decreases
func same_segment2(currseg, traversedseg IO_seg2) bool {
	return Future(traversedseg) === Future(currseg) &&
	Past(traversedseg)    === Past(currseg) &&
	History(traversedseg) === History(currseg)
}

ghost
pure
decreases
// TODO: do not know where upd_info comes from
func update_uinfo2(currseg, traversedseg IO_seg2, hf1 IO_HF) bool

ghost
pure
decreases
func same_uinfo2(currseg, traversedseg IO_seg2) bool {
	return UInfo(currseg) === UInfo(traversedseg)
}

ghost
pure
decreases
func update_info(condition bool, currseg, traversedseg IO_seg2, hf1 IO_HF) bool {
	return condition? update_uinfo2(currseg, traversedseg, hf1) : same_uinfo2(currseg, traversedseg)
}

ghost
pure
decreases
func same_other(currseg, traversedseg IO_seg2) bool {
	return AInfo(traversedseg) === AInfo(currseg) &&
		ConsDir(traversedseg) === ConsDir(currseg) &&
		Peer(traversedseg) === Peer(currseg)
}