// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package io

import "github.com/scionproto/scion/pkg/slayers/path"

// used everywhere where the Isabel spec has a type-parameter
type TypeParameter = interface{}
type TypeParameter1 = interface{}
type TypeParameter2 = interface{}
type TypeParameter3 = interface{}

// interface IDs
type IO_ifs uint16

// msgTerms consist of terms from our term algebra.
// TODO: is encoding it as a domain the best choice here?
type IO_msgterm domain{}

/** Hop-Fields **/

// Abstract representation of an HopField
// We consider 0 to be the ID of the internal network in HopField.
// We consider None to be the ID of the internal network in HF.
type HF domain {
	func InIF2(h HF) option[IO_ifs]
	func EgIF2(h HF) option[IO_ifs]
	func HVF(h HF) IO_msgterm
}

// We ASSUME the existence of a function that computes the msgTerm of a path.HopField
ghost
decreases
pure func ComputeMsgTerm(h path.HopField) IO_msgterm

ghost
ensures h.ConsIngress == 0 ==> InIF2(res) == none[IO_ifs]
ensures h.ConsIngress != 0 ==> InIF2(res) == some(IO_ifs(h.ConsIngress))
ensures h.ConsEgress  == 0 ==> EgIF2(res) == none[IO_ifs]
ensures h.ConsEgress  != 0 ==> EgIF2(res) == some(IO_ifs(h.ConsIngress))
ensures HVF(res) == ComputeMsgTerm(h)
decreases
pure func ToHF(h path.HopField) (res HF)

/** End of Hop-Fields **/

/** Segments **/
type IO_seg2 domain {
	func AInfo(s IO_seg2) TypeParameter1
	func UInfo(s IO_seg2) TypeParameter2
	func ConsDir(s IO_seg2) bool
	func Peer(s IO_seg2) bool
	func Past(s IO_seg2) seq[HFSchemeAhiT]
	func Future(s IO_seg2) seq[HFSchemeAhiT]
	func History(s IO_seg2) seq[AhiSchemeAhiT]
}

// TODO: is encoding these as domains the best choice here?
// QUESTION: where does HF_scheme come from?
type HFSchemeAhiT domain{}
type AhiSchemeAhiT domain{}

/** End of Segments **/

/** Packets **/
type IO_pkt2 adt {
	IO_pkt2_cons {
		CurrSeg  IO_seg2
		LeftSeg  option[IO_seg2]
		MidSeg   option[IO_seg2]
		RightSeg option[IO_seg2]
	}
}

// pkt3 is not defined anywhere; according to Felix, stands for IO_pkt2
type IO_pkt3 = IO_pkt2

/** End of Packets **/

/** Router State **/

type IO_dp3s_state_local domain {
	func IBuf(s IO_dp3s_state_local, ifc option[IO_ifs]) set[IO_pkt3]
	func OBuf(s IO_dp3s_state_local, ifc option[IO_ifs]) set[IO_pkt3]
}

/** End of Router State **/

/** Values **/

// TODO: is the encoding correct?
type IO_val adt {
	IO_val_Unit{}

	// IO_pkt2 in the doc
	IO_val_Pkt2 {
		IO_val_Pkt2_1 option[IO_ifs]
		IO_val_Pkt2_2 IO_pkt3
	}

	IO_val_Unsupported {
		IO_val_Unsupported_1 option[IO_ifs]
		IO_val_Unsupported_2 TypeParameter
	}

	IO_Internal_val1 {
		IO_Internal_val1_1 IO_pkt3
		IO_Internal_val1_2 IO_ifs
		IO_Internal_val1_3 IO_pkt3
		IO_Internal_val1_4 option[IO_ifs]
	}

	IO_Internal_val2 {
		IO_Internal_val2_1 IO_pkt3
		IO_Internal_val2_2 IO_pkt3
		IO_Internal_val2_3 IO_ifs
	}
}

type IO_bio3sIN adt {
	IO_bio3s_enter{}
	IO_bio3s_xover_up2down{}
	IO_bio3s_xover_core{}
	IO_bio3s_exit{}
}

type IO_bio3sIO adt {
	IO_bio3s_send{}
	IO_bio3s_recv{}
}

/** End of Values **/