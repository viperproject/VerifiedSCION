// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package io

import "github.com/scionproto/scion/pkg/slayers/path"

// used everywhere where the Isabel spec has a type-parameter
type TypeParameter = interface{}
type TypeParameter1 = interface{}
type TypeParameter2 = interface{}
type TypeParameter3 = interface{}

type Unit adt {
	Unit_{}
}

// interface IDs
type IO_ifs uint16

// type of AS identifiers
type IO_as uint

// router ids
type IO_rid uint

// msgTerms consist of terms from our term algebra.
type IO_msgterm adt {
	MsgTerm_Empty{}

	MsgTerm_AS {
		MsgTerm_AS_ IO_as
	}

	MsgTerm_Num {
		MsgTerm_Num_ int // formallized as nat in Isabelle
	}

	MsgTerm_Key {
		MsgTerm_Key_ IO_key
	}

	MsgTerm_L {
		MsgTerm_L_ seq[IO_msgterm]
	}

	MsgTerm_FS {
		MsgTerm_FS_ seq[IO_msgterm]
	}

	MsgTerm_MPair {
		MsgTerm_MPair_1 IO_msgterm
		MsgTerm_MPair_2 IO_msgterm
	}

	MsgTerm_Hash {
		MsgTerm_Hash_ IO_msgterm
	}

	MsgTerm_Crypt {
		MsgTerm_Crypt_1 IO_key
		MsgTerm_Crypt_2 IO_msgterm
	}
}

type IO_key adt {
	Key_macK {
		Key_macK_ IO_as
	}

	Key_pubK {
		Key_pubK_ IO_as
	}

	Key_priK {
		Key_priK_ IO_as
	}
}

/** Hop-Fields **/

// Abstract representation of an HopField
// We consider 0 to be the ID of the internal network in HopField.
// We consider None to be the ID of the internal network in HF.
type IO_HF adt {
	IO_HF_ {
		InIF2 option[IO_ifs]
		EgIF2 option[IO_ifs]
		HVF IO_msgterm
	}
}

// "authenticated hop information"
type IO_ahi adt {
	IO_ahi_ {
		InIF option[IO_ifs]
		EgIF option[IO_ifs]
		ASID IO_as
	}
}

// TODO: how is this defined
// extract_asid
ghost
pure
decreases
func (m IO_msgterm) extract_asid() IO_as

// function 'toab' in Isabelle, originally of type HF_scheme -> aahi_scheme
ghost
pure
decreases
func (h IO_HF) Toab() IO_ahi {
	return IO_ahi_{h.InIF2, h.EgIF2, h.HVF.extract_asid()}
}

// TODO: move ToHF to another package
// TODO: can we get rid of this assumption?
// We ASSUME the existence of a function that computes the msgTerm of a path.HopField
ghost
decreases
pure func ComputeMsgTerm(h path.HopField) IO_msgterm

// TODO: should be easy to give a body to this now
ghost
ensures h.ConsIngress == 0 ==> res.InIF2 == none[IO_ifs]
ensures h.ConsIngress != 0 ==> res.InIF2 == some(IO_ifs(h.ConsIngress))
ensures h.ConsEgress  == 0 ==> res.EgIF2 == none[IO_ifs]
ensures h.ConsEgress  != 0 ==> res.EgIF2 == some(IO_ifs(h.ConsIngress))
ensures res.HVF == ComputeMsgTerm(h)
decreases
pure func ToHF(h path.HopField) (res IO_HF)

/** End of Hop-Fields **/

/** Segments **/
// seg3 is the same as seg2 instantiated with type parameters
type IO_seg3 adt {
	IO_seg3_ {
		AInfo int // nat in Isabelle
		UInfo set[IO_msgterm]
		ConsDir bool
		Peer bool
		Past seq[IO_HF]     // formalized originally as a seq of HF_scheme
		Future seq[IO_HF]   // formalized originally as a seq of HF_scheme
		History seq[IO_ahi] // formalized originally as a seq of ahi_scheme
	}
}

/** End of Segments **/

/** Packets **/
// pkt3 is the same as pkt2 instantiated with type parameters
type IO_pkt3 adt {
	IO_pkt2_ {
		CurrSeg  IO_seg3
		LeftSeg  option[IO_seg3]
		MidSeg   option[IO_seg3]
		RightSeg option[IO_seg3]
	}
}

/** End of Packets **/

/** Router State **/

type IO_dp3s_state_local domain {
	func IBuf(s IO_dp3s_state_local, ifc option[IO_ifs]) set[IO_pkt3]
	func OBuf(s IO_dp3s_state_local, ifc option[IO_ifs]) set[IO_pkt3]
}

/** End of Router State **/

/** Values **/

// TODO: is the encoding correct?
type IO_val adt {
	IO_val_Unit{}

	// IO_pkt2 in the doc
	IO_val_Pkt2 {
		IO_val_Pkt2_1 option[IO_ifs]
		IO_val_Pkt2_2 IO_pkt3
	}

	IO_val_Unsupported {
		IO_val_Unsupported_1 option[IO_ifs]
		IO_val_Unsupported_2 TypeParameter
	}

	IO_Internal_val1 {
		IO_Internal_val1_1 IO_pkt3
		IO_Internal_val1_2 IO_ifs
		IO_Internal_val1_3 IO_pkt3
		IO_Internal_val1_4 option[IO_ifs]
	}

	IO_Internal_val2 {
		IO_Internal_val2_1 IO_pkt3
		IO_Internal_val2_2 IO_pkt3
		IO_Internal_val2_3 IO_ifs
	}
}

type IO_bio3sIN adt {
	IO_bio3s_enter{}
	IO_bio3s_xover_up2down{}
	IO_bio3s_xover_core{}
	IO_bio3s_exit{}
}

type IO_bio3sIO adt {
	IO_bio3s_send{}
	IO_bio3s_recv{}
}

// defined in Isabelle as (bios3sIN, bios3sIO) events
type IO_bio3s adt {
	IO_bio3s_IN {
		IN IO_bio3sIN
	}

	IO_bio3s_IO {
		IO IO_bio3sIN
	}

	IO_bio3s_Skip{}

	IO_bio3s_Stop{}
}

/** End of Values **/
