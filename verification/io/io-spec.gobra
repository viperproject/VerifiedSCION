// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	 http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

/**** IO-Specification ****/

package io

// This is the main IO Specification.
pred (dp DataPlaneSpec) dp3s_iospec_ordered(s IO_dp3s_state_local, t Place) {
	dp.dp3s_iospec_bio3s_enter(s, t) &&
	dp.dp3s_iospec_bio3s_xover_up2down(s, t) &&
	dp.dp3s_iospec_bio3s_xover_core(s, t) &&
	dp.dp3s_iospec_bio3s_exit(s, t) &&
	dp.dp3s_iospec_bio3s_send(s, t) &&
	dp.dp3s_iospec_bio3s_recv(s, t) &&
	dp.dp3s_iospec_skip(s, t) &&
	dp.dp3s_iospec_stop(s, t)
}

type Place int

pred (dp DataPlaneSpec) token(t Place)

ghost
decreases
pure func (dp DataPlaneSpec) undefined() IO_dp3s_state_local

pred (dp DataPlaneSpec) CBio_IN_bio3s_enter(t Place, v IO_val)

ghost
requires dp.CBio_IN_bio3s_enter(t, v)
decreases
pure func (dp DataPlaneSpec) CBio_IN_bio3s_enter_T(t Place, v IO_val) Place


ghost
requires len(currseg.Future) > 0
decreases
pure func (dp DataPlaneSpec) dp3s_iospec_bio3s_create_guard_traversedseg(currseg IO_seg3) IO_seg3 {
	return let uinfo :=  !currseg.ConsDir ?
	 	dp.upd_uinfo(currseg.UInfo, currseg.Future[0]) :
	 	currseg.UInfo in
		IO_seg3_ {
			AInfo: currseg.AInfo,
			UInfo: uinfo,
			ConsDir: currseg.ConsDir,
			Peer: currseg.Peer,
			Past: currseg.Past,
			Future: currseg.Future,
			History: currseg.History}
}

// This corresponds to the condition of the if statement in the io-spec case for enter
ghost
decreases
pure func (dp DataPlaneSpec) dp3s_iospec_bio3s_enter_guard(s IO_dp3s_state_local, t Place, v IO_val) bool {
	return some(v.IO_Internal_val1_2) in domain(s.ibuf) ==>
		(let ibuf_set := s.ibuf[some(v.IO_Internal_val1_2)] in (v.IO_Internal_val1_1 in ibuf_set)) &&
		len(v.IO_Internal_val1_1.CurrSeg.Future) > 0 &&
		let currseg := v.IO_Internal_val1_1.CurrSeg in
		let hf1, fut := currseg.Future[0], currseg.Future[1:] in
		let traversedseg := dp.dp3s_iospec_bio3s_create_guard_traversedseg(currseg) in
		dp.dp2_enter_guard(
			v.IO_Internal_val1_1,
			currseg,
			traversedseg,
			dp.asid(),
			hf1,
			v.IO_Internal_val1_2,
			fut) &&
			dp.dp3s_forward(
				IO_pkt2(
					IO_Packet2{
						traversedseg,
						v.IO_Internal_val1_1.LeftSeg,
						v.IO_Internal_val1_1.MidSeg,
						v.IO_Internal_val1_1.RightSeg}),
				v.IO_Internal_val1_3,
				v.IO_Internal_val1_4)
}

pred (dp DataPlaneSpec) dp3s_iospec_bio3s_enter(s IO_dp3s_state_local, t Place) {
	// TODO: we may need more triggering terms here
	forall v IO_val :: { dp.dp3s_iospec_bio3s_enter_guard(s, t, v) } (v.isIO_Internal_val1 ==>
			(dp.dp3s_iospec_bio3s_enter_guard(s, t, v) ==>
				(dp.CBio_IN_bio3s_enter(t, v) &&
				dp.dp3s_iospec_ordered(
					dp.dp3s_add_obuf(s, v.IO_Internal_val1_4, v.IO_Internal_val1_3),
					dp.CBio_IN_bio3s_enter_T(t, v)))))
}

pred (dp DataPlaneSpec) CBio_IN_bio3s_xover_up2down(t Place, v IO_val)

ghost
requires dp.CBio_IN_bio3s_xover_up2down(t, v)
pure func (dp DataPlaneSpec) dp3s_iospec_bio3s_xover_up2down_T(t Place, v IO_val) Place

// This corresponds to the condition of the if statement in the io-spec case for xover_up2down
ghost
decreases
pure func (dp DataPlaneSpec) dp3s_iospec_bio3s_xover_up2down_guard(s IO_dp3s_state_local, t Place, v IO_val) bool {
	return let currseg := v.IO_Internal_val1_1.CurrSeg in
	v.IO_Internal_val1_1.LeftSeg == none[IO_seg2] ? false :
	let nextseg := get(v.IO_Internal_val1_1.LeftSeg) in
	(nextseg.ConsDir &&
	len(nextseg.Future) > 0 &&
	len(currseg.Future) > 0 &&
	let hf1, hf2 := currseg.Future[0], nextseg.Future[0] in
	let traversedseg := dp.dp3s_iospec_bio3s_create_guard_traversedseg(currseg) in
	(dp.xover_up2down2_link_type(dp.asid(), hf1, hf2) &&
		dp.dp3s_xover_common(
			s,
			v.IO_Internal_val1_1,
			currseg,
			nextseg,
			traversedseg,
			IO_pkt2(IO_Packet2{nextseg, v.IO_Internal_val1_1.MidSeg, v.IO_Internal_val1_1.RightSeg, some(traversedseg)}),
			hf1,
			hf2,
			v.IO_Internal_val1_2,
			v.IO_Internal_val1_3,
			v.IO_Internal_val1_4,)))
}

pred (dp DataPlaneSpec) dp3s_iospec_bio3s_xover_up2down(s IO_dp3s_state_local, t Place) {
	forall v IO_val :: { dp.dp3s_iospec_bio3s_xover_up2down_guard(s, t, v) }{ dp.CBio_IN_bio3s_xover_up2down(t, v) } { dp.dp3s_iospec_ordered(dp.dp3s_add_obuf(s, v.IO_Internal_val1_4, v.IO_Internal_val1_3), dp.dp3s_iospec_bio3s_xover_up2down_T(t, v)) } (v.isIO_Internal_val1 ==>
		(dp.dp3s_iospec_bio3s_xover_up2down_guard(s, t, v) ==>
			(dp.CBio_IN_bio3s_xover_up2down(t, v) &&
				dp.dp3s_iospec_ordered(
					dp.dp3s_add_obuf(s, v.IO_Internal_val1_4, v.IO_Internal_val1_3),
					dp.dp3s_iospec_bio3s_xover_up2down_T(t, v)))))
}

pred (dp DataPlaneSpec) CBio_IN_bio3s_xover_core(t Place, v IO_val)

ghost
requires dp.CBio_IN_bio3s_xover_core(t, v)
pure func (dp DataPlaneSpec) dp3s_iospec_bio3s_xover_core_T(t Place, v IO_val) Place

// This corresponds to the condition of the if statement in the io-spec case for xover_core
ghost
decreases
pure func (dp DataPlaneSpec) dp3s_iospec_bio3s_xover_core_guard(s IO_dp3s_state_local, t Place, v IO_val) bool {
	return (dp.asid() in dp.core_as_set() &&
		let currseg := v.IO_Internal_val1_1.CurrSeg in
		(v.IO_Internal_val1_1.LeftSeg == none[IO_seg2] ? false :
			let nextseg := get(v.IO_Internal_val1_1.LeftSeg) in
				currseg.ConsDir == nextseg.ConsDir &&
				len(nextseg.Future) > 0 &&
				len(currseg.Future) > 0 &&
				let hf1, hf2 := currseg.Future[0], nextseg.Future[0] in
				let traversedseg := dp.dp3s_iospec_bio3s_create_guard_traversedseg(currseg) in
				(dp.xover_core2_link_type(hf1, hf2, dp.asid(), currseg.ConsDir) &&
					dp.dp3s_xover_common(
						s,
						v.IO_Internal_val1_1,
						currseg,
						nextseg,
						traversedseg,
						IO_pkt2(IO_Packet2{nextseg, v.IO_Internal_val1_1.MidSeg, v.IO_Internal_val1_1.RightSeg, some(traversedseg)}),
						hf1,
						hf2,
						v.IO_Internal_val1_2,
						v.IO_Internal_val1_3,
						v.IO_Internal_val1_4))))
}

pred (dp DataPlaneSpec) dp3s_iospec_bio3s_xover_core(s IO_dp3s_state_local, t Place) {
	forall v IO_val :: { dp.dp3s_iospec_bio3s_xover_core_guard(s, t, v) }{ dp.CBio_IN_bio3s_xover_core(t, v) }{ dp.dp3s_iospec_ordered(dp.dp3s_add_obuf(s, v.IO_Internal_val1_4, v.IO_Internal_val1_3), dp.dp3s_iospec_bio3s_xover_core_T(t, v)) } (v.isIO_Internal_val1 ==>
		(dp.dp3s_iospec_bio3s_xover_core_guard(s, t, v) ==>
			(dp.CBio_IN_bio3s_xover_core(t, v) &&
			dp.dp3s_iospec_ordered(
				dp.dp3s_add_obuf(s, v.IO_Internal_val1_4, v.IO_Internal_val1_3),
				dp.dp3s_iospec_bio3s_xover_core_T(t, v)))))
}


pred (dp DataPlaneSpec) CBio_IN_bio3s_exit(t Place, v IO_val)

ghost
requires dp.CBio_IN_bio3s_exit(t, v)
pure func (dp DataPlaneSpec) dp3s_iospec_bio3s_exit_T(t Place, v IO_val) Place

// This corresponds to the condition of the if statement in the io-spec case for exit
ghost
decreases
pure func (dp DataPlaneSpec) dp3s_iospec_bio3s_exit_guard(s IO_dp3s_state_local, t Place, v IO_val) bool {
	return none[IO_ifs] in domain(s.ibuf) ==>
		(let ibuf_set := s.ibuf[none[IO_ifs]] in (v.IO_Internal_val2_1 in ibuf_set)) &&
		dp.dp3s_forward_ext(v.IO_Internal_val2_1, v.IO_Internal_val2_2, v.IO_Internal_val2_3)
}

pred (dp DataPlaneSpec) dp3s_iospec_bio3s_exit(s IO_dp3s_state_local, t Place) {
	forall v IO_val :: { dp.dp3s_iospec_bio3s_exit_guard(s, t, v) }{ dp.CBio_IN_bio3s_exit(t, v) }{ dp.dp3s_iospec_ordered(dp.dp3s_add_obuf(s, some(v.IO_Internal_val2_3), v.IO_Internal_val2_2), dp.dp3s_iospec_bio3s_exit_T(t, v)) } (v.isIO_Internal_val2 ==>
		(dp.dp3s_iospec_bio3s_exit_guard(s, t, v) ==>
			(dp.CBio_IN_bio3s_exit(t, v) &&
			dp.dp3s_iospec_ordered(
				dp.dp3s_add_obuf(s, some(v.IO_Internal_val2_3), v.IO_Internal_val2_2),
				dp.dp3s_iospec_bio3s_exit_T(t, v)))))
}


pred (dp DataPlaneSpec) CBioIO_bio3s_send(t Place, v IO_val)

ghost
requires dp.CBioIO_bio3s_send(t, v)
pure func (dp DataPlaneSpec) dp3s_iospec_bio3s_send_T(t Place, v IO_val) Place

// This corresponds to the condition of the if statement in the io-spec case for send
ghost
decreases
pure func (dp DataPlaneSpec) dp3s_iospec_bio3s_send_guard(s IO_dp3s_state_local, t Place, v IO_val) bool {
	return v.IO_val_Pkt2_1 in domain(s.obuf) ==>
		(let obuf_set := s.obuf[v.IO_val_Pkt2_1] in (v.IO_val_Pkt2_2 in obuf_set))
}

// TODO: annotate WriteBatch, skipped for now
pred (dp DataPlaneSpec) dp3s_iospec_bio3s_send(s IO_dp3s_state_local, t Place) {
	forall v IO_val :: { dp.dp3s_iospec_bio3s_send_guard(s, t, v) }{ dp.CBioIO_bio3s_send(t, v) }{ dp.dp3s_iospec_ordered(s, dp.dp3s_iospec_bio3s_send_T(t, v)) }{ dp.CBioIO_bio3s_send(t, v) }{ dp.dp3s_iospec_ordered(s, dp.dp3s_iospec_bio3s_send_T(t, v)) } (v.isIO_val_Pkt2 ==>
		(dp.dp3s_iospec_bio3s_send_guard(s, t, v) ==>
			dp.CBioIO_bio3s_send(t, v) &&
			dp.dp3s_iospec_ordered(s, dp.dp3s_iospec_bio3s_send_T(t, v)))) &&
	(v.isIO_val_Unsupported ==>
		dp.CBioIO_bio3s_send(t, v) &&
			dp.dp3s_iospec_ordered(s, dp.dp3s_iospec_bio3s_send_T(t, v)))
}

pred (dp DataPlaneSpec) CBioIO_bio3s_recv(t Place)

ghost
requires dp.CBioIO_bio3s_recv(t)
pure func (dp DataPlaneSpec) dp3s_iospec_bio3s_recv_T(t Place) Place

ghost
requires dp.CBioIO_bio3s_recv(t)
pure func (dp DataPlaneSpec) dp3s_iospec_bio3s_recv_R(t Place) IO_val

pred (dp DataPlaneSpec) dp3s_iospec_bio3s_recv(s IO_dp3s_state_local, t Place) {
	dp.CBioIO_bio3s_recv(t) &&
		(dp.dp3s_iospec_bio3s_recv_R(t).isIO_val_Pkt2 ==>
			dp.dp3s_iospec_ordered(
				dp.dp3s_add_ibuf(
					s,
					dp.dp3s_iospec_bio3s_recv_R(t).IO_val_Pkt2_1,
					dp.dp3s_iospec_bio3s_recv_R(t).IO_val_Pkt2_2),
				dp.dp3s_iospec_bio3s_recv_T(t))) &&
		(dp.dp3s_iospec_bio3s_recv_R(t).isIO_val_Unsupported ==>
			dp.dp3s_iospec_ordered(s, dp.dp3s_iospec_bio3s_recv_T(t))) &&
		((!dp.dp3s_iospec_bio3s_recv_R(t).isIO_val_Pkt2 && !dp.dp3s_iospec_bio3s_recv_R(t).isIO_val_Unsupported) ==>
			dp.dp3s_iospec_ordered(dp.undefined(), dp.dp3s_iospec_bio3s_recv_T(t)))
}

pred (dp DataPlaneSpec) CBio_Skip(t Place)

ghost
requires dp.CBio_Skip(t)
pure func (dp DataPlaneSpec) dp3s_iospec_skip_T(t Place) Place

pred (dp DataPlaneSpec) dp3s_iospec_skip(s IO_dp3s_state_local, t Place) {
	dp.CBio_Skip(t) && dp.dp3s_iospec_ordered(s, dp.dp3s_iospec_skip_T(t))
}

pred (dp DataPlaneSpec) dp3s_iospec_stop(s IO_dp3s_state_local, t Place) {
	true
}

