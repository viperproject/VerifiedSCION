// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package slices

import . "github.com/scionproto/scion/verification/utils/definitions"

// How to extend this file:
// - if we need to support slices of non-supported types, we must repeat all definitions
//   for that type. For this, we should be careful to avoid introducing cylical dependencies.
//   The suffix of the predicate/function should be the type of the elems of the slices.
// - For each type, there might be two different types of operations: those that keep track
//   of contents (the name of the operation ends in "C"), and those who do not.

pred AbsSlice_Bytes(s []byte, start int, end int) {
	// start inclusive
	0 <= start &&
	start <= end &&
	// end exclusive
	end <= cap(s) &&
	forall i int :: { &s[i] } start <= i && i < end ==> acc(&s[i])
}

pure
requires acc(AbsSlice_Bytes(s, start, end), _)
requires start <= i && i < end
decreases
func GetByte(s []byte, start int, end int, i int) byte {
	return unfolding acc(AbsSlice_Bytes(s, start, end), _) in s[i]
}

ghost
opaque
requires acc(AbsSlice_Bytes(s, start1, end1), _)
requires acc(AbsSlice_Bytes(s, start2, end2), _)
requires start1 <= i && i < end1
requires start2 <= i && i < end2
ensures  GetByte(s, start1, end1, i) == GetByte(s, start2, end2, i)
decreases
pure func GetByteDiffBoundsYieldsSameVal(s []byte, start1, end1, start2, end2, i int) Lemma {
	return unfolding acc(AbsSlice_Bytes(s, start1, end1), _)    in
		unfolding acc(AbsSlice_Bytes(s, start2, end2), _)       in
		let _ := Asserting(GetByte(s, start1, end1, i) == s[i]) in
		let _ := Asserting(GetByte(s, start2, end2, i) == s[i]) in
		Lemma{}
}

ghost
requires 0 < p
requires acc(AbsSliceC_Bytes(s, 0, len(s), contents), p)
ensures  acc(AbsSlice_Bytes(s, 0, len(s)), p)
decreases
func GetAbsSlice_Bytes(s []byte, contents seq[byte], p perm) {
	unfold acc(AbsSliceC_Bytes(s, 0, len(s), contents), p)
	fold acc(AbsSlice_Bytes(s, 0, len(s)), p)
}

ghost
requires 0 < p
requires acc(AbsSlice_Bytes(s, start, end), p)
requires start <= idx && idx <= end
ensures  acc(AbsSlice_Bytes(s, start, idx), p)
ensures  acc(AbsSlice_Bytes(s, idx, end), p)
decreases
func SplitByIndex_Bytes(s []byte, start int, end int, idx int, p perm) {
	unfold acc(AbsSlice_Bytes(s, start, end), p)
	fold   acc(AbsSlice_Bytes(s, start, idx), p)
	fold   acc(AbsSlice_Bytes(s, idx, end), p)
}

ghost
requires 0 < p
requires acc(AbsSlice_Bytes(s, start, idx), p)
requires acc(AbsSlice_Bytes(s, idx,   end), p)
ensures  acc(AbsSlice_Bytes(s, start, end), p)
decreases
func CombineAtIndex_Bytes(s []byte, start int, end int, idx int, p perm) {
	unfold acc(AbsSlice_Bytes(s, start, idx), p)
	unfold acc(AbsSlice_Bytes(s, idx,   end), p)
	fold   acc(AbsSlice_Bytes(s, start, end), p)
}

ghost
requires 0 < p
requires acc(AbsSlice_Bytes(s, start, end), p)
// the following precondition convinces Gobra that
// the slice operation is well-formed
requires unfolding acc(AbsSlice_Bytes(s, start, end), p) in true
ensures  acc(AbsSlice_Bytes(s[start:end], 0, len(s[start:end])), p)
decreases
func Reslice_Bytes(s []byte, start int, end int, p perm) {
	unfold acc(AbsSlice_Bytes(s, start, end), p)
	assert forall i int :: { &s[start:end][i] }{ &s[start + i] } 0 <= i && i < (end-start) ==> &s[start:end][i] == &s[start + i]
	fold  acc(AbsSlice_Bytes(s[start:end], 0, len(s[start:end])), p)
}

ghost
requires 0 < p
requires 0 <= start && start <= end && end <= cap(s)
requires len(s[start:end]) <= cap(s)
requires acc(AbsSlice_Bytes(s[start:end], 0, len(s[start:end])), p)
ensures  acc(AbsSlice_Bytes(s, start, end), p)
decreases
func Unslice_Bytes(s []byte, start int, end int, p perm) {
	unfold acc(AbsSlice_Bytes(s[start:end], 0, len(s[start:end])), p)
	assert 0 <= start && start <= end && end <= cap(s)
	assert forall i int :: { &s[start:end][i] } 0 <= i && i < len(s[start:end]) ==> acc(&s[start:end][i], p)
	assert forall i int :: { &s[start:end][i] }{ &s[start + i] } 0 <= i && i < len(s[start:end]) ==> &s[start:end][i] == &s[start + i]

	invariant 0 <= j && j <= len(s[start:end])
	invariant forall i int :: { &s[start:end][i] } j <= i && i < len(s[start:end]) ==> acc(&s[start:end][i], p)
	invariant forall i int :: { &s[start:end][i] }{ &s[start + i] } 0 <= i && i < len(s[start:end]) ==> &s[start:end][i] == &s[start + i]
	invariant forall i int :: { &s[i] } start <= i && i < start+j ==> acc(&s[i], p)
	decreases len(s[start:end]) - j
	for j := 0; j < len(s[start:end]); j++ {
		assert forall i int :: { &s[i] } start <= i && i < start+j ==> acc(&s[i], p)
		assert &s[start:end][j] == &s[start + j]
		assert acc(&s[start + j], p)
		assert forall i int :: { &s[i] } start <= i && i <= start+j ==> acc(&s[i], p)
	}
	fold acc(AbsSlice_Bytes(s, start, end), p)
}

ghost
requires 0 < p
requires 0 <= start && start <= end && end <= len(s)
requires acc(AbsSlice_Bytes(s, 0, len(s)), p)
ensures  acc(AbsSlice_Bytes(s[start:end], 0, end-start), p)
ensures  acc(AbsSlice_Bytes(s, 0, start), p)
ensures  acc(AbsSlice_Bytes(s, end, len(s)), p)
decreases
func SplitRange_Bytes(s []byte, start int, end int, p perm) {
	SplitByIndex_Bytes(s, 0, len(s), start, p)
	SplitByIndex_Bytes(s, start, len(s), end, p)
	Reslice_Bytes(s, start, end, p)
}

ghost
requires 0 < p
requires 0 <= start && start <= end && end <= len(s)
requires acc(AbsSlice_Bytes(s[start:end], 0, end-start), p)
requires acc(AbsSlice_Bytes(s, 0, start), p)
requires acc(AbsSlice_Bytes(s, end, len(s)), p)
ensures  acc(AbsSlice_Bytes(s, 0, len(s)), p)
decreases
func CombineRange_Bytes(s []byte, start int, end int, p perm) {
	Unslice_Bytes(s, start, end, p)
	CombineAtIndex_Bytes(s, start, len(s), end, p)
	CombineAtIndex_Bytes(s, 0, len(s), start, p)
}

ghost
ensures AbsSlice_Bytes(nil, 0, 0)
decreases
func NilAcc_Bytes() {
	fold AbsSlice_Bytes(nil, 0, 0)
}

ghost
opaque
requires 0 <= startPerm && startPerm <= start && start <= end && end <= endPerm
requires acc(AbsSlice_Bytes(s, startPerm, endPerm), _)
ensures  len(res) == end-start
ensures  forall i int :: { GetByte(s, startPerm, endPerm, i) }{ res[i-start] } start <= i && i < end ==>
	GetByte(s, startPerm, endPerm, i) == res[i-start]
decreases end - start
pure func AsSeq(s []byte, startPerm, endPerm, start, end int) (res seq[byte]) {
	return start >= end ? seq[byte]{} : (seq[byte]{ GetByte(s, startPerm, endPerm, start) } ++ AsSeq(s, startPerm, endPerm, start+1, end))
}

ghost
opaque
requires 0 <= startPerm1 && startPerm1 <= start && start <= end && end <= endPerm1
requires 0 <= startPerm2 && startPerm2 <= start && start <= end && end <= endPerm2
requires acc(AbsSlice_Bytes(s, startPerm1, endPerm1), _)
requires acc(AbsSlice_Bytes(s, startPerm2, endPerm2), _)
ensures AsSeq(s, startPerm1, endPerm1, start, end) ==
	AsSeq(s, startPerm2, endPerm2, start, end)
decreases end - start
pure func ResizeBoundsYieldsSameSeq(s []byte, startPerm1, endPerm1, startPerm2, endPerm2,  start, end int) Lemma {
	return let _ := reveal AsSeq(s, startPerm1, endPerm1, start, end) in
		let _ := reveal AsSeq(s, startPerm2, endPerm2, start, end)    in
		start >= end ?
			Lemma{} :
			let _ := GetByteDiffBoundsYieldsSameVal(s, startPerm1, endPerm1, startPerm2, endPerm2, start) in
				ResizeBoundsYieldsSameSeq(s, startPerm1, endPerm1, startPerm2, endPerm2, start+1, end)
}

/** Auxiliar definitions Any **/
ghost
requires size >= 0
ensures len(res) == size
ensures forall i int :: { res[i] } 0 <= i && i < size ==> res[i] == nil
decreases _
pure func NewSeq_Any(size int) (res seq[any])

// TODO:
// func ToSeq_Any
// ResliceC_Any

/** End of Auxiliar definitions Any **/

/** Slices of Any without Contents **/
pred AbsSlice_Any(s []any, start int, end int) {
	// start inclusive
	0 <= start &&
	start <= end &&
	// end exclusive
	end <= cap(s) &&
	forall i int :: { &s[i] } start <= i && i < end ==> acc(&s[i])
}

ghost
requires 0 < p
requires acc(AbsSlice_Any(s, start, end), p)
requires start <= idx && idx <= end
ensures  acc(AbsSlice_Any(s, start, idx), p)
ensures  acc(AbsSlice_Any(s, idx, end), p)
decreases
func SplitByIndex_Any(s []any, start int, end int, idx int, p perm) {
	unfold acc(AbsSlice_Any(s, start, end), p)
	fold   acc(AbsSlice_Any(s, start, idx), p)
	fold   acc(AbsSlice_Any(s, idx, end), p)
}

ghost
requires 0 < p
requires acc(AbsSlice_Any(s, start, idx), p)
requires acc(AbsSlice_Any(s, idx,   end), p)
ensures  acc(AbsSlice_Any(s, start, end), p)
decreases
func CombineAtIndex_Any(s []any, start int, end int, idx int, p perm) {
	unfold acc(AbsSlice_Any(s, start, idx), p)
	unfold acc(AbsSlice_Any(s, idx,   end), p)
	fold   acc(AbsSlice_Any(s, start, end), p)
}

ghost
requires 0 < p
requires acc(AbsSlice_Any(s, start, end), p)
// the following precondition convinces Gobra that
// the slice operation is well-formed
requires unfolding acc(AbsSlice_Any(s, start, end), p) in true
ensures  acc(AbsSlice_Any(s[start:end], 0, len(s[start:end])), p)
decreases
func Reslice_Any(s []any, start int, end int, p perm) {
	unfold acc(AbsSlice_Any(s, start, end), p)
	assert forall i int :: { &s[start:end][i] }{ &s[start + i] } 0 <= i && i < (end-start) ==> &s[start:end][i] == &s[start + i]
	fold  acc(AbsSlice_Any(s[start:end], 0, len(s[start:end])), p)
}

ghost
requires 0 < p
requires 0 <= start && start <= end && end <= cap(s)
requires len(s[start:end]) <= cap(s)
requires acc(AbsSlice_Any(s[start:end], 0, len(s[start:end])), p)
ensures  acc(AbsSlice_Any(s, start, end), p)
decreases
func Unslice_Any(s []any, start int, end int, p perm) {
	unfold acc(AbsSlice_Any(s[start:end], 0, len(s[start:end])), p)
	assert 0 <= start && start <= end && end <= cap(s)
	assert forall i int :: { &s[start:end][i] } 0 <= i && i < len(s[start:end]) ==> acc(&s[start:end][i], p)
	assert forall i int :: { &s[start:end][i] }{ &s[start + i] } 0 <= i && i < len(s[start:end]) ==> &s[start:end][i] == &s[start + i]

	invariant 0 <= j && j <= len(s[start:end])
	invariant forall i int :: { &s[start:end][i] } j <= i && i < len(s[start:end]) ==> acc(&s[start:end][i], p)
	invariant forall i int :: { &s[start:end][i] }{ &s[start + i] } 0 <= i && i < len(s[start:end]) ==> &s[start:end][i] == &s[start + i]
	invariant forall i int :: { &s[i] } start <= i && i < start+j ==> acc(&s[i], p)
	decreases len(s[start:end]) - j
	for j := 0; j < len(s[start:end]); j++ {
		assert forall i int :: { &s[i] } start <= i && i < start+j ==> acc(&s[i], p)
		assert &s[start:end][j] == &s[start + j]
		assert acc(&s[start + j], p)
		assert forall i int :: { &s[i] } start <= i && i <= start+j ==> acc(&s[i], p)
	}
	fold acc(AbsSlice_Any(s, start, end), p)
}

/** End of slices of Any without Contents **/
