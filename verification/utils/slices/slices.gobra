// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package slices

// How to extend this file:
// - if we need to support slices of non-supported types, we must repeat all definitions
//   for that type. For this, we should be careful to avoid introducing cylical dependencies.
//   The suffix of the predicate/function should be the type of the elems of the slices.
// - For each type, there might be two different types of operations: those that keep track
//   of contents (the name of the operation ends in "C"), and those who do not.

ghost
requires 0 < p
requires 0 <= start && start <= end && end <= cap(s) && forall i int :: { &s[i] } start <= i && i < end ==> acc(&s[i], p)
// the following precondition convinces Gobra that
// the slice operation is well-formed
requires   true
ensures  0 <= 0 && 0 <= len(s[start:end]) && len(s[start:end]) <= cap(s[start:end]) && forall i int :: { &s[start:end][i] } 0 <= i && i < len(s[start:end]) ==> acc(&s[start:end][i], p)
ensures forall i int :: { &s[start:end][i] }{ &s[start + i] } 0 <= i && i < (end-start) ==> &s[start:end][i] == &s[start + i]
decreases
func Reslice_Bytes(s []byte, start int, end int, p perm) {
	assert forall i int :: { &s[start:end][i] }{ &s[start + i] } 0 <= i && i < (end-start) ==> &s[start:end][i] == &s[start + i]
}

ghost
requires 0 < p
requires 0 <= start && start <= end && end <= cap(s)
requires len(s[start:end]) <= cap(s)
requires 0 <= 0 && 0 <= len(s[start:end]) && len(s[start:end]) <= cap(s[start:end]) && forall i int :: { &s[start:end][i] } 0 <= i && i < len(s[start:end]) ==> acc(&s[start:end][i], p)
ensures  0 <= start && start <= end && end <= cap(s) && forall i int :: { &s[i] } start <= i && i < end ==> acc(&s[i], p)
decreases
func Unslice_Bytes(s []byte, start int, end int, p perm) {

	assert 0 <= start && start <= end && end <= cap(s)
	assert forall i int :: { &s[start:end][i] } 0 <= i && i < len(s[start:end]) ==> acc(&s[start:end][i], p)
	assert forall i int :: { &s[start:end][i] }{ &s[start + i] } 0 <= i && i < len(s[start:end]) ==> &s[start:end][i] == &s[start + i]

	invariant 0 <= j && j <= len(s[start:end])
	invariant forall i int :: { &s[start:end][i] } j <= i && i < len(s[start:end]) ==> acc(&s[start:end][i], p)
	invariant forall i int :: { &s[start:end][i] }{ &s[start + i] } 0 <= i && i < len(s[start:end]) ==> &s[start:end][i] == &s[start + i]
	invariant forall i int :: { &s[i] } start <= i && i < start+j ==> acc(&s[i], p)
	decreases len(s[start:end]) - j
	for j := 0; j < len(s[start:end]); j++ {
		assert forall i int :: { &s[i] } start <= i && i < start+j ==> acc(&s[i], p)
		assert &s[start:end][j] == &s[start + j]
		assert acc(&s[start + j], p)
		assert forall i int :: { &s[i] } start <= i && i <= start+j ==> acc(&s[i], p)
	}

}

ghost
requires 0 < p
requires 0 <= start && start <= end && end <= len(s)
requires 0 <= 0 && 0 <= len(s) && len(s) <= cap(s) && forall i int :: { &s[i] } 0 <= i && i < len(s) ==> acc(&s[i], p)
ensures  0 <= 0 && 0 <= end-start && end-start <= cap(s[start:end]) && forall i int :: { &s[start:end][i] } 0 <= i && i < end-start ==> acc(&s[start:end][i], p)
ensures  0 <= 0 && 0 <= start && start <= cap(s) && forall i int :: { &s[i] } 0 <= i && i < start ==> acc(&s[i], p)
ensures  0 <= end && end <= len(s) && len(s) <= cap(s) && forall i int :: { &s[i] } end <= i && i < len(s) ==> acc(&s[i], p)
decreases
func SplitRange_Bytes(s []byte, start int, end int, p perm) {
	Reslice_Bytes(s, start, end, p)
}

ghost
requires 0 < p
requires 0 <= start && start <= end && end <= len(s)
requires 0 <= 0 && 0 <= end-start && end-start <= cap(s[start:end]) && forall i int :: { &s[start:end][i] } 0 <= i && i < end-start ==> acc(&s[start:end][i], p)
requires 0 <= 0 && 0 <= start && start <= cap(s) && forall i int :: { &s[i] } 0 <= i && i < start ==> acc(&s[i], p)
requires 0 <= end && end <= len(s) && len(s) <= cap(s) && forall i int :: { &s[i] } end <= i && i < len(s) ==> acc(&s[i], p)
ensures  0 <= 0 && 0 <= len(s) && len(s) <= cap(s) && forall i int :: { &s[i] } 0 <= i && i < len(s) ==> acc(&s[i], p)
decreases
func CombineRange_Bytes(s []byte, start int, end int, p perm) {
	Unslice_Bytes(s, start, end, p)
}

type Unit struct{}

ghost
requires 0 <= subStart
requires subStart <= subEnd
requires subEnd <= cap(s)
ensures  forall i int :: { &s[subStart:subEnd][i] } 0 <= i && i < len(s[subStart:subEnd]) ==>
	&s[subStart:subEnd][i] == &s[subStart+i]
decreases
pure func AssertSliceOverlap(ghost s []byte, ghost subStart int, ghost subEnd int) Unit {
	return Unit{}
}
