// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Signatures for the public declarations in file
// https://github.com/golang/go/blob/master/src/errors/wrap.go

// +gobra

package errors

// Unwrap returns the result of calling the Unwrap method on err, if err's
// type contains an Unwrap method returning error.
// Otherwise, Unwrap returns nil.
requires  err.ErrorMem()
ensures   res.ErrorMem()
ensures   res.ErrorMem() --* err.ErrorMem()
// we assume termination; to lift this assumption, we would
// some sort of measure into the depth of an error to bound
// the number of recursive calls that can happen to error.
// This requires large changes to the error type.
decreases _
func Unwrap(err error) (res error)

// Is reports whether any error in err's chain matches target.
//
// The chain consists of err itself followed by the sequence of errors obtained by
// repeatedly calling Unwrap.
//
// An error is considered to match a target if it is equal to that target or if
// it implements a method Is(error) bool such that Is(target) returns true.
//
// An error type might provide an Is method so it can be treated as equivalent
// to an existing error. For example, if MyError defines
//
//	func (m MyError) Is(target error) bool { return target == fs.ErrExist }
//
// then Is(MyError{}, fs.ErrExist) returns true. See syscall.Errno.Is for
// an example in the standard library. An Is method should only shallowly
// compare err and the target and not call Unwrap on either.
preserves err    != nil && err.ErrorMem()
preserves target != nil && target.ErrorMem()
// we assume termination; to lift this assumption, we would
// some sort of measure into the depth of an error to bound
// the number of recursive calls that can happen to error.
// This requires large changes to the error type.
decreases _
func Is(err, target error) (res bool)

// As finds the first error in err's chain that matches target, and if one is found, sets
// target to that error value and returns true. Otherwise, it returns false.
//
// The chain consists of err itself followed by the sequence of errors obtained by
// repeatedly calling Unwrap.
//
// An error matches target if the error's concrete value is assignable to the value
// pointed to by target, or if the error has a method As(interface{}) bool such that
// As(target) returns true. In the latter case, the As method is responsible for
// setting target.
//
// An error type might provide an As method so it can be treated as if it were a
// different error type.
//
// As panics if target is not a non-nil pointer to either a type that implements
// error, or to any interface type.
requires  err    != nil ==> err.ErrorMem()
requires  target != nil
preserves target.Mem()
ensures   res ==> (
	let nestedErr := target.Get() in
	err != nil &&
	nestedErr != nil &&
	nestedErr.ErrorMem() &&
	(nestedErr.ErrorMem() --* err.ErrorMem()))
ensures   !res ==> err.ErrorMem()
// we assume termination; to lift this assumption, we would
// some sort of measure into the depth of an error to bound
// the number of recursive calls that can happen to error.
// This requires large changes to the error type.
decreases _
func As(err error, target ErrorCell) (res bool)

type ErrorCell interface {
	pred Mem()

	ghost
	requires  Mem() && CanSet(e)
	ensures   Mem() && Get() === e
	decreases
	Set(e error)

	ghost
	pure
	requires acc(Mem(), _)
	decreases
	Get() error

	ghost
	pure
	requires acc(Mem(), _) && acc(e.ErrorMem(), _)
	decreases
	CanSet(e error) bool
}