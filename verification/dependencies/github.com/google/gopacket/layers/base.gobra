// Copyright 2012 Google, Inc. All rights reserved.
//
// Use of this source code is governed by a BSD-style license
// that can be found in the LICENSE file in the root of the source
// tree.

// +gobra

package layers

import sl "github.com/scionproto/scion/verification/utils/slices"

type BaseLayer struct {
	Contents []byte
	Payload []byte
}

pred (b *BaseLayer) Mem() {
	acc(b) && acc(b.Contents) && acc(b.Payload)
}

pred (b *BaseLayer) LayerMem() {
	acc(b) && acc(b.Contents)
}

pred (b *BaseLayer) PayloadMem() {
	acc(b) && acc(b.Payload)
}

requires b.LayerMem()
ensures 0 <= 0 && 0 <= len(res) && len(res) <= cap(res) && forall i int :: { &res[i] } 0 <= i && i < len(res) ==> acc(&res[i])
ensures 0 <= 0 && 0 <= len(res) && len(res) <= cap(res) && forall i int :: { &res[i] } 0 <= i && i < len(res) ==> acc(&res[i]) --* b.LayerMem()
decreases
func (b *BaseLayer) LayerContents() (res []byte) {
	unfold b.LayerMem()
	res = b.Contents

	package 0 <= 0 && 0 <= len(res) && len(res) <= cap(res) && forall i int :: { &res[i] } 0 <= i && i < len(res) ==> acc(&res[i]) --* b.LayerMem() {

		fold b.LayerMem()
	}
}

requires b.PayloadMem()
ensures 0 <= 0 && 0 <= len(res) && len(res) <= cap(res) && forall i int :: { &res[i] } 0 <= i && i < len(res) ==> acc(&res[i])
ensures 0 <= 0 && 0 <= len(res) && len(res) <= cap(res) && forall i int :: { &res[i] } 0 <= i && i < len(res) ==> acc(&res[i]) --* b.PayloadMem()
decreases
func (b *BaseLayer) LayerPayload() (res []byte) {
	unfold b.PayloadMem()
	res = b.Payload

	package 0 <= 0 && 0 <= len(res) && len(res) <= cap(res) && forall i int :: { &res[i] } 0 <= i && i < len(res) ==> acc(&res[i]) --* b.PayloadMem() {

		fold b.PayloadMem()
	}
}
