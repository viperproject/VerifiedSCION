// Copyright 2012 Google, Inc. All rights reserved.
//
// Use of this source code is governed by a BSD-style license
// that can be found in the LICENSE file in the root of the source
// tree.

// +gobra

package gopacket

import "github.com/scionproto/scion/verification/utils/slices"

type Layer interface {
	// Since the resources abstracted in LayerMem and PayloadMem might overlap,
	// it may not be possible to hold an instance of each at once.
	// Hence, we have Mem that abstracts all the resources associated with
	// the layer.
	pred Mem(ub []byte)
	pred LayerMem(ub []byte)
	pred PayloadMem(ub []byte)

	requires acc(Mem(ub), _)
	decreases
	pure LayerType(ghost ub []byte) LayerType

	requires LayerMem(ub)
	ensures slices.AbsSlice_Bytes(res, 0, len(res))
	ensures slices.AbsSlice_Bytes(res, 0, len(res)) --* LayerMem(ub)
	decreases
	LayerContents(ghost ub []byte) (res []byte)

	requires PayloadMem(ub)
	ensures slices.AbsSlice_Bytes(res, 0, len(res))
	ensures slices.AbsSlice_Bytes(res, 0, len(res)) --* PayloadMem(ub)
	decreases
	LayerPayload(ghost ub []byte) (res []byte)
}

type Payload []byte

pred (p Payload) LayerMem(ub []byte) { acc(p) }
pred (p Payload) PayloadMem(ub []byte) { true }
pred (p Payload) Mem(ub []byte) { acc(p) }

requires acc(p.Mem(ub), _)
decreases
pure func (p Payload) LayerType(ghost ub []byte) LayerType {
	return unfolding acc(p.Mem(ub), _) in LayerTypePayload
}

requires p.LayerMem(ub)
ensures slices.AbsSlice_Bytes(res, 0, len(res))
ensures slices.AbsSlice_Bytes(res, 0, len(res)) --* p.LayerMem(ub)
decreases
func (p Payload) LayerContents(ghost ub []byte) (res []byte) {
	unfold p.LayerMem()
	res = []byte(p)
	assert forall i int :: 0 <= i && i < len(p) ==> acc(&p[i])
	fold slices.AbsSlice_Bytes(res, 0, len(res))
	package slices.AbsSlice_Bytes(res, 0, len(res)) --* p.LayerMem(ub) {
		unfold slices.AbsSlice_Bytes(res, 0, len(res))
		fold p.LayerMem(ub)
	}
}

requires p.PayloadMem(ub)
ensures res == nil
ensures slices.AbsSlice_Bytes(res, 0, len(res))
ensures slices.AbsSlice_Bytes(res, 0, len(res)) --* p.PayloadMem(ub)
decreases
func (p Payload) LayerPayload(ghost ub []byte) (res []byte) {
	unfold p.PayloadMem(ub)
	res = nil
	fold slices.AbsSlice_Bytes(res, 0, len(res))
	package slices.AbsSlice_Bytes(res, 0, len(res)) --* p.PayloadMem(ub) {
		unfold slices.AbsSlice_Bytes(res, 0, len(res))
		fold p.PayloadMem(ub)
	}
}

requires p.LayerMem(ub)
ensures slices.AbsSlice_Bytes(res, 0, len(res))
ensures slices.AbsSlice_Bytes(res, 0, len(res)) --* p.LayerMem(ub)
ensures res === []byte(p)
decreases
func (p Payload) Payload(ghost ub []byte) (res []byte) {
	unfold p.LayerMem(ub)
	res = []byte(p)
	assert forall i int :: 0 <= i && i < len(p) ==> acc(&p[i])
	fold slices.AbsSlice_Bytes(res, 0, len(res))
	package slices.AbsSlice_Bytes(res, 0, len(res)) --* p.LayerMem(ub) {
		unfold slices.AbsSlice_Bytes(res, 0, len(res))
		fold p.LayerMem(ub)
	}
}

Payload implements Layer
Payload implements ApplicationLayer

type LinkLayer interface {
	Layer

	requires false
	decreases
	LinkFlow() Flow
}

type NetworkLayer interface {
	Layer

	requires false
	decreases
	NetworkFlow() Flow
}

type TransportLayer interface {
	Layer

	preserves acc(LayerMem(), 1/10000)
	decreases
	TransportFlow() Flow
}

type ApplicationLayer interface {
	Layer

	requires LayerMem()
	ensures slices.AbsSlice_Bytes(res, 0, len(res))
	ensures slices.AbsSlice_Bytes(res, 0, len(res)) --* LayerMem()
	decreases
	Payload() (res []byte)
}

type ErrorLayer interface {
	Layer

	preserves Mem()
	decreases
	Error() error
}
