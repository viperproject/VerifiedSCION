// Copyright 2012 Google, Inc. All rights reserved.
//
// Use of this source code is governed by a BSD-style license
// that can be found in the LICENSE file in the root of the source
// tree.

// +gobra

package gopacket

import (
	"fmt"
)

// Layer represents a single decoded packet layer (using either the
// OSI or TCP/IP definition of a layer).  When decoding, a packet's data is
// broken up into a number of layers.  The caller may call LayerType() to
// figure out which type of layer they've received from the packet.  Optionally,
// they may then use a type assertion to get the actual layer type for deep
// inspection of the data.
type Layer interface {
	// Memory predicate for Layer
	pred Mem()
	// LayerType is the gopacket type for this layer.
	pure LayerType() LayerType
	// LayerContents returns the set of bytes that make up this layer.
	requires Mem()
	ensures acc(res)
	ensures acc(res) --* Mem()
	decreases
	LayerContents() (res []byte)
	// LayerPayload returns the set of bytes contained within this layer, not
	// including the layer itself.
	requires Mem()
	ensures acc(res)
	ensures acc(res) --* Mem()
	decreases
	LayerPayload() (res []byte)
}

// Payload is a Layer containing the payload of a packet.  The definition of
// what constitutes the payload of a packet depends on previous layers; for
// TCP and UDP, we stop decoding above layer 4 and return the remaining
// bytes as a Payload.  Payload is an ApplicationLayer.
type Payload []byte

pred (p Payload) Mem() { acc(p) }

// LayerType returns LayerTypePayload
decreases
pure func (p Payload) LayerType() LayerType { return LayerTypePayload() }

// LayerContents returns the bytes making up this layer.
requires acc(p)
ensures acc(res)
ensures acc(res) --* acc(p)
decreases
func (p Payload) LayerContents() (res []byte) {
	res = []byte(p)
	assert forall i int :: 0 <= i && i < len(p) ==> acc(&p[i])
	package acc(res) --* acc(p)
}

// LayerPayload returns the payload within this layer.
decreases
func (p Payload) LayerPayload() []byte { return nil }

// Payload returns this layer as bytes.
requires acc(p)
ensures acc(res)
ensures acc(res) --* acc(p)
decreases
func (p Payload) Payload() (res []byte) {
	res = []byte(p)
	assert forall i int :: 0 <= i && i < len(p) ==> acc(&p[i])
	package acc(res) --* acc(p)
}

// These layers correspond to Internet Protocol Suite (TCP/IP) layers, and their
// corresponding OSI layers, as best as possible.

// LinkLayer is the packet layer corresponding to TCP/IP layer 1 (OSI layer 2)
type LinkLayer interface {
	// Memory predicate for Layer
	pred Mem()
	// LayerType is the gopacket type for this layer.
	pure LayerType() LayerType
	// LayerContents returns the set of bytes that make up this layer.
	requires Mem()
	ensures acc(res)
	ensures acc(res) --* Mem()
	LayerContents() (res []byte)
	// LayerPayload returns the set of bytes contained within this layer, not
	// including the layer itself.
	requires Mem()
	ensures acc(res)
	ensures acc(res) --* Mem()
	LayerPayload() (res []byte)
	
	LinkFlow() Flow
}

// NetworkLayer is the packet layer corresponding to TCP/IP layer 2 (OSI
// layer 3)
type NetworkLayer interface {
	// Memory predicate for Layer
	pred Mem()
	// LayerType is the gopacket type for this layer.
	pure LayerType() LayerType
	// LayerContents returns the set of bytes that make up this layer.
	requires Mem()
	ensures acc(res)
	ensures acc(res) --* Mem()
	LayerContents() (res []byte)
	// LayerPayload returns the set of bytes contained within this layer, not
	// including the layer itself.
	requires Mem()
	ensures acc(res)
	ensures acc(res) --* Mem()
	LayerPayload() (res []byte)
	
	NetworkFlow() Flow
}

// TransportLayer is the packet layer corresponding to the TCP/IP layer 3 (OSI
// layer 4)
type TransportLayer interface {
	// Memory predicate for Layer
	pred Mem()
	// LayerType is the gopacket type for this layer.
	pure LayerType() LayerType
	// LayerContents returns the set of bytes that make up this layer.
	requires Mem()
	ensures acc(res)
	ensures acc(res) --* Mem()
	LayerContents() (res []byte)
	// LayerPayload returns the set of bytes contained within this layer, not
	// including the layer itself.
	requires Mem()
	ensures acc(res)
	ensures acc(res) --* Mem()
	LayerPayload() (res []byte)
	TransportFlow() Flow
}

// ApplicationLayer is the packet layer corresponding to the TCP/IP layer 4 (OSI
// layer 7), also known as the packet payload.
type ApplicationLayer interface {
		// Memory predicate for Layer
	pred Mem()
	// LayerType is the gopacket type for this layer.
	pure LayerType() LayerType
	// LayerContents returns the set of bytes that make up this layer.
	requires Mem()
	ensures acc(res)
	ensures acc(res) --* Mem()
	LayerContents() (res []byte)
	// LayerPayload returns the set of bytes contained within this layer, not
	// including the layer itself.
	requires Mem()
	ensures acc(res)
	ensures acc(res) --* Mem()
	LayerPayload() (res []byte)
	
	Payload() []byte
}

// ErrorLayer is a packet layer created when decoding of the packet has failed.
// Its payload is all the bytes that we were unable to decode, and the returned
// error details why the decoding failed.
type ErrorLayer interface {
		// Memory predicate for Layer
	pred Mem()
	// LayerType is the gopacket type for this layer.
	pure LayerType() LayerType
	// LayerContents returns the set of bytes that make up this layer.
	requires Mem()
	ensures acc(res)
	ensures acc(res) --* Mem()
	LayerContents() (res []byte)
	// LayerPayload returns the set of bytes contained within this layer, not
	// including the layer itself.
	requires Mem()
	ensures acc(res)
	ensures acc(res) --* Mem()
	LayerPayload() (res []byte)
	
	Error() error
}
