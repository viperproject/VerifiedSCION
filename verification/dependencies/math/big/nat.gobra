// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file implements unsigned multi-precision integers (natural
// numbers). They are the building blocks for the implementation
// of signed integers, rationals, and floating-point numbers.
//
// Caution: This implementation relies on the function "alias"
//          which assumes that (nat) slice capacities are never
//          changed (no 3-operand slice expressions). If that
//          changes, alias needs to be updated for correctness.

// +gobra

package big

// An unsigned integer x of the form
//
//	x = x[n-1]*_B^(n-1) + x[n-2]*_B^(n-2) + ... + x[1]*_B + x[0]
//
// with 0 <= x[i] < _B and 0 <= i < n is stored in a slice of length n,
// with the digits x[i] as the slice elements.
//
// A number is normalized if the slice contains no leading 0 digits.
// During arithmetic operations, denormalized values may occur but are
// always normalized before returning the final result. The normalized
// representation of 0 is the empty or nil slice (length = 0).
type nat []Word

pred (n nat) Mem() {
	acc(n) && len(n) > 0
}

ghost
requires acc(n.Mem(), 1/10000)
pure func (n nat) toInt() int64 {
	return unfolding acc(n.Mem(), 1/10000) in toIntHelper(n, 0)
}

ghost
requires acc(n, 1/10000) && len(n) > 0
requires 0 <= i && i < len(n)
pure func toIntHelper (n nat, i int) int64 {
	return i == len(n) - 1 ? int64(n[i]) : int64(n[i]) + 32 * toIntHelper(n, i + 1)
}
