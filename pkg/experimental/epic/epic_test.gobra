// Copyright 2021 ETH Zurich, Anapaya Systems
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package epic

import (
	"github.com/scionproto/scion/pkg/addr"
    "github.com/scionproto/scion/pkg/slayers"
	pathepic "github.com/scionproto/scion/pkg/slayers/path/epic"
    "github.com/scionproto/scion/verification/utils/definitions" // import necessary for R18
    sl "github.com/scionproto/scion/verification/utils/slices" // import necessary for precondition about ghost parameter
    "net"
    "time"
)

// NO ERROR
// doesn't verify
func TestPrepareMacInput1(ghostWildcard bool, ghostUb []byte) {
    // inline createEpicPath
	pktID := pathepic.PktID{
        Timestamp: 1,
        Counter:   PktCounterFromCore(2, 3),
    }
    e := &pathepic.Path{
        PktID: pktID,
        PHVF:  []byte{1, 2, 3, 4},
        LHVF:  []byte{5, 6, 7, 8},
    }

    // inline createScionCmnAddrHdr
    // inline MustParseIA
    srcIa, err := addr.ParseIA("2-ff00:0:222")
    if err != nil {
        // panic(err) // omit panic calls
    }

    header := &slayers.SCION{
        SrcIA:      srcIa,
        PayloadLen: 120,
    }
    ip4Addr := &net.IPAddr{IP: net.ParseIP("10.0.0.100")}

    inhale ghostWildcard ==> acc(ip4Addr.Mem(), _) // inhale precondition of call with ghost parameter
    inhale !ghostWildcard ==> acc(ip4Addr.Mem(), definitions.R18) // inhale precondition of call with ghost parameter
    header.SetSrcAddr(ip4Addr, ghostWildcard)

    expected := []byte(
        "\x00\x4a\xf9\xf0\x70\x00\x00\x00\x01\x02\x00\x00\x03" +
            "\x00\x02\xff\x00\x00\x00\x02\x22\x0a\x00\x00\x64\x00\x78" +
            "\x00\x00\x00\x00\x00")

	var ts uint32 = 1257894000 // = [4a f9 f0 70]

    inputBuffer := make([]byte, MACBufferSize)

    inhale acc(header.Mem(ghostUb), definitions.R20) // inhale precondition of call with ghost parameter
    inhale acc(sl.Bytes(ghostUb, 0, len(ghostUb)), definitions.R20) // inhale precondition of call with ghost parameter
    fold sl.Bytes(inputBuffer, 0, len(inputBuffer)) // fold of predicate in precondition
    inputLength, err := prepareMacInput(e.PktID, header, ts, inputBuffer, ghostUb)

    assert err == nil // assertion fails

    got := inputBuffer[:inputLength]

    assert got === expected
}

// NO ERROR
// doesn't verify
func TestPrepareMacInput1DebuggingInfo(pktID pathepic.PktID, s *slayers.SCION, timestamp uint32, inputBuffer []byte, ghost ghostUb []byte) {
    inhale acc(s.Mem(ghostUb), definitions.R20)
    inhale acc(sl.Bytes(ghostUb, 0, len(ghostUb)), definitions.R20)
    inhale sl.Bytes(inputBuffer, 0, len(inputBuffer))

    tmpPktID := pathepic.PktID{
        Timestamp: 1,
        Counter:   33554435,
    }
    tmpS := &slayers.SCION{
        SrcIA:      843325418504738,
        RawSrcAddr: []uint8{10, 0, 0, 100},
    }
    tmpTimestamp := uint32(1257894000)
    tmpInputBuffer := []byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

    assume pktID == tmpPktID
    assume s == tmpS
    assume timestamp == tmpTimestamp
    assume inputBuffer === tmpInputBuffer

    // actual test
    inputLength, err := prepareMacInput(pktID, s, timestamp, inputBuffer, ghostUb)

    assert err == nil // assertion fails

    got := inputBuffer[:inputLength]

    expected := []byte(
        "\x00\x4a\xf9\xf0\x70\x00\x00\x00\x01\x02\x00\x00\x03" +
            "\x00\x02\xff\x00\x00\x00\x02\x22\x0a\x00\x00\x64\x00\x78" +
            "\x00\x00\x00\x00\x00")

    assert got === expected
}

// ERROR
// doesn't verify
func TestPrepareMacInput2(pktID pathepic.PktID, s *slayers.SCION, timestamp uint32, inputBuffer []byte, ub []byte) {
    // inline createEpicPath
    inpPktID := pathepic.PktID{
        Timestamp: 1,
        Counter:   PktCounterFromCore(2, 3),
    }
    e := &pathepic.Path{
        PktID: inpPktID,
        PHVF:  []byte{1, 2, 3, 4},
        LHVF:  []byte{5, 6, 7, 8},
    }

    inp := make([]byte, MACBufferSize)

    assume pktID === e.PktID
    assume s == nil
    assume timestamp == 1257894000 // = [4a f9 f0 70]
    assume inputBuffer === inp

    inhale  MACBufferSize <= len(inputBuffer)
    inhale acc(s.Mem(ub), definitions.R20)
    inhale acc(sl.Bytes(ub, 0, len(ub)), definitions.R20)
    inhale sl.Bytes(inputBuffer, 0, len(inputBuffer))
    _, err := prepareMacInput(pktID, s, timestamp, inputBuffer, ub)

    assert err != nil // assertion fails (test would verify if prepareMacInput had precondition s == nil ==> reserr != nil)
}

// ERROR
// doesn't verify
func TestCreateTimestamp1(input time.Time, now time.Time) {
    nowInp := time.Now().Truncate(time.Second)
    assume now == nowInp

    inp := time.Unix(0, 0)
    assume input == inp

    res, err := CreateTimestamp(input, now)

    assert err != nil
    assert res == 0
}

// ERROR
// doesn't verify
func TestCreateTimestamp2(input time.Time, now time.Time) {
    nowInp := time.Now().Truncate(time.Second)
    assume now == nowInp

    // inline createTimeHMS
    tmp1 := (time.Duration(24) * time.Hour) +
        (time.Duration(64) * time.Minute) +
        (time.Duration(0) * time.Second)
    tmp2 := -tmp1
    inp := now.Add(tmp2)
    assume input == inp

    res, err := CreateTimestamp(input, now)

    assert err != nil
    assert res == 0
}

// NO ERROR
// doesn't verify
func TestCreateTimestamp3() {
    now := time.Now().Truncate(time.Second)

    // inline createTimeHMS
    tmp1 := (time.Duration(24) * time.Hour) +
        (time.Duration(63) * time.Minute) +
        (time.Duration(0) * time.Second)
    tmp2 := -tmp1
    input := now.Add(tmp2)

    // inline createTimeHMS
    tmp3 := (time.Duration(24) * time.Hour) +
        (time.Duration(63) * time.Minute) +
        (time.Duration(0) * time.Second)
    expected := tmp3 / TimestampResolution - 1

    res, err := CreateTimestamp(input, now)

    assert err == nil
    assert res == uint32(expected)
}

// ERROR
// doesn't verify
func TestVerifyTimestamp1(timestamp time.Time, epicTS uint32, now time.Time) {
    nowInp := time.Now().Truncate(time.Second)
    assume now == nowInp

    timestampInp := now.Add(-time.Minute)
    assume timestamp == timestampInp

    assume epicTS == 0

    err := VerifyTimestamp(timestamp, epicTS, now)

    assert err != nil
}

// ERROR
// doesn't verify
func TestVerifyTimestamp2(timestamp time.Time, epicTS uint32, now time.Time) {
    nowInp := time.Now().Truncate(time.Second)
    assume now == nowInp

    timestampInp := now.Add(-time.Minute)
    assume timestamp == timestampInp

    epicTSInp, err := CreateTimestamp(timestampInp, now)
    csAndPl := uint32(((MaxClockSkew + MaxPacketLifetime) / 21).Microseconds())

    assume epicTS == epicTSInp - csAndPl

    err := VerifyTimestamp(timestamp, epicTS, now)

    assert err != nil
}

// NO ERROR
// doesn't verify
func TestVerifyTimestamp3() {
    now := time.Now().Truncate(time.Second)
    timestamp := now.Add(-time.Minute)

    epicTSInp, err := CreateTimestamp(timestamp, now)
    csAndPl := uint32(((MaxClockSkew + MaxPacketLifetime) / 21).Microseconds())

    epicTS := epicTSInp - csAndPl + 1

    err := VerifyTimestamp(timestamp, epicTS, now)

    assert err == nil
}

// NO ERROR
// doesn't verify
func TestVerifyHVF1(ub []byte, wildcard bool, cmUb1 []byte) {
    // inline createScionCmnAddrHdr
    // inline MustParseIA
    ia, err := addr.ParseIA("2-ff00:0:222")
    if err != nil {
        // panic(err) // omit panic calls
    }

    spkt := &slayers.SCION{
        SrcIA:      ia,
        PayloadLen: 120,
    }
    ip4Addr := &net.IPAddr{IP: net.ParseIP("10.0.0.100")}

    inhale wildcard ==> acc(ip4Addr.Mem(), _) // inhale precondition of call with ghost parameter
    inhale !wildcard ==> acc(ip4Addr.Mem(), definitions.R18) // inhale precondition of call with ghost parameter
    _ := spkt.SetSrcAddr(ip4Addr, wildcard)

    s := spkt

    now := time.Now().Truncate(time.Second)
    timestamp := uint32(now.Add(-time.Minute).Unix())
    epicTS, _ := CreateTimestamp(now.Add(-time.Minute), time.Now())
    pktID := pathepic.PktID{
        Timestamp: epicTS,
        Counter:   PktCounterFromCore(1, 2),
    }

    // Use random authenticators
    authPenultimate := []byte("fcdc8202502d452e")
    authLast := []byte("f5fcc4ce2250db36")

    // Generate PHVF and LHVF
    buffer1 := []byte(nil)
    inhale acc(s.Mem(cmUb1), definitions.R20)
    inhale acc(sl.Bytes(cmUb1, 0, len(cmUb1)), definitions.R20)
    fold sl.Bytes(buffer1, 0, len(buffer1))
    fold acc(sl.Bytes(authPenultimate, 0, len(authPenultimate)), definitions.R30)
    PHVF, err := CalcMac(authPenultimate, pktID, s, timestamp, buffer1, cmUb1)
    assert err == nil

    buffer := make([]byte, MACBufferSize)

    inhale acc(s.Mem(ub), definitions.R20)
    inhale acc(sl.Bytes(ub, 0, len(ub)), definitions.R20)
    fold sl.Bytes(buffer, 0, len(buffer))
    fold acc(sl.Bytes(authPenultimate, 0, len(authPenultimate)), definitions.R30)
    err = VerifyHVF(authPenultimate, pktID, s, timestamp, PHVF, buffer, ub)

    assert err == nil
}

// NO ERROR
// doesn't verify
func TestVerifyHVF1Debugging(auth []byte, pktID pathepic.PktID, s *slayers.SCION,
    timestamp uint32, hvf []byte, buffer []byte, ghost ub []byte) {
    inhale sl.Bytes(buffer, 0, len(buffer))
    inhale acc(s.Mem(ub), definitions.R20)
    inhale acc(sl.Bytes(hvf, 0, len(hvf)), definitions.R50)
    inhale acc(sl.Bytes(ub, 0, len(ub)), definitions.R20)
    inhale acc(sl.Bytes(auth, 0, len(auth)), definitions.R30)

    tmpAuth := []uint8{102, 99, 100, 99, 56, 50, 48, 50, 53, 48, 50, 100, 52, 53, 50, 101}
    tmpPktID := pathepic.PktID{
        Timestamp: 2860218,
        Counter: 16777218,
    }
    tmpS := &slayers.SCION{
        SrcIA: 843325418504738,
        RawSrcAddr: []uint8{10, 0, 0, 100},
    }
    tmpTimestamp := uint32(1731680062)
    tmpHvf := []uint8{41, 127, 23, 2}
    tmpBuffer := []uint8{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

    assume auth === tmpAuth
    assume pktID == tmpPktID
    assume s == tmpS
    assume timestamp == tmpTimestamp
    assume hvf === tmpHvf
    assume buffer === tmpBuffer

    err := VerifyHVF(auth, pktID, s, timestamp, hvf, buffer, ub)

    assert err == nil
}

// ERROR
// doesn't verify
func TestVerifyHVF2(auth []byte, pktID pathepic.PktID, s *slayers.SCION,
    timestamp uint32, hvf []byte, buffer []byte,
    ub []byte, wildcard bool, cmUb1 []byte) {

    authInp := []byte("074487bf22e46742")
    assume auth === authInp

    // inline createScionCmnAddrHdr
    // inline MustParseIA
    ia, err := addr.ParseIA("2-ff00:0:222")
    if err != nil {
        // panic(err) // omit panic calls
    }

    spkt := &slayers.SCION{
        SrcIA:      ia,
        PayloadLen: 120,
    }
    ip4Addr := &net.IPAddr{IP: net.ParseIP("10.0.0.100")}

    inhale wildcard ==> acc(ip4Addr.Mem(), _) // inhale precondition of call with ghost parameter
    inhale !wildcard ==> acc(ip4Addr.Mem(), definitions.R18) // inhale precondition of call with ghost parameter
    _ := spkt.SetSrcAddr(ip4Addr, wildcard)

    assume s == spkt

    now := time.Now().Truncate(time.Second)
    timestampInp := uint32(now.Add(-time.Minute).Unix())

    assume timestamp == timestampInp

    epicTS, _ := CreateTimestamp(now.Add(-time.Minute), time.Now())
    pktIDInp := pathepic.PktID{
        Timestamp: epicTS,
        Counter:   PktCounterFromCore(1, 2),
    }

    assume pktID == pktIDInp

    // Use random authenticators
    authPenultimate := []byte("fcdc8202502d452e")
    authLast := []byte("f5fcc4ce2250db36")

    // Generate PHVF and LHVF
    buffer1 := []byte(nil)
    inhale acc(s.Mem(cmUb1), definitions.R20)
    inhale acc(sl.Bytes(cmUb1, 0, len(cmUb1)), definitions.R20)
    fold sl.Bytes(buffer1, 0, len(buffer1))
    fold acc(sl.Bytes(authPenultimate, 0, len(authPenultimate)), definitions.R30)
    PHVFInp, err := CalcMac(authPenultimate, pktID, s, timestamp, buffer1, cmUb1)
    assert err == nil

    assume hvf === PHVFInp

    bufferInp := make([]byte, MACBufferSize)

    assume buffer === bufferInp

    inhale acc(s.Mem(ub), definitions.R20)
    inhale acc(sl.Bytes(ub, 0, len(ub)), definitions.R20)
    fold sl.Bytes(buffer, 0, len(buffer))
    fold acc(sl.Bytes(authPenultimate, 0, len(authPenultimate)), definitions.R30)
    err = VerifyHVF(authPenultimate, pktID, s, timestamp, hvf, buffer, ub)

    assert err != nil // assertion fails
}

// NO ERROR
// doesn't verify
func TestPktCounterFromCore1() {
    coreID := uint8(0x01)
    coreCounter := uint32(0x1234)
    expected := uint32(0x01001234)

    got := PktCounterFromCore(coreID, coreCounter)
    assert got == expected
}

// NO ERROR
// doesn't verify
func TestPktCounterFromCore2() {
    coreID := uint8(0x01)
    coreCounter := uint32(0xffffffff)
    expected := uint32(0x01ffffff)

    got := PktCounterFromCore(coreID, coreCounter)
    assert got == expected
}

// NO ERROR
// doesn't verify
func TestCoreFromPktCounter() {
    pktCounter := uint32(0x12345678)
    expectedCoreID := uint8(0x12)
    expectedCoreCounter := uint32(0x345678)

    coreID, coreCounter := CoreFromPktCounter(pktCounter)
    assert expectedCoreID == coreID
    assert expectedCoreCounter == coreCounter
}
