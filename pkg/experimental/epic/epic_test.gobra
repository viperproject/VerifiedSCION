// Copyright 2021 ETH Zurich, Anapaya Systems
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package epic

import (
	"github.com/scionproto/scion/pkg/addr"
    "github.com/scionproto/scion/pkg/slayers"
    "github.com/scionproto/scion/pkg/slayers/path"
    pathepic "github.com/scionproto/scion/pkg/slayers/path/epic"
    "github.com/scionproto/scion/verification/utils/definitions" // import necessary for R18
    sl "github.com/scionproto/scion/verification/utils/slices" // import necessary for precondition about ghost parameter
    "net"
    "time"
)

// done
// NO ERROR
// doesn't verify
func TestPrepareMacInput1(pktID pathepic.PktID, s *slayers.SCION, timestamp uint32, inputBuffer []byte , ub []byte) {
    tmpPktID := pathepic.PktID{Timestamp:0x1, Counter:0x2000003}
    tmpS := &slayers.SCION{
        BaseLayer:slayers.BaseLayer{Contents:[]uint8(nil),
            Payload:[]uint8(nil)},
            Version:0x0,
            TrafficClass:0x0,
            FlowID:0x0,
            NextHdr:0x0,
            HdrLen:0x0,
            PayloadLen:0x78,
            PathType:0x0,
            DstAddrType:0x0,
            SrcAddrType:0x0,
            DstIA:0x0,
            SrcIA:0x2ff0000000222,
            RawDstAddr:[]uint8(nil),
            RawSrcAddr:[]uint8{0xa, 0x0, 0x0, 0x64},
            Path:path.Path(nil),
    }
    tmpInputBuffer := []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}

    inhale MACBufferSize <= len(inputBuffer)
    inhale acc(s.Mem(ub), definitions.R20)
    inhale acc(sl.Bytes(ub, 0, len(ub)), definitions.R20)
    inhale sl.Bytes(inputBuffer, 0, len(inputBuffer))

    assume pktID == tmpPktID
    assume s == tmpS
    assume timestamp == 0x4af9f070
    assume inputBuffer === tmpInputBuffer

    expected := []byte{0x0, 0x4a, 0xf9, 0xf0, 0x70, 0x0, 0x0, 0x0, 0x1, 0x2, 0x0, 0x0, 0x3, 0x0, 0x2, 0xff, 0x0, 0x0, 0x0, 0x2, 0x22, 0xa, 0x0, 0x0, 0x64, 0x0, 0x78, 0x0, 0x0, 0x0, 0x0, 0x0}

	inputLength, err := prepareMacInput(pktID, s, timestamp, inputBuffer, ub)

    assert err == nil // assertion fails

    got := inputBuffer[:inputLength]
    assert got === expected
}

// done
// NO ERROR
// doesn't verify
func TestPrepareMacInput2(pktID pathepic.PktID, s *slayers.SCION, timestamp uint32, inputBuffer []byte , ub []byte) {
    tmpPktID := pathepic.PktID{Timestamp:0x1, Counter:0x2000003}
    tmpS := (*slayers.SCION)(nil)
    tmpInputBuffer := []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}

    inhale MACBufferSize <= len(inputBuffer)
    inhale acc(s.Mem(ub), definitions.R20)
    inhale acc(sl.Bytes(ub, 0, len(ub)), definitions.R20)
    inhale sl.Bytes(inputBuffer, 0, len(inputBuffer))

    assume pktID == tmpPktID
    assume s == tmpS
    assume timestamp == 0x4af9f070
    assume inputBuffer === tmpInputBuffer

    _, err := prepareMacInput(pktID, s, timestamp, inputBuffer, ub)

    assert err != nil // assertion fails
}

// TODO
// ERROR
// doesn't verify
func TestCreateTimestamp1(input time.Time, now time.Time) {
    nowInp := time.Now().Truncate(time.Second)
    assume now == nowInp

    inp := time.Unix(0, 0)
    assume input == inp

    res, err := CreateTimestamp(input, now)

    assert err != nil
    assert res == 0
}

// ERROR
// doesn't verify
func TestCreateTimestamp2(input time.Time, now time.Time) {
    nowInp := time.Now().Truncate(time.Second)
    assume now == nowInp

    // inline createTimeHMS
    tmp1 := (time.Duration(24) * time.Hour) +
        (time.Duration(64) * time.Minute) +
        (time.Duration(0) * time.Second)
    tmp2 := -tmp1
    inp := now.Add(tmp2)
    assume input == inp

    res, err := CreateTimestamp(input, now)

    assert err != nil
    assert res == 0
}

// NO ERROR
// doesn't verify
func TestCreateTimestamp3() {
    now := time.Now().Truncate(time.Second)

    // inline createTimeHMS
    tmp1 := (time.Duration(24) * time.Hour) +
        (time.Duration(63) * time.Minute) +
        (time.Duration(0) * time.Second)
    tmp2 := -tmp1
    input := now.Add(tmp2)

    // inline createTimeHMS
    tmp3 := (time.Duration(24) * time.Hour) +
        (time.Duration(63) * time.Minute) +
        (time.Duration(0) * time.Second)
    expected := tmp3 / TimestampResolution - 1

    res, err := CreateTimestamp(input, now)

    assert err == nil
    assert res == uint32(expected)
}

// ERROR
// doesn't verify
func TestVerifyTimestamp1(timestamp time.Time, epicTS uint32, now time.Time) {
    nowInp := time.Now().Truncate(time.Second)
    assume now == nowInp

    timestampInp := now.Add(-time.Minute)
    assume timestamp == timestampInp

    assume epicTS == 0

    err := VerifyTimestamp(timestamp, epicTS, now)

    assert err != nil
}

// ERROR
// doesn't verify
func TestVerifyTimestamp2(timestamp time.Time, epicTS uint32, now time.Time) {
    nowInp := time.Now().Truncate(time.Second)
    assume now == nowInp

    timestampInp := now.Add(-time.Minute)
    assume timestamp == timestampInp

    epicTSInp, err := CreateTimestamp(timestampInp, now)
    csAndPl := uint32(((MaxClockSkew + MaxPacketLifetime) / 21).Microseconds())

    assume epicTS == epicTSInp - csAndPl

    err := VerifyTimestamp(timestamp, epicTS, now)

    assert err != nil
}

// NO ERROR
// doesn't verify
func TestVerifyTimestamp3() {
    now := time.Now().Truncate(time.Second)
    timestamp := now.Add(-time.Minute)

    epicTSInp, err := CreateTimestamp(timestamp, now)
    csAndPl := uint32(((MaxClockSkew + MaxPacketLifetime) / 21).Microseconds())

    epicTS := epicTSInp - csAndPl + 1

    err := VerifyTimestamp(timestamp, epicTS, now)

    assert err == nil
}

// NO ERROR
// doesn't verify
func TestVerifyHVF1(ub []byte, wildcard bool, cmUb1 []byte) {
    // inline createScionCmnAddrHdr
    // inline MustParseIA
    ia, err := addr.ParseIA("2-ff00:0:222")
    if err != nil {
        // panic(err) // omit panic calls
    }

    spkt := &slayers.SCION{
        SrcIA:      ia,
        PayloadLen: 120,
    }
    ip4Addr := &net.IPAddr{IP: net.ParseIP("10.0.0.100")}

    inhale wildcard ==> acc(ip4Addr.Mem(), _) // inhale precondition of call with ghost parameter
    inhale !wildcard ==> acc(ip4Addr.Mem(), definitions.R18) // inhale precondition of call with ghost parameter
    _ := spkt.SetSrcAddr(ip4Addr, wildcard)

    s := spkt

    now := time.Now().Truncate(time.Second)
    timestamp := uint32(now.Add(-time.Minute).Unix())
    epicTS, _ := CreateTimestamp(now.Add(-time.Minute), time.Now())
    pktID := pathepic.PktID{
        Timestamp: epicTS,
        Counter:   PktCounterFromCore(1, 2),
    }

    // Use random authenticators
    authPenultimate := []byte("fcdc8202502d452e")
    authLast := []byte("f5fcc4ce2250db36")

    // Generate PHVF and LHVF
    buffer1 := []byte(nil)
    inhale acc(s.Mem(cmUb1), definitions.R20)
    inhale acc(sl.Bytes(cmUb1, 0, len(cmUb1)), definitions.R20)
    fold sl.Bytes(buffer1, 0, len(buffer1))
    fold acc(sl.Bytes(authPenultimate, 0, len(authPenultimate)), definitions.R30)
    PHVF, err := CalcMac(authPenultimate, pktID, s, timestamp, buffer1, cmUb1)
    assert err == nil

    buffer := make([]byte, MACBufferSize)

    inhale acc(s.Mem(ub), definitions.R20)
    inhale acc(sl.Bytes(ub, 0, len(ub)), definitions.R20)
    fold sl.Bytes(buffer, 0, len(buffer))
    fold acc(sl.Bytes(authPenultimate, 0, len(authPenultimate)), definitions.R30)
    err = VerifyHVF(authPenultimate, pktID, s, timestamp, PHVF, buffer, ub)

    assert err == nil
}

// NO ERROR
// doesn't verify
func TestVerifyHVF1Debugging(auth []byte, pktID pathepic.PktID, s *slayers.SCION,
    timestamp uint32, hvf []byte, buffer []byte, ghost ub []byte) {
    inhale sl.Bytes(buffer, 0, len(buffer))
    inhale acc(s.Mem(ub), definitions.R20)
    inhale acc(sl.Bytes(hvf, 0, len(hvf)), definitions.R50)
    inhale acc(sl.Bytes(ub, 0, len(ub)), definitions.R20)
    inhale acc(sl.Bytes(auth, 0, len(auth)), definitions.R30)

    tmpAuth := []uint8{102, 99, 100, 99, 56, 50, 48, 50, 53, 48, 50, 100, 52, 53, 50, 101}
    tmpPktID := pathepic.PktID{
        Timestamp: 2860218,
        Counter: 16777218,
    }
    tmpS := &slayers.SCION{
        SrcIA: 843325418504738,
        RawSrcAddr: []uint8{10, 0, 0, 100},
    }
    tmpTimestamp := uint32(1731680062)
    tmpHvf := []uint8{41, 127, 23, 2}
    tmpBuffer := []uint8{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

    assume auth === tmpAuth
    assume pktID == tmpPktID
    assume s == tmpS
    assume timestamp == tmpTimestamp
    assume hvf === tmpHvf
    assume buffer === tmpBuffer

    err := VerifyHVF(auth, pktID, s, timestamp, hvf, buffer, ub)

    assert err == nil
}

// ERROR
// doesn't verify
func TestVerifyHVF2(auth []byte, pktID pathepic.PktID, s *slayers.SCION,
    timestamp uint32, hvf []byte, buffer []byte,
    ub []byte, wildcard bool, cmUb1 []byte) {

    authInp := []byte("074487bf22e46742")
    assume auth === authInp

    // inline createScionCmnAddrHdr
    // inline MustParseIA
    ia, err := addr.ParseIA("2-ff00:0:222")
    if err != nil {
        // panic(err) // omit panic calls
    }

    spkt := &slayers.SCION{
        SrcIA:      ia,
        PayloadLen: 120,
    }
    ip4Addr := &net.IPAddr{IP: net.ParseIP("10.0.0.100")}

    inhale wildcard ==> acc(ip4Addr.Mem(), _) // inhale precondition of call with ghost parameter
    inhale !wildcard ==> acc(ip4Addr.Mem(), definitions.R18) // inhale precondition of call with ghost parameter
    _ := spkt.SetSrcAddr(ip4Addr, wildcard)

    assume s == spkt

    now := time.Now().Truncate(time.Second)
    timestampInp := uint32(now.Add(-time.Minute).Unix())

    assume timestamp == timestampInp

    epicTS, _ := CreateTimestamp(now.Add(-time.Minute), time.Now())
    pktIDInp := pathepic.PktID{
        Timestamp: epicTS,
        Counter:   PktCounterFromCore(1, 2),
    }

    assume pktID == pktIDInp

    // Use random authenticators
    authPenultimate := []byte("fcdc8202502d452e")
    authLast := []byte("f5fcc4ce2250db36")

    // Generate PHVF and LHVF
    buffer1 := []byte(nil)
    inhale acc(s.Mem(cmUb1), definitions.R20)
    inhale acc(sl.Bytes(cmUb1, 0, len(cmUb1)), definitions.R20)
    fold sl.Bytes(buffer1, 0, len(buffer1))
    fold acc(sl.Bytes(authPenultimate, 0, len(authPenultimate)), definitions.R30)
    PHVFInp, err := CalcMac(authPenultimate, pktID, s, timestamp, buffer1, cmUb1)
    assert err == nil

    assume hvf === PHVFInp

    bufferInp := make([]byte, MACBufferSize)

    assume buffer === bufferInp

    inhale acc(s.Mem(ub), definitions.R20)
    inhale acc(sl.Bytes(ub, 0, len(ub)), definitions.R20)
    fold sl.Bytes(buffer, 0, len(buffer))
    fold acc(sl.Bytes(authPenultimate, 0, len(authPenultimate)), definitions.R30)
    err = VerifyHVF(authPenultimate, pktID, s, timestamp, hvf, buffer, ub)

    assert err != nil // assertion fails
}

// NO ERROR
// doesn't verify
func TestPktCounterFromCore1() {
    coreID := uint8(0x01)
    coreCounter := uint32(0x1234)
    expected := uint32(0x01001234)

    got := PktCounterFromCore(coreID, coreCounter)
    assert got == expected
}

// NO ERROR
// doesn't verify
func TestPktCounterFromCore2() {
    coreID := uint8(0x01)
    coreCounter := uint32(0xffffffff)
    expected := uint32(0x01ffffff)

    got := PktCounterFromCore(coreID, coreCounter)
    assert got == expected
}

// NO ERROR
// doesn't verify
func TestCoreFromPktCounter() {
    pktCounter := uint32(0x12345678)
    expectedCoreID := uint8(0x12)
    expectedCoreCounter := uint32(0x345678)

    coreID, coreCounter := CoreFromPktCounter(pktCounter)
    assert expectedCoreID == coreID
    assert expectedCoreCounter == coreCounter
}
