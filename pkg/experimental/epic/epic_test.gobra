// Copyright 2021 ETH Zurich, Anapaya Systems
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package epic

import (
	"github.com/scionproto/scion/pkg/addr"
    "github.com/scionproto/scion/pkg/slayers"
    "github.com/scionproto/scion/pkg/slayers/path"
    pathepic "github.com/scionproto/scion/pkg/slayers/path/epic"
    "github.com/scionproto/scion/verification/utils/definitions" // import necessary for R18
    sl "github.com/scionproto/scion/verification/utils/slices" // import necessary for precondition about ghost parameter
    "net"
    "time"
)

// done
// Correct input
// no error case
// DOES NOT VERIFY
func TestPrepareMacInput1(pktID pathepic.PktID, s *slayers.SCION, timestamp uint32, inputBuffer []byte , ub []byte) {
    tmpPktID := pathepic.PktID{Timestamp:0x1, Counter:0x2000003}
    tmpS := &slayers.SCION{
        BaseLayer:slayers.BaseLayer{Contents:[]uint8(nil),
            Payload:[]uint8(nil)},
            Version:0x0,
            TrafficClass:0x0,
            FlowID:0x0,
            NextHdr:0x0,
            HdrLen:0x0,
            PayloadLen:0x78,
            PathType:0x0,
            DstAddrType:0x0,
            SrcAddrType:0x0,
            DstIA:0x0,
            SrcIA:0x2ff0000000222,
            RawDstAddr:[]uint8(nil),
            RawSrcAddr:[]uint8{0xa, 0x0, 0x0, 0x64},
            Path:path.Path(nil),
    }
    tmpInputBuffer := []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}

    inhale MACBufferSize <= len(inputBuffer)
    inhale acc(s.Mem(ub), definitions.R20)
    inhale acc(sl.Bytes(ub, 0, len(ub)), definitions.R20)
    inhale sl.Bytes(inputBuffer, 0, len(inputBuffer))

    assume pktID == tmpPktID
    assume s == tmpS
    assume timestamp == 0x4af9f070
    assume inputBuffer === tmpInputBuffer

    refute false

    expected := []byte{0x0, 0x4a, 0xf9, 0xf0, 0x70, 0x0, 0x0, 0x0, 0x1, 0x2, 0x0, 0x0, 0x3, 0x0, 0x2, 0xff, 0x0, 0x0, 0x0, 0x2, 0x22, 0xa, 0x0, 0x0, 0x64, 0x0, 0x78, 0x0, 0x0, 0x0, 0x0, 0x0}

	inputLength, err := prepareMacInput(pktID, s, timestamp, inputBuffer, ub) // method call

    assert err == nil // ERROR: might not hold

    got := inputBuffer[:inputLength]
    assert got === expected
}

// done
// SCION header nil
// error case
// DOES NOT VERIFY
func TestPrepareMacInput2(pktID pathepic.PktID, s *slayers.SCION, timestamp uint32, inputBuffer []byte , ub []byte) {
    tmpPktID := pathepic.PktID{Timestamp:0x1, Counter:0x2000003}
    tmpS := (*slayers.SCION)(nil)
    tmpInputBuffer := []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}

    inhale MACBufferSize <= len(inputBuffer)
    inhale acc(s.Mem(ub), definitions.R20)
    inhale acc(sl.Bytes(ub, 0, len(ub)), definitions.R20)
    inhale sl.Bytes(inputBuffer, 0, len(inputBuffer))

    assume pktID == tmpPktID
    assume s == tmpS
    assume timestamp == 0x4af9f070
    assume inputBuffer === tmpInputBuffer

    _, err := prepareMacInput(pktID, s, timestamp, inputBuffer, ub)

    assert err != nil // ERROR: might not hold
}

// done
// Timestamp way too far in the past
// error case
// DOES NOT VERIFY
func TestCreateTimestamp1(input time.Time, now time.Time, ghost p perm) {
    loc := time.Local
    inhale p > 0
    inhale acc(loc, p)
    tmpInput := time.Date(1970, time.January, 1, 1, 0, 0, 0, loc, p)
    tmpNow := time.Date(2025, time.February, 17, 7, 9, 27, 0, loc, p)

    assume input == tmpInput
    assume now == tmpNow

    expected := uint32(0)

    res, err := CreateTimestamp(input, now)

    assert err != nil
    assert res == expected // ERROR: might not hold
}

// done
// PHVF valid
// no error case
// DOES NOT VERIFY
func TestVerifyHVF1(auth []byte, pktID pathepic.PktID, s *slayers.SCION, timestamp uint32, hvf []byte, buffer []byte, ub []byte) {
    tmpAuth := []byte{0x66, 0x63, 0x64, 0x63, 0x38, 0x32, 0x30, 0x32, 0x35, 0x30, 0x32, 0x64, 0x34, 0x35, 0x32, 0x65}
    tmpPktID := pathepic.PktID{Timestamp: 0x2c1785, Counter: 0x1000002}
    tmpS := &slayers.SCION{BaseLayer: slayers.BaseLayer{Contents: []uint8(nil), Payload: []uint8(nil)}, Version: 0x0, TrafficClass: 0x0, FlowID: 0x0, NextHdr: 0x0, HdrLen: 0x0, PayloadLen: 0x78, PathType: 0x0, DstAddrType: 0x0, SrcAddrType: 0x0, DstIA: 0x0, SrcIA: 0x2ff0000000222, RawDstAddr: []uint8(nil), RawSrcAddr: []uint8{0xa, 0x0, 0x0, 0x64}, Path: path.Path(nil), pathPool: []path.Path(nil), pathPoolRaw: path.Path(nil)}
    tmpTimestamp := uint32(0x67b2d5b9)
    tmpHvf := []byte{0xac, 0x23, 0x66, 0x20}
    tmpBuffer := []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}

    assume auth === tmpAuth
    assume pktID == tmpPktID
    assume s == tmpS
    assume timestamp == tmpTimestamp
    assume hvf === tmpHvf
    assume buffer === tmpBuffer

    inhale sl.Bytes(buffer, 0, len(buffer))
    inhale acc(s.Mem(ub), definitions.R20)
    inhale acc(sl.Bytes(hvf, 0, len(hvf)), definitions.R50)
    inhale acc(sl.Bytes(ub, 0, len(ub)), definitions.R20)
    inhale acc(sl.Bytes(auth, 0, len(auth)), definitions.R30)

    refute false

    err := VerifyHVF(auth, pktID, s, timestamp, hvf, buffer, ub)

    assert err == nil // ERROR: might not hold
}

// done
// PHVF with wrong authenticator
// error case
// DOES NOT VERIFY
func TestVerifyHVF2(auth []byte, pktID pathepic.PktID, s *slayers.SCION, timestamp uint32, hvf []byte, buffer []byte, ub []byte) {
    tmpAuth := []byte{0x30, 0x37, 0x34, 0x34, 0x38, 0x37, 0x62, 0x66, 0x32, 0x32, 0x65, 0x34, 0x36, 0x37, 0x34, 0x32}
    tmpPktID := pathepic.PktID{Timestamp:0x2c16f3, Counter:0x1000002}
    tmpS := &slayers.SCION{BaseLayer:slayers.BaseLayer{Contents:[]uint8(nil), Payload:[]uint8(nil)}, Version:0x0, TrafficClass:0x0, FlowID:0x0, NextHdr:0x0, HdrLen:0x0, PayloadLen:0x78, PathType:0x0, DstAddrType:0x0, SrcAddrType:0x0, DstIA:0x0, SrcIA:0x2ff0000000222, RawDstAddr:[]uint8(nil), RawSrcAddr:[]uint8{0xa, 0x0, 0x0, 0x64}, Path:path.Path(nil), pathPool:[]path.Path(nil), pathPoolRaw:path.Path(nil)}
    tmpTimestamp := uint32(0x67b2dcf7)
    tmpHvf := []byte{0xd4, 0x30, 0xbd, 0xdc}
    tmpBuffer := []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}

    assume auth === tmpAuth
    assume pktID == tmpPktID
    assume s == tmpS
    assume timestamp == tmpTimestamp
    assume hvf === tmpHvf
    assume buffer === tmpBuffer

    inhale sl.Bytes(buffer, 0, len(buffer))
    inhale acc(s.Mem(ub), definitions.R20)
    inhale acc(sl.Bytes(hvf, 0, len(hvf)), definitions.R50)
    inhale acc(sl.Bytes(ub, 0, len(ub)), definitions.R20)
    inhale acc(sl.Bytes(auth, 0, len(auth)), definitions.R30)

    err := VerifyHVF(auth, pktID, s, timestamp, hvf, buffer, ub)

    assert err != nil // ERROR: might not hold
}

// TODO
// ERROR
// doesn't verify
func TestCreateTimestamp2(input time.Time, now time.Time) {
    nowInp := time.Now().Truncate(time.Second)
    assume now == nowInp

    // inline createTimeHMS
    tmp1 := (time.Duration(24) * time.Hour) +
        (time.Duration(64) * time.Minute) +
        (time.Duration(0) * time.Second)
    tmp2 := -tmp1
    inp := now.Add(tmp2)
    assume input == inp

    res, err := CreateTimestamp(input, now)

    assert err != nil
    assert res == 0
}

// NO ERROR
// doesn't verify
func TestCreateTimestamp3() {
    now := time.Now().Truncate(time.Second)

    // inline createTimeHMS
    tmp1 := (time.Duration(24) * time.Hour) +
        (time.Duration(63) * time.Minute) +
        (time.Duration(0) * time.Second)
    tmp2 := -tmp1
    input := now.Add(tmp2)

    // inline createTimeHMS
    tmp3 := (time.Duration(24) * time.Hour) +
        (time.Duration(63) * time.Minute) +
        (time.Duration(0) * time.Second)
    expected := tmp3 / TimestampResolution - 1

    res, err := CreateTimestamp(input, now)

    assert err == nil
    assert res == uint32(expected)
}

// ERROR
// doesn't verify
func TestVerifyTimestamp1(timestamp time.Time, epicTS uint32, now time.Time) {
    nowInp := time.Now().Truncate(time.Second)
    assume now == nowInp

    timestampInp := now.Add(-time.Minute)
    assume timestamp == timestampInp

    assume epicTS == 0

    err := VerifyTimestamp(timestamp, epicTS, now)

    assert err != nil
}

// ERROR
// doesn't verify
func TestVerifyTimestamp2(timestamp time.Time, epicTS uint32, now time.Time) {
    nowInp := time.Now().Truncate(time.Second)
    assume now == nowInp

    timestampInp := now.Add(-time.Minute)
    assume timestamp == timestampInp

    epicTSInp, err := CreateTimestamp(timestampInp, now)
    csAndPl := uint32(((MaxClockSkew + MaxPacketLifetime) / 21).Microseconds())

    assume epicTS == epicTSInp - csAndPl

    err := VerifyTimestamp(timestamp, epicTS, now)

    assert err != nil
}

// NO ERROR
// doesn't verify
func TestVerifyTimestamp3() {
    now := time.Now().Truncate(time.Second)
    timestamp := now.Add(-time.Minute)

    epicTSInp, err := CreateTimestamp(timestamp, now)
    csAndPl := uint32(((MaxClockSkew + MaxPacketLifetime) / 21).Microseconds())

    epicTS := epicTSInp - csAndPl + 1

    err := VerifyTimestamp(timestamp, epicTS, now)

    assert err == nil
}

// NO ERROR
// doesn't verify
func TestPktCounterFromCore1() {
    coreID := uint8(0x01)
    coreCounter := uint32(0x1234)
    expected := uint32(0x01001234)

    got := PktCounterFromCore(coreID, coreCounter)
    assert got == expected
}

// NO ERROR
// doesn't verify
func TestPktCounterFromCore2() {
    coreID := uint8(0x01)
    coreCounter := uint32(0xffffffff)
    expected := uint32(0x01ffffff)

    got := PktCounterFromCore(coreID, coreCounter)
    assert got == expected
}

// NO ERROR
// doesn't verify
func TestCoreFromPktCounter() {
    pktCounter := uint32(0x12345678)
    expectedCoreID := uint8(0x12)
    expectedCoreCounter := uint32(0x345678)

    coreID, coreCounter := CoreFromPktCounter(pktCounter)
    assert expectedCoreID == coreID
    assert expectedCoreCounter == coreCounter
}
