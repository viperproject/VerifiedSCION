// Copyright 2020 Anapaya Systems
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package onehop

import (
    "github.com/scionproto/scion/pkg/slayers/path"
    "github.com/scionproto/scion/pkg/slayers/path/scion"
    "github.com/scionproto/scion/verification/utils/definitions"
    sl "github.com/scionproto/scion/verification/utils/slices"
)

// done
// no error case
// DOES NOT VERIFY
func TestSerializeDecode(o1 *Path, b []byte, ubuf []byte, o2 *Path, data []byte) {
    tmpO1 := &Path{
        Info: path.InfoField{
            Peer:      false,
            ConsDir:   true,
            SegID:     0x222,
            Timestamp: 0x100},
        FirstHop: path.HopField{
            IngressRouterAlert: true,
            EgressRouterAlert:  true,
            ExpTime:            0x3f,
            ConsIngress:        0x0,
            ConsEgress:         0x1,
            Mac:                [6]byte{0x1, 0x2, 0x3, 0x4, 0x5, 0x6}},
        SecondHop: path.HopField{
            IngressRouterAlert: true,
            EgressRouterAlert:  true,
            ExpTime:            0x3f,
            ConsIngress:        0x2,
            ConsEgress:         0x0,
            Mac:                [6]byte{0x1, 0x2, 0x3, 0x4, 0x5, 0x6}},
    }
    tmpB := []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}

    tmpO2 := &Path{
        Info: path.InfoField{
            Peer:      false,
            ConsDir:   false,
            SegID:     0x0,
            Timestamp: 0x0},
        FirstHop: path.HopField{
            IngressRouterAlert: false,
            EgressRouterAlert:  false,
            ExpTime:            0x0,
            ConsIngress:        0x0,
            ConsEgress:         0x0,
            Mac:                [6]byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0}},
        SecondHop: path.HopField{
            IngressRouterAlert: false,
            EgressRouterAlert:  false,
            ExpTime:            0x0,
            ConsIngress:        0x0,
            ConsEgress:         0x0,
            Mac:                [6]byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0}},
    }

    inhale acc(o1.Mem(ubuf), definitions.R1)
    inhale acc(sl.Bytes(ubuf, 0, len(ubuf)), definitions.R1)
    inhale sl.Bytes(b, 0, len(b))

    assume o1 == tmpO1
    assume b === tmpB

    refute false

    err := o1.SerializeTo(b, ubuf)

    assert err == nil // passes

    inhale o2.NonInitMem()

    assume o2 == tmpO2

    refute false

    err := o2.DecodeFromBytes(b)

    assert err == nil       // passes
    assert *o1 == *o2 // ERROR: might not hold
}

// done
// complete path converts correctly
// no error case
// DOES NOT VERIFY
func TestPathToSCIONDecoded1(o *Path, ubuf []byte) {
    tmpO := &Path{
        Info: path.InfoField{
            Peer:      false,
            ConsDir:   true,
            SegID:     0x222,
            Timestamp: 0x100},
        FirstHop: path.HopField{
            IngressRouterAlert: true,
            EgressRouterAlert:  true,
            ExpTime:            0x3f,
            ConsIngress:        0x0,
            ConsEgress:         0x1,
            Mac:                [6]byte{0x1, 0x2, 0x3, 0x4, 0x5, 0x6},
        },
        SecondHop: path.HopField{
            IngressRouterAlert: true,
            EgressRouterAlert:  true,
            ExpTime:            0x3f,
            ConsIngress:        0x2,
            ConsEgress:         0x0,
            Mac:                [6]byte{0x1, 0x2, 0x3, 0x4, 0x5, 0x6},
        },
    }

    assume o == tmpO

    inhale o.Mem(ubuf)
    inhale sl.Bytes(ubuf, 0, len(ubuf))

    sp, err := o.ToSCIONDecoded(ubuf)

    expected := &scion.Decoded{
        Base: scion.Base{
            PathMeta: scion.MetaHdr{CurrINF: 0x0, CurrHF: 0x0, SegLen: [3]uint8{0x2, 0x0, 0x0}},
            NumINF:   1,
            NumHops:  2},
        InfoFields: []path.InfoField{
            path.InfoField{Peer: false, ConsDir: true, SegID: 0x222, Timestamp: 0x100},
        },
        HopFields: []path.HopField{
            path.HopField{IngressRouterAlert: true, EgressRouterAlert: true, ExpTime: 0x3f, ConsIngress: 0x0, ConsEgress: 0x1, Mac: [6]byte{0x1, 0x2, 0x3, 0x4, 0x5, 0x6}},
            path.HopField{IngressRouterAlert: true, EgressRouterAlert: true, ExpTime: 0x3f, ConsIngress: 0x2, ConsEgress: 0x0, Mac: [6]byte{0x1, 0x2, 0x3, 0x4, 0x5, 0x6}},
        },
    }

    assert err == nil
    assert sp == expected // ERROR: might not hold
}

// done
// incomplete path
// error case
// DOES NOT VERIFY
func TestPathToSCIONDecoded2(o *Path, ubuf []byte) {
    tmpO := &Path{
        Info: path.InfoField{Peer: false, ConsDir: true, SegID: 0x222, Timestamp: 0x100},
        FirstHop: path.HopField{
            IngressRouterAlert: true,
            EgressRouterAlert:  true,
            ExpTime:            0x3f,
            ConsIngress:        0x0,
            ConsEgress:         0x1,
            Mac:                [6]byte{0x1, 0x2, 0x3, 0x4, 0x5, 0x6},
        },
        SecondHop: path.HopField{
            IngressRouterAlert: false,
            EgressRouterAlert:  false,
            ExpTime:            0x0,
            ConsIngress:        0x0,
            ConsEgress:         0x0,
            Mac:                [6]byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
        },
    }

    assume o == tmpO

    inhale o.Mem(ubuf)
    inhale sl.Bytes(ubuf, 0, len(ubuf))

    sp, err := o.ToSCIONDecoded(ubuf)

    assert err != nil // ERROR: might not hold
    assert sp == nil
}
