package epic

import (
	"github.com/scionproto/scion/pkg/slayers/path/scion"
	// @ . "github.com/scionproto/scion/verification/utils/definitions"
	// @ sl "github.com/scionproto/scion/verification/utils/slices"
	"fmt"
	"github.com/scionproto/scion/assertion"
)

func TestReverse_Basic_reverse(p_Path_Reverse *Path) {
	var tmp_p_Path_Reverse *Path
	tmp_p_Path_Reverse = &Path{PktID: PktID{Timestamp: 1, Counter: 33554435}, PHVF: []uint8{0x1, 0x2, 0x3, 0x4}, LHVF: []uint8{0x5, 0x6, 0x7, 0x8}, ScionPath: &scion.Raw{Base: scion.Base{PathMeta: scion.MetaHdr{CurrINF: 0, CurrHF: 0, SegLen: [3]uint8{0x2, 0x2, 0x0}}, NumINF: 2, NumHops: 4}, Raw: []uint8{0x0, 0x0, 0x20, 0x80, 0x0, 0x0, 0x1, 0x11, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x2, 0x22, 0x0, 0x0, 0x1, 0x0, 0x0, 0x3f, 0x0, 0x1, 0x0, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x0, 0x3f, 0x0, 0x3, 0x0, 0x2, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x0, 0x3f, 0x0, 0x0, 0x0, 0x2, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x0, 0x3f, 0x0, 0x1, 0x0, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6}}}
	// @ inhale p_Path_Reverse.Mem(ubuf)
	// @ inhale sl.Bytes(ubuf, 0, len(ubuf))
	// @ exhale acc(tmp_p_Path_Reverse)
	// @ assume p_Path_Reverse == tmp_p_Path_Reverse
	// @ refute false
	ret, err := p_Path_Reverse.Reverse()
	// @ ass0_Path_Reverse := err == nil
	// @ assert ass0_Path_Reverse
	// @ ass1_Path_Reverse := &Path{PktID:PktID{Timestamp:0x1, Counter:0x2000003}, PHVF:[]uint8{0x1, 0x2, 0x3, 0x4}, LHVF:[]uint8{0x5, 0x6, 0x7, 0x8}, ScionPath:(*scion.Raw)(0xc00001f770)} == ret
	// @ assert ass1_Path_Reverse
}
func TestReverse_Reverse_a_reversed_path(p_Path_Reverse *Path) {
	var tmp_p_Path_Reverse *Path
	tmp_p_Path_Reverse = &Path{PktID: PktID{Timestamp: 1, Counter: 33554435}, PHVF: []uint8{0x1, 0x2, 0x3, 0x4}, LHVF: []uint8{0x5, 0x6, 0x7, 0x8}, ScionPath: &scion.Raw{Base: scion.Base{PathMeta: scion.MetaHdr{CurrINF: 1, CurrHF: 3, SegLen: [3]uint8{0x2, 0x2, 0x0}}, NumINF: 2, NumHops: 4}, Raw: []uint8{0x43, 0x0, 0x20, 0x80, 0x0, 0x0, 0x2, 0x22, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x11, 0x0, 0x0, 0x1, 0x0, 0x0, 0x3f, 0x0, 0x1, 0x0, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x0, 0x3f, 0x0, 0x0, 0x0, 0x2, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x0, 0x3f, 0x0, 0x3, 0x0, 0x2, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x0, 0x3f, 0x0, 0x1, 0x0, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6}}}
	// @ inhale p_Path_Reverse.Mem(ubuf)
	// @ inhale sl.Bytes(ubuf, 0, len(ubuf))
	// @ exhale acc(tmp_p_Path_Reverse)
	// @ assume p_Path_Reverse == tmp_p_Path_Reverse
	// @ refute false
	ret, err := p_Path_Reverse.Reverse()
	// @ ass0_Path_Reverse := err == nil
	// @ assert ass0_Path_Reverse
	// @ ass1_Path_Reverse := &Path{PktID:PktID{Timestamp:0x1, Counter:0x2000003}, PHVF:[]uint8{0x1, 0x2, 0x3, 0x4}, LHVF:[]uint8{0x5, 0x6, 0x7, 0x8}, ScionPath:(*scion.Raw)(0xc00001f7d0)} == ret
	// @ assert ass1_Path_Reverse
}
