// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package scion

pred (b *Base) NonInitMem() {
	acc(b)
}

// This predicate is established right after DecodeFromBytes.
// Because this method does not perform any bounds checks, it
// is not possible to have assertions in this invariant about
// how the fileds of Base compare to those of its MetaHdr field.
pred (b *Base) Mem() {
	acc(&b.NumINF) &&
	acc(&b.NumHops) &&
	acc(&b.PathMeta.CurrINF) &&
	acc(&b.PathMeta.CurrHF) &&
	acc(&b.PathMeta.SegLen[0]) &&
	acc(&b.PathMeta.SegLen[1]) &&
	acc(&b.PathMeta.SegLen[2]) &&
	// 3 is the value of MaxINFs and 64 is the number of MaxHops.
	0 <= b.NumINF && b.NumINF <= MaxINFs &&
	// the Code defines 64 as the maximum number of hops,
	// but this does not seem to be enforced anywhere.
	0 <= b.NumHops && // && b.NumHops <= MaxHops &&
	(0 < b.NumINF ==> 0 < b.NumHops)
}

ghost
decreases
pure func (b Base) ValidCurrInfSpec() bool {
	return 0 <= b.PathMeta.CurrINF && b.PathMeta.CurrINF < b.NumINF
}

ghost
decreases
pure func (b Base) ValidCurrHfSpec() bool {
	return 0 <= b.PathMeta.CurrHF && b.PathMeta.CurrHF < b.NumHops
}

ghost
decreases
pure func (b Base) ValidCurrIdxsSpec() bool {
	return b.ValidCurrHfSpec() &&
		b.ValidCurrInfSpec() &&
		0 <= b.PathMeta.SegLen[0] &&
		0 <= b.PathMeta.SegLen[1] &&
		0 <= b.PathMeta.SegLen[2] &&
		(b.NumINF == 1 ==> b.NumHops == int(b.PathMeta.SegLen[0])) &&
		(b.NumINF == 2 ==> b.NumHops == int(b.PathMeta.SegLen[0] + b.PathMeta.SegLen[1])) &&
		(b.NumINF == 3 ==> b.NumHops == int(b.PathMeta.SegLen[0] + b.PathMeta.SegLen[1] + b.PathMeta.SegLen[2])) &&
		b.PathMeta.CurrINF == b.InfForHfSpec(b.PathMeta.CurrHF)
}

ghost
requires acc(b.Mem(), _)
decreases
pure func (b *Base) ValidCurrINF() bool {
	return unfolding acc(b.Mem(), _) in (*b).ValidCurrInfSpec()
}

ghost
requires acc(b.Mem(), _)
decreases
pure func (b *Base) ValidCurrHF() bool {
	return unfolding acc(b.Mem(), _) in (*b).ValidCurrHfSpec()
}

ghost
requires acc(b.Mem(), _)
decreases
pure func (b *Base) ValidCurrIdxs() bool {
	return unfolding acc(b.Mem(), _) in (*b).ValidCurrIdxsSpec()
}

ghost
requires acc(b.Mem(), _)
ensures  0 <= res && res <= 3
decreases
pure func (b *Base) GetNumINF() (res int) {
	return unfolding acc(b.Mem(), _) in b.NumINF
}

ghost
requires acc(b.Mem(), _)
ensures  0 <= res
decreases
pure func (b *Base) GetNumHops() (res int) {
	return unfolding acc(b.Mem(), _) in b.NumHops
}

ghost
requires acc(s.Mem(), _)
decreases
pure func (s *Base) GetMetaHdr() MetaHdr {
	return unfolding acc(s.Mem(), _) in s.PathMeta
}

ghost
requires acc(s.Mem(), _)
decreases
pure func (s *Base) GetCurrHF() uint8 {
	return s.GetMetaHdr().CurrHF
}

ghost
ensures  0 <= r && r < 3
decreases
pure func (s Base) InfForHfSpec(hf uint8) (r uint8) {
	return hf < s.PathMeta.SegLen[0] ?
		0 :
		(hf < s.PathMeta.SegLen[0] + s.PathMeta.SegLen[1] ? 1 : 2)
}

ghost
requires acc(s.Mem(), _)
decreases
pure func (s *Base) IsXoverSpec() bool {
	return unfolding acc(s.Mem(), _) in (
		s.PathMeta.CurrHF+1 < uint8(s.NumHops) &&
		s.PathMeta.CurrINF != s.InfForHfSpec(s.PathMeta.CurrHF+1))
}

ghost
requires s.NumINF != 0
requires int(s.PathMeta.CurrHF) < s.NumHops-1
ensures  s.ValidCurrIdxsSpec() ==> res.ValidCurrIdxsSpec()
decreases
pure func (s Base) IncPathSpec() (res Base) {
	return Base{
		PathMeta: MetaHdr{s.InfForHfSpec(s.PathMeta.CurrHF+1), s.PathMeta.CurrHF+1, s.PathMeta.SegLen},
		NumINF: s.NumINF,
		NumHops: s.NumHops,
	}
}

ghost
requires b.Mem()
ensures  b.NonInitMem()
decreases
func (b *Base) DowngradePerm() {
	unfold b.Mem()
	fold b.NonInitMem()
}