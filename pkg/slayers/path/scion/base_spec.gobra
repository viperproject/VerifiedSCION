// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package scion

import (
	"encoding/binary"
	"github.com/scionproto/scion/pkg/slayers/path"
	sl "github.com/scionproto/scion/verification/utils/slices"

	. "github.com/scionproto/scion/verification/utils/definitions"
)

pred (b *Base) NonInitMem() {
	acc(b)
}

// This predicate is established right after DecodeFromBytes.
// Because this method does not perform any bounds checks, it
// is not possible to have assertions in this invariant about
// how the fileds of Base compare to those of its MetaHdr field.
pred (b *Base) Mem() {
	acc(&b.NumINF) &&
	acc(&b.NumHops) &&
	acc(&b.PathMeta.CurrINF) &&
	acc(&b.PathMeta.CurrHF) &&
	acc(&b.PathMeta.SegLen[0]) &&
	acc(&b.PathMeta.SegLen[1]) &&
	acc(&b.PathMeta.SegLen[2]) &&
	0 <= b.NumINF  && b.NumINF <= MaxINFs  &&
	0 <= b.NumHops && b.NumHops <= MaxHops &&
	(0 < b.NumINF ==> 0 < b.NumHops)
}

ghost
decreases
pure func (b Base) ValidCurrInfSpec() bool {
	return 0 <= b.PathMeta.CurrINF && b.PathMeta.CurrINF < b.NumINF
}

ghost
decreases
pure func (b Base) ValidCurrHfSpec() bool {
	return 0 <= b.PathMeta.CurrHF && b.PathMeta.CurrHF < b.NumHops
}

ghost
decreases
pure func (b Base) ValidCurrIdxsSpec() bool {
	return 0 <= b.NumINF && b.NumINF <= MaxINFs &&
		0 <= b.NumHops && b.NumHops <= MaxHops  &&
		b.ValidCurrHfSpec()  &&
		b.ValidCurrInfSpec() &&
		0 <= b.PathMeta.SegLen[0] && b.PathMeta.SegLen[0] < MaxHops &&
		0 <= b.PathMeta.SegLen[1] && b.PathMeta.SegLen[1] < MaxHops &&
		0 <= b.PathMeta.SegLen[2] && b.PathMeta.SegLen[2] < MaxHops &&
		(b.NumINF == 1 ==> b.NumHops == int(b.PathMeta.SegLen[0]))  &&
		(b.NumINF == 2 ==> b.NumHops == int(b.PathMeta.SegLen[0] + b.PathMeta.SegLen[1])) &&
		(b.NumINF == 3 ==> b.NumHops == int(b.PathMeta.SegLen[0] + b.PathMeta.SegLen[1] + b.PathMeta.SegLen[2])) &&
		(forall i int :: { b.PathMeta.SegLen[i] } 0 <= i && i < b.NumINF ==>
			b.PathMeta.SegLen[i] != 0) &&
		(forall i int :: { b.PathMeta.SegLen[i] } b.NumINF <= i && i < MaxINFs ==>
			b.PathMeta.SegLen[i] == 0)
}

ghost
decreases
pure func (b Base) CurrInfMatchesCurrHF() bool {
	return b.PathMeta.CurrINF == b.InfForHfSpec(b.PathMeta.CurrHF)
}

ghost
decreases
pure func (b Base) InfsMatchHfsSpec() bool {
	return 0 <= b.NumINF && b.NumINF <= 3 &&
		(b.NumINF == 1 ==> b.NumHops == int(b.PathMeta.SegLen[0]))  &&
		(b.NumINF == 2 ==> b.NumHops == int(b.PathMeta.SegLen[0] + b.PathMeta.SegLen[1])) &&
		(b.NumINF == 3 ==> b.NumHops == int(b.PathMeta.SegLen[0] + b.PathMeta.SegLen[1] + b.PathMeta.SegLen[2])) &&
		(forall i int :: { b.PathMeta.SegLen[i] } 0 <= i && i < b.NumINF ==>
			b.PathMeta.SegLen[i] != 0) &&
		(forall i int :: { b.PathMeta.SegLen[i] } b.NumINF <= i && i < MaxINFs ==>
			b.PathMeta.SegLen[i] == 0)
}

ghost
requires acc(b.Mem(), _)
decreases
pure func (b *Base) ValidCurrINF() bool {
	return unfolding acc(b.Mem(), _) in (*b).ValidCurrInfSpec()
}

ghost
requires acc(b.Mem(), _)
decreases
pure func (b *Base) ValidCurrHF() bool {
	return unfolding acc(b.Mem(), _) in (*b).ValidCurrHfSpec()
}

ghost
requires acc(b.Mem(), _)
decreases
pure func (b *Base) ValidCurrIdxs() bool {
	return unfolding acc(b.Mem(), _) in (*b).ValidCurrIdxsSpec()
}

ghost
requires acc(b.Mem(), _)
decreases
pure func (b *Base) InfsMatchHfs() bool {
	return unfolding acc(b.Mem(), _) in (*b).InfsMatchHfsSpec()
}

ghost
requires acc(b.Mem(), _)
ensures  0 <= res && res <= 3
decreases
pure func (b *Base) GetNumINF() (res int) {
	return unfolding acc(b.Mem(), _) in b.NumINF
}

ghost
requires acc(b.Mem(), _)
ensures  0 <= res
decreases
pure func (b *Base) GetNumHops() (res int) {
	return unfolding acc(b.Mem(), _) in b.NumHops
}

ghost
requires acc(s.Mem(), _)
decreases
pure func (s *Base) GetMetaHdr() MetaHdr {
	return unfolding acc(s.Mem(), _) in s.PathMeta
}

ghost
requires acc(s.Mem(), _)
decreases
pure func (s *Base) GetBase() Base {
	return unfolding acc(s.Mem(), _) in *s
}

ghost
requires acc(s.Mem(), _)
decreases
pure func (s *Base) GetCurrHF() uint8 {
	return s.GetMetaHdr().CurrHF
}

ghost
ensures  0 <= r && r < 3
decreases
pure func (s Base) InfForHfSpec(hf uint8) (r uint8) {
	return hf < s.PathMeta.SegLen[0] ?
		0 :
		(hf < s.PathMeta.SegLen[0] + s.PathMeta.SegLen[1] ? 1 : 2)
}

ghost
requires acc(s.Mem(), _)
decreases
pure func (s *Base) IsXoverSpec() bool {
	return unfolding acc(s.Mem(), _) in (
		s.PathMeta.CurrHF+1 < uint8(s.NumHops) &&
		s.PathMeta.CurrINF != s.InfForHfSpec(s.PathMeta.CurrHF+1))
}

ghost
requires s.NumINF != 0
requires int(s.PathMeta.CurrHF) < s.NumHops-1
ensures  s.ValidCurrIdxsSpec() ==> res.ValidCurrIdxsSpec()
decreases
pure func (s Base) IncPathSpec() (res Base) {
	return Base{
		PathMeta: MetaHdr{s.InfForHfSpec(s.PathMeta.CurrHF+1), s.PathMeta.CurrHF+1, s.PathMeta.SegLen},
		NumINF: s.NumINF,
		NumHops: s.NumHops,
	}
}

/*************** AbsBase ***************/

// There is a good deal of repition in this section of the file and the similarly
// named functions for the type `Base`. While for now this is not too big of a problem,
// we should find ways to streamline the definitions, ideally by having these defs only
// for the abstraction type only.

type AbsBase adt {
	AbsBase_ {
		PathMeta AbsMetaHdr
		NumINF int
		NumHops int
	}
}

type AbsMetaHdr adt {
	AbsMetaHdr_ {
		// we should change the types of CurrINF and CurrHF to wider types,
		// otherwise we might start getting overflow errors here when they
		// are fully enabled.
		CurrINF uint8
		CurrHF  uint8
		SegLen  seq[uint8]
	}
}

ghost
decreases
pure func (b Base) Abs() AbsBase {
	return AbsBase_{
		PathMeta: b.PathMeta.Abs(),
		NumINF: b.NumINF,
		NumHops: b.NumHops,
	}
}

ghost
decreases
pure func (b MetaHdr) Abs() AbsMetaHdr {
	return AbsMetaHdr_{
		CurrINF: b.CurrINF,
		CurrHF: b.CurrHF,
		SegLen: seq[uint8]{ b.SegLen[0], b.SegLen[1], b.SegLen[2] },
	}
}

ghost
requires len(b.PathMeta.SegLen) == 3
decreases
pure func (b AbsBase) ReverseSpec() AbsBase {
	return AbsBase_ {
		PathMeta: b.ReverseMetaHdrSpec(),
		NumINF: b.NumINF,
		NumHops: b.NumHops,
	}
}

ghost
requires len(b.PathMeta.SegLen) == 3
decreases
pure func (b AbsBase) ReverseMetaHdrSpec() AbsMetaHdr {
	return AbsMetaHdr_ {
		CurrINF: uint8(b.NumINF) - b.PathMeta.CurrINF - 1,
		CurrHF: uint8(b.NumHops) - b.PathMeta.CurrHF - 1,
		SegLen: b.ReverseSegLen(),
	}
}

ghost
requires len(b.PathMeta.SegLen) == 3
decreases
pure func (b AbsBase) ReverseSegLen() seq[uint8] {
	return (match b.NumINF {
		case 2: seq[uint8]{ b.PathMeta.SegLen[1], b.PathMeta.SegLen[0], b.PathMeta.SegLen[2]}
		case 3: seq[uint8]{ b.PathMeta.SegLen[2], b.PathMeta.SegLen[1], b.PathMeta.SegLen[0] }
		default: b.PathMeta.SegLen
	})
}

ghost
decreases
pure func (b AbsBase) ValidCurrIdxsSpec() bool {
	return 0 <= b.NumINF && b.NumINF <= MaxINFs &&
		len(b.PathMeta.SegLen) == 3             &&
		0 <= b.NumHops && b.NumHops <= MaxHops  &&
		b.ValidCurrHfSpec()  &&
		b.ValidCurrInfSpec() &&
		0 <= b.PathMeta.SegLen[0] && b.PathMeta.SegLen[0] < MaxHops &&
		0 <= b.PathMeta.SegLen[1] && b.PathMeta.SegLen[1] < MaxHops &&
		0 <= b.PathMeta.SegLen[2] && b.PathMeta.SegLen[2] < MaxHops &&
		(b.NumINF == 1 ==> b.NumHops == int(b.PathMeta.SegLen[0]))  &&
		(b.NumINF == 2 ==> b.NumHops == int(b.PathMeta.SegLen[0] + b.PathMeta.SegLen[1])) &&
		(b.NumINF == 3 ==> b.NumHops == int(b.PathMeta.SegLen[0] + b.PathMeta.SegLen[1] + b.PathMeta.SegLen[2])) &&
		(forall i int :: { b.PathMeta.SegLen[i] } 0 <= i && i < b.NumINF ==>
			b.PathMeta.SegLen[i] != 0) &&
		(forall i int :: { b.PathMeta.SegLen[i] } b.NumINF <= i && i < MaxINFs ==>
			b.PathMeta.SegLen[i] == 0)
}

ghost
opaque
requires b.ValidCurrIdxsSpec()
decreases
pure func (b AbsBase) CurrInfMatchesCurrHF() bool {
	return b.PathMeta.CurrINF == b.InfForHfSpec(b.PathMeta.CurrHF)
}

ghost
decreases
pure func (b AbsBase) ValidCurrInfSpec() bool {
	return 0 <= b.PathMeta.CurrINF && b.PathMeta.CurrINF < b.NumINF
}

ghost
decreases
pure func (b AbsBase) ValidCurrHfSpec() bool {
	return 0 <= b.PathMeta.CurrHF && b.PathMeta.CurrHF < b.NumHops
}

ghost
requires len(s.PathMeta.SegLen) == 3
ensures  0 <= r && r < 3
decreases
pure func (s AbsBase) InfForHfSpec(hf uint8) (r uint8) {
	return hf < s.PathMeta.SegLen[0] ?
		0 :
		(hf < s.PathMeta.SegLen[0] + s.PathMeta.SegLen[1] ? 1 : 2)
}

ghost
requires b.ValidCurrIdxsSpec()
ensures  b.ReverseSpec().ValidCurrIdxsSpec()
decreases
pure func (b AbsBase) ReversingValidBaseIsValidBase() Lemma {
	return Lemma{}
}

ghost
ensures b.ValidCurrIdxsSpec() == b.Abs().ValidCurrIdxsSpec()
decreases
pure func (b Base) ValidBaseHasValidAbs() Lemma {
	return Lemma{}
}

/*************** End of AbsBase ***************/

ghost
requires b.Mem()
ensures  b.NonInitMem()
decreases
func (b *Base) DowngradePerm() {
	unfold b.Mem()
	fold b.NonInitMem()
}

ghost
decreases
pure func DecodedFrom(line uint32) MetaHdr {
	return MetaHdr {
		CurrINF: uint8(line >> 30),
		CurrHF: uint8(line>>24) & 0x3F,
		SegLen: [3]uint8{uint8(line>>12) & 0x3F, uint8(line>>6) & 0x3F, uint8(line) & 0x3F},
	}
}

ghost
requires acc(sl.AbsSlice_Bytes(b, 0, len(b)), _)
decreases
pure func (m MetaHdr) DecodeFromBytesSpec(b []byte) bool {
	return MetaLen <= len(b)             &&
		0 <= m.CurrINF && m.CurrINF <= 3 &&
		0 <= m.CurrHF  && m.CurrHF < 64  &&
		m.SegsInBounds() &&
		let lenR := len(b) in
		let b0 := sl.GetByte(b, 0, lenR, 0) in
		let b1 := sl.GetByte(b, 0, lenR, 1) in
		let b2 := sl.GetByte(b, 0, lenR, 2) in
		let b3 := sl.GetByte(b, 0, lenR, 3) in
		let line := binary.BigEndian.Uint32Spec(b0, b1, b2, b3) in
		DecodedFrom(line) == m
}

ghost
requires acc(s.Mem(), _)
requires acc(sl.AbsSlice_Bytes(b, 0, len(b)), _)
decreases
pure func (s *Base) DecodeFromBytesSpec(b []byte) bool {
	return unfolding acc(s.Mem(), _) in
		s.PathMeta.DecodeFromBytesSpec(b)
}

ghost
decreases
pure func (m MetaHdr) SegsInBounds() bool {
	return 0 <= m.SegLen[0] && m.SegLen[0] <= 63 &&
		0 <= m.SegLen[1] && m.SegLen[1] <= 63    &&
		0 <= m.SegLen[2] && m.SegLen[2] <= 63
}

ghost
decreases
pure func (m MetaHdr) SerializedToLine() uint32 {
	return uint32(m.CurrINF)<<30 |
		uint32(m.CurrHF&0x3F)<<24 |
		uint32(m.SegLen[0]&0x3F) << 12 |
		uint32(m.SegLen[1]&0x3F) << 6 |
		uint32(m.SegLen[2] & 0x3F)
}

ghost
requires acc(sl.AbsSlice_Bytes(b, 0, len(b)), _)
decreases
pure func (m MetaHdr) SerializeToSpec(b []byte) bool {
	return MetaLen <= len(b)                &&
		let lenR := len(b)                  in
		let b0 := sl.GetByte(b, 0, lenR, 0) in
		let b1 := sl.GetByte(b, 0, lenR, 1) in
		let b2 := sl.GetByte(b, 0, lenR, 2) in
		let b3 := sl.GetByte(b, 0, lenR, 3) in
		let v  := m.SerializedToLine()      in
		binary.BigEndian.PutUint32Spec(b0, b1, b2, b3, v)
}

ghost
decreases
pure func (m MetaHdr) InBounds() bool {
	return 0 <= m.CurrINF && m.CurrINF <= 3   &&
		0 <= m.CurrHF && m.CurrHF <= 63       &&
		0 <= m.SegLen[0] && m.SegLen[0] <= 63 &&
		0 <= m.SegLen[1] && m.SegLen[1] <= 63 &&
		0 <= m.SegLen[2] && m.SegLen[2] <= 63
}

ghost
requires acc(sl.AbsSlice_Bytes(ub, 0, len(ub)), R56)
decreases
pure func (s Base) EqAbsHeader(ub []byte) bool {
	// we compute the sublice ub[:MetaLen] inside this function instead
	// of expecting the correct subslice to be passed, otherwise this function
	// becomes too cumbersome to use in calls from (*Raw).EqAbsHeader due to the
	// lack of a folding expression. Same goes for MetaHdr.EqAbsHeader.
	return MetaLen <= len(ub) &&
		s == RawBytesToBase(ub)
}

ghost
requires acc(sl.AbsSlice_Bytes(ub, 0, len(ub)), _)
decreases
pure func (s MetaHdr) EqAbsHeader(ub []byte) bool {
	return MetaLen <= len(ub) &&
		unfolding acc(sl.AbsSlice_Bytes(ub, 0, len(ub)), _) in
		s == DecodedFrom(binary.BigEndian.Uint32(ub[:MetaLen]))
}

ghost
opaque
requires MetaLen <= idx && idx <= len(ub)
requires acc(sl.AbsSlice_Bytes(ub, 0, len(ub)), R55)
requires acc(sl.AbsSlice_Bytes(ub[:idx], 0, idx), R55)
ensures  s.EqAbsHeader(ub) == s.EqAbsHeader(ub[:idx])
decreases
pure func (s MetaHdr) EqAbsHeaderForSublice(ub []byte, idx int) Lemma {
	return let _ := Asserting(ub[:MetaLen] === ub[:idx][:MetaLen]) in
		unfolding acc(sl.AbsSlice_Bytes(ub, 0, len(ub)), R56) in
		unfolding acc(sl.AbsSlice_Bytes(ub[:idx], 0, idx), R56) in
		let _ := Asserting(s.EqAbsHeader(ub) == (s == DecodedFrom(binary.BigEndian.Uint32(ub[:MetaLen])))) in
		Lemma{}
}

/** Lemma proven in /VerifiedSCION/verification/utils/bitwise/proofs.dfy **/
ghost
requires m.InBounds()
ensures  let line1 := m.SerializedToLine() in
	binary.BigEndian.PutUint32Spec(b0, b1, b2, b3, line1) ==>
		let line2 := binary.BigEndian.Uint32Spec(b0, b1, b2, b3) in DecodedFrom(line2) == m
decreases
func (m MetaHdr) SerializeAndDeserializeLemma(b0, b1, b2, b3 byte)