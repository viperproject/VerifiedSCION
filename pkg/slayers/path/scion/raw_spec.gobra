// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package scion

import (
	"github.com/scionproto/scion/pkg/slayers/path"
	. "verification/utils/definitions"
	sl "verification/utils/slices"
	"verification/dependencies/encoding/binary"
	"verification/io"
)

/**** Predicates ****/
pred (s *Raw) NonInitMem() {
	acc(&s.Raw) &&
	s.Base.NonInitMem()
}

pred (s *Raw) Mem(buf []byte) {
	s.Base.Mem() &&
	acc(&s.Raw) &&
	len(s.Raw) <= len(buf) &&
	s.Raw === buf[:len(s.Raw)] &&
	len(s.Raw) == s.Base.Len()
}
/**** End of Predicates ****/

(*Raw) implements path.Path

ghost
pure
requires  acc(s.Mem(buf), _)
requires  acc(sl.Bytes(buf, 0, len(buf)), R42)
decreases
func (s *Raw) IsValidResultOfDecoding(buf []byte, err error) (res bool) {
	return s.EqAbsHeader(buf) &&
		s.InfsMatchHfs(buf) && s.SegsInBounds(buf)
}

/**** Stubs ****/
/**
  * This method is not part of the original SCION codebase.
  * Instead, `Len` was defined in `*Raw` via embedded structs.
  * Unfortunately, Gobra does not fully support them yet, so we
  * introduced this wrapper method which acts as a wrapper.
  */
pure
requires acc(s.Mem(buf), _)
ensures  unfolding acc(s.Mem(buf), _) in t == s.Base.Type()
decreases
func (s *Raw) Type(ghost buf []byte) (t path.Type) {
	return unfolding acc(s.Mem(buf), _) in s.Base.Type()
}

/**
  * This method is not part of the original SCION codebase.
  * Instead, `Len` was defined in `*Raw` via embedded structs.
  * Unfortunately, Gobra does not fully support them yet, so we
  * introduced this wrapper method which acts as a wrapper.
  */
preserves acc(s.Mem(buf), R50)
ensures   l == s.LenSpec(buf)
decreases
func (s *Raw) Len(ghost buf []byte) (l int) {
	return unfolding acc(s.Mem(buf), _) in s.Base.Len()
}

ghost
pure
requires acc(s.Mem(ub), _)
ensures  unfolding acc(s.Mem(ub), _) in l == s.Base.Len()
decreases
func (s *Raw) LenSpec(ghost ub []byte) (l int) {
	return unfolding acc(s.Mem(ub), _) in s.Base.Len()
}

/**
  * This method is not part of the original SCION codebase.
  * Instead, `IsFirstHopAfterXover` was defined in `*Base` via embedded structs.
  * Unfortunately, Gobra does not fully support them yet, so we
  * introduced this wrapper method which acts as a wrapper.
  */
preserves acc(s.Mem(ub), R18)
ensures   res ==> 0 < s.GetCurrINF(ub) && 0 < s.GetCurrHF(ub)
decreases
func (s *Raw) IsFirstHopAfterXover(ghost ub []byte) (res bool) {
	unfold acc(s.Mem(ub), R18)
	defer fold acc(s.Mem(ub), R18)
	return s.Base.IsFirstHopAfterXover()
}

/**
  * This method is not part of the original SCION codebase.
  * Instead, `IsXover` was defined in `*Base` via embedded structs.
  * Unfortunately, Gobra does not fully support them yet, so we
  * introduced this wrapper method which acts as a wrapper.
  */
preserves acc(s.Mem(ub), R9)
ensures res == s.GetIsXoverSpec(ub)
decreases
func (s *Raw) IsXover(ghost ub []byte) (res bool) {
	unfold acc(s.Mem(ub), R9)
	defer fold acc(s.Mem(ub), R9)
	return s.Base.IsXover()
}

ghost
requires acc(s.Mem(ub), _)
decreases
pure func (s *Raw) ValidCurrINF(ghost ub []byte) bool {
	return unfolding acc(s.Mem(ub), _) in
		s.Base.ValidCurrINF()
}

ghost
requires acc(s.Mem(ub), _)
decreases
pure func (s *Raw) ValidCurrHF(ghost ub []byte) bool {
	return unfolding acc(s.Mem(ub), _) in
		s.Base.ValidCurrHF()
}

ghost
requires acc(s.Mem(ub), _)
decreases
pure func (s *Raw) ValidCurrIdxs(ghost ub []byte) bool {
	return unfolding acc(s.Mem(ub), _) in
		s.Base.ValidCurrIdxs()
}

ghost
requires acc(s.Mem(ub), _)
decreases
pure func (s *Raw) InfsMatchHfs(ghost ub []byte) bool {
	return unfolding acc(s.Mem(ub), _) in
		s.Base.InfsMatchHfs()
}

ghost
requires acc(s.Mem(ub), _)
decreases
pure func (s *Raw) CurrInfMatchesCurrHF(ghost ub []byte) bool {
	return unfolding acc(s.Mem(ub), _) in
		s.Base.GetBase().CurrInfMatchesCurrHF()
}

ghost
requires acc(s.Mem(ub), _)
requires acc(sl.Bytes(ub, 0, len(ub)), R56)
decreases
pure func (s *Raw) EqAbsHeader(ub []byte) bool {
	return unfolding acc(s.Mem(ub), _) in
		unfolding acc(s.Base.Mem(), _) in
		s.Base.EqAbsHeader(ub)
}

ghost
requires acc(s.Mem(ub), _)
decreases
pure func (s *Raw) GetIsXoverSpec(ub []byte) bool {
	return unfolding acc(s.Mem(ub), _) in s.Base.IsXoverSpec()
}

ghost
requires acc(s.Mem(ub), _)
decreases
pure func (s *Raw) SegsInBounds(ub []byte) bool {
	return unfolding acc(s.Mem(ub), _) in
		unfolding acc(s.Base.Mem(), _) in
		s.PathMeta.SegsInBounds()
}

/**** End of Stubs ****/

/**** Lemmas ****/

ghost
requires s.Mem(buf)
ensures  s.NonInitMem()
ensures  old(s.RawBufferMem(buf)) === s.RawBufferNonInitMem()
decreases
func (s *Raw) DowngradePerm(buf []byte) {
	unfold s.Mem(buf)
	unfold s.Base.Mem()
	fold s.Base.NonInitMem()
	fold s.NonInitMem()
}

ghost
requires r.Mem(ubuf1)
requires len(ubuf1) <= len(ubuf2)
requires ubuf1 === ubuf2[:len(ubuf1)]
ensures  r.Mem(ubuf2)
decreases
func (r *Raw) Widen(ubuf1, ubuf2 []byte) {
	unfold r.Mem(ubuf1)
	fold r.Mem(ubuf2)
}

/**** End of Lemmas ****/

/**** Start of helpful pure functions ****/
ghost
requires acc(r.Mem(ub), _)
decreases
pure func (r *Raw) GetNumINF(ghost ub []byte) int {
	return unfolding acc(r.Mem(ub), _) in (unfolding acc(r.Base.Mem(), _) in r.NumINF)
}

ghost
requires acc(r.Mem(ub), _)
decreases
pure func (r *Raw) GetNumHops(ghost ub []byte) int {
	return unfolding acc(r.Mem(ub), _) in (unfolding acc(r.Base.Mem(), _) in r.NumHops)
}

ghost
requires acc(r.Mem(ub), _)
decreases
pure func (r *Raw) GetCurrINF(ghost ub []byte) uint8 {
	return unfolding acc(r.Mem(ub), _) in (unfolding acc(r.Base.Mem(), _) in r.PathMeta.CurrINF)
}

ghost
requires acc(r.Mem(ub), _)
decreases
pure func (r *Raw) GetCurrHF(ghost ub []byte) uint8 {
	return unfolding acc(r.Mem(ub), _) in (unfolding acc(r.Base.Mem(), _) in r.PathMeta.CurrHF)
}

ghost
pure
requires acc(s.Mem(buf), _)
decreases
func (s *Raw) RawBufferMem(ghost buf []byte) []byte {
	return unfolding acc(s.Mem(buf), _) in s.Raw
}

ghost
pure
requires acc(s.NonInitMem(), _)
decreases
func (s *Raw) RawBufferNonInitMem() []byte {
	return unfolding acc(s.NonInitMem(), _) in s.Raw
}
/**** End of helpful pure functions ****/

ghost
decreases
pure func HopFieldOffset(numINF int, currHF int, headerOffset int) int {
	return path.InfoFieldOffset(numINF, headerOffset) + path.HopLen * currHF
}

ghost
decreases
pure func PktLen(segs io.SegLens, headerOffset int) int {
	return HopFieldOffset(segs.NumInfoFields(), 0, headerOffset) +
		path.HopLen * segs.TotalHops()
}

ghost
requires  0 <= offset
requires  0 <= currHfIdx && currHfIdx <= segLen
requires  offset + path.HopLen * segLen <= len(raw)
requires  acc(sl.Bytes(raw, 0, len(raw)), R56)
ensures   len(res) == segLen - currHfIdx
decreases segLen - currHfIdx
pure func hopFields(
	raw []byte,
	offset int,
	currHfIdx int,
	segLen int) (res seq[io.IO_HF]) {
	return currHfIdx == segLen ? seq[io.IO_HF]{} :
		let hf := path.BytesToIO_HF(raw, 0, offset + path.HopLen * currHfIdx, len(raw)) in
		seq[io.IO_HF]{hf} ++ hopFields(raw, offset, currHfIdx + 1, segLen)
}

ghost
requires -1 <= currHfIdx && currHfIdx < len(hopfields)
ensures len(res) == currHfIdx + 1
decreases currHfIdx + 1
pure func segPast(hopfields seq[io.IO_HF], currHfIdx int) (res seq[io.IO_HF]) {
	return currHfIdx == -1  ?
		seq[io.IO_HF]{} :
		seq[io.IO_HF]{hopfields[currHfIdx]} ++ segPast(hopfields, currHfIdx - 1)
}

ghost
requires 0 <= currHfIdx && currHfIdx <= len(hopfields)
ensures len(res) == len(hopfields) - currHfIdx
decreases len(hopfields) - currHfIdx
pure func segFuture(hopfields seq[io.IO_HF], currHfIdx int) (res seq[io.IO_HF]) {
	return currHfIdx == len(hopfields) ? seq[io.IO_HF]{} :
		seq[io.IO_HF]{hopfields[currHfIdx]} ++ segFuture(hopfields, currHfIdx + 1)
}

ghost
requires -1 <= currHfIdx && currHfIdx < len(hopfields)
ensures len(res) == currHfIdx + 1
decreases currHfIdx + 1
pure func segHistory(hopfields seq[io.IO_HF], currHfIdx int) (res seq[io.IO_ahi]) {
	return currHfIdx == -1 ? seq[io.IO_ahi]{} :
		seq[io.IO_ahi]{hopfields[currHfIdx].Toab()} ++ segHistory(hopfields, currHfIdx - 1)
}

ghost
requires 0 <= offset
requires 0 < segLen
requires 0 <= currHfIdx && currHfIdx <= segLen
requires offset + path.HopLen * segLen <= len(raw)
requires acc(sl.Bytes(raw, 0, len(raw)), R56)
ensures len(res.Future) == segLen - currHfIdx
ensures len(res.History) == currHfIdx
ensures len(res.Past) == currHfIdx
decreases
pure func segment(raw []byte,
	offset int,
	currHfIdx int,
	ainfo io.IO_ainfo,
	uinfo set[io.IO_msgterm],
	consDir bool,
	peer bool,
	segLen int) (res io.IO_seg2) {
	return let hopfields := hopFields(raw, offset, 0, segLen) in
		io.IO_seg3_ {
			AInfo :ainfo,
			UInfo : uinfo,
			ConsDir : consDir,
			Peer : peer,
			Past : segPast(hopfields, currHfIdx - 1),
			Future : segFuture(hopfields, currHfIdx),
			History : segHistory(hopfields, currHfIdx - 1),
		}
}

ghost
opaque
requires 0 <= headerOffset
requires path.InfoFieldOffset(currInfIdx, headerOffset) + path.InfoLen <= offset
requires 0 < segLen
requires offset + path.HopLen * segLen <= len(raw)
requires 0 <= currHfIdx && currHfIdx <= segLen
requires 0 <= currInfIdx && currInfIdx < 3
requires acc(sl.Bytes(raw, 0, len(raw)), R56)
decreases
pure func CurrSeg(raw []byte,
	offset int,
	currInfIdx int,
	currHfIdx int,
	segLen int,
	headerOffset int) io.IO_seg3 {
	return let ainfo := path.Timestamp(raw, currInfIdx, headerOffset) in
		let consDir := path.ConsDir(raw, currInfIdx, headerOffset) in
		let peer := path.Peer(raw, currInfIdx, headerOffset) in
		let uinfo := path.AbsUinfo(raw, currInfIdx, headerOffset) in
		segment(raw, offset, currHfIdx, ainfo, uinfo, consDir, peer, segLen)
}

ghost
opaque
requires 0 <= headerOffset
requires segs.Valid()
requires PktLen(segs, headerOffset) <= len(raw)
requires 1 <= currInfIdx && currInfIdx < 4
requires acc(sl.Bytes(raw, 0, len(raw)), R56)
decreases
pure func LeftSeg(
	raw []byte,
	currInfIdx int,
	segs io.SegLens,
	headerOffset int) option[io.IO_seg3] {
	return let offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset) in
		(currInfIdx == 1 && segs.Seg2Len > 0) ?
			some(CurrSeg(raw, offset + path.HopLen * segs.Seg1Len, currInfIdx, 0, segs.Seg2Len, headerOffset)) :
			((currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
				some(CurrSeg(raw, offset + path.HopLen * (segs.Seg1Len + segs.Seg2Len), currInfIdx, 0, segs.Seg3Len, headerOffset)) :
				none[io.IO_seg3])
}

ghost
opaque
requires 0 <= headerOffset
requires segs.Valid()
requires PktLen(segs, headerOffset) <= len(raw)
requires -1 <= currInfIdx && currInfIdx < 2
requires acc(sl.Bytes(raw, 0, len(raw)), R56)
decreases
pure func RightSeg(
	raw []byte,
	currInfIdx int,
	segs io.SegLens,
	headerOffset int) option[io.IO_seg3] {
	return let offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset) in
		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
			some(CurrSeg(raw, offset + path.HopLen * segs.Seg1Len, currInfIdx, segs.Seg2Len, segs.Seg2Len, headerOffset)) :
			(currInfIdx == 0 && segs.Seg2Len > 0) ?
				some(CurrSeg(raw, offset, currInfIdx, segs.Seg1Len, segs.Seg1Len, headerOffset)) :
				none[io.IO_seg3]
}

ghost
opaque
requires 0 <= headerOffset
requires segs.Valid()
requires PktLen(segs, headerOffset) <= len(raw)
requires 2 <= currInfIdx && currInfIdx < 5
requires acc(sl.Bytes(raw, 0, len(raw)), R56)
decreases
pure func MidSeg(
	raw []byte,
	currInfIdx int,
	segs io.SegLens,
	headerOffset int) option[io.IO_seg3] {
	return let offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset) in
		(currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
			some(CurrSeg(raw, offset, 0, segs.Seg1Len, segs.Seg1Len, headerOffset)) :
			((currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
				some(CurrSeg(raw, offset + path.HopLen * (segs.Seg1Len + segs.Seg2Len), currInfIdx, 0, segs.Seg3Len, headerOffset)) :
				none[io.IO_seg3])
}

ghost
opaque
requires acc(sl.Bytes(raw, 0, len(raw)), R56)
requires validPktMetaHdr(raw)
decreases
pure func (s *Raw) absPkt(raw []byte) (res io.IO_pkt2) {
	return let _ := reveal validPktMetaHdr(raw) in
		let metaHdr := RawBytesToMetaHdr(raw) in
		let currInfIdx := int(metaHdr.CurrINF) in
		let currHfIdx := int(metaHdr.CurrHF) in
		let seg1Len := int(metaHdr.SegLen[0]) in
		let seg2Len := int(metaHdr.SegLen[1]) in
		let seg3Len := int(metaHdr.SegLen[2]) in
		let segs := io.CombineSegLens(seg1Len, seg2Len, seg3Len) in
		let segLen := segs.LengthOfCurrSeg(currHfIdx) in
		let prevSegLen := segs.LengthOfPrevSeg(currHfIdx) in
		let numINF := segs.NumInfoFields() in
		let offset := HopFieldOffset(numINF, prevSegLen, MetaLen) in
		io.IO_Packet2 {
			CurrSeg : CurrSeg(raw, offset, currInfIdx, currHfIdx-prevSegLen, segLen, MetaLen),
			LeftSeg : LeftSeg(raw, currInfIdx + 1, segs, MetaLen),
			MidSeg : MidSeg(raw, currInfIdx + 2, segs, MetaLen),
			RightSeg : RightSeg(raw, currInfIdx - 1, segs, MetaLen),
		}
}

ghost
requires MetaLen <= len(raw)
requires acc(sl.Bytes(raw, 0, len(raw)), R56)
decreases
pure func RawBytesToMetaHdr(raw []byte) MetaHdr {
	return unfolding acc(sl.Bytes(raw, 0, len(raw)), R56) in
		let hdr := binary.BigEndian.Uint32(raw[:MetaLen])          in
		DecodedFrom(hdr)
}

ghost
requires MetaLen <= len(raw)
requires acc(sl.Bytes(raw, 0, len(raw)), R56)
decreases
pure func RawBytesToBase(raw []byte) Base {
	return let metaHdr := RawBytesToMetaHdr(raw) in
		let seg1 := int(metaHdr.SegLen[0])       in
		let seg2 := int(metaHdr.SegLen[1])       in
		let seg3 := int(metaHdr.SegLen[2])       in
		let segs := io.CombineSegLens(seg1, seg2, seg3) in
		Base{metaHdr, segs.NumInfoFields(), segs.TotalHops()}
}

ghost
opaque
requires acc(sl.Bytes(raw, 0, len(raw)), R56)
decreases
pure func validPktMetaHdr(raw []byte) bool {
	return MetaLen <= len(raw)  &&
		let metaHdr := RawBytesToMetaHdr(raw) in
		let seg1 := int(metaHdr.SegLen[0])    in
		let seg2 := int(metaHdr.SegLen[1])    in
		let seg3 := int(metaHdr.SegLen[2])    in
		let segs := io.CombineSegLens(seg1, seg2, seg3) in
		let base := RawBytesToBase(raw)       in
		0 < metaHdr.SegLen[0]           &&
		base.ValidCurrIdxsSpec()        &&
		base.CurrInfMatchesCurrHF()		&&
		PktLen(segs, MetaLen) <= len(raw)
}

ghost
requires  MetaLen <= idx && idx <= len(raw)
preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
preserves acc(sl.Bytes(raw[:idx], 0, idx), R56)
ensures   RawBytesToMetaHdr(raw) == RawBytesToMetaHdr(raw[:idx])
ensures   RawBytesToBase(raw) == RawBytesToBase(raw[:idx])
decreases
func ValidPktMetaHdrSublice(raw []byte, idx int) {
	reveal validPktMetaHdr(raw)
	reveal validPktMetaHdr(raw[:idx])
	unfold acc(sl.Bytes(raw, 0, len(raw)), R56)
	unfold acc(sl.Bytes(raw[:idx], 0, idx), R56)
	assert forall i int :: { &raw[:MetaLen][i] } 0 <= i && i < MetaLen ==>
		&raw[:MetaLen][i] == &raw[:idx][:MetaLen][i]
	fold acc(sl.Bytes(raw, 0, len(raw)), R56)
	fold acc(sl.Bytes(raw[:idx], 0, idx), R56)
}

ghost
requires acc(s.Mem(ub), R54)
requires acc(sl.Bytes(ub, 0, len(ub)), R55)
requires s.InfsMatchHfs(ub)
requires s.ValidCurrINF(ub)
requires s.ValidCurrHF(ub)
requires s.SegsInBounds(ub)
requires s.CurrInfMatchesCurrHF(ub)
requires s.EqAbsHeader(ub)
ensures  acc(sl.Bytes(ub, 0, len(ub)), R55)
ensures  acc(s.Mem(ub), R54)
ensures  validPktMetaHdr(ub)
ensures  s.EqAbsHeader(ub)
decreases
func (s *Raw) EstablishValidPktMetaHdr(ghost ub []byte) {
	unfold acc(s.Mem(ub), R55)
	unfold acc(s.Base.Mem(), R56)
	assert  MetaLen <= len(ub)
	assert s.Base.GetBase() == RawBytesToBase(ub)
	seg1 := int(s.Base.PathMeta.SegLen[0])
	seg2 := int(s.Base.PathMeta.SegLen[1])
	seg3 := int(s.Base.PathMeta.SegLen[2])
	segs := io.CombineSegLens(seg1, seg2, seg3)
	assert 0 < seg1
	assert s.ValidCurrIdxs(ub)
	assert PktLen(segs, MetaLen) <= len(ub)
	assert reveal validPktMetaHdr(ub)
	fold acc(s.Base.Mem(), R56)
	fold acc(s.Mem(ub), R55)
}

ghost
requires oldPkt.LeftSeg != none[io.IO_seg2]
requires len(oldPkt.CurrSeg.Future) > 0
decreases
pure func AbsXover(oldPkt io.IO_pkt2) (newPkt io.IO_pkt2) {
	return io.IO_Packet2 {
		get(oldPkt.LeftSeg),
		oldPkt.MidSeg,
		oldPkt.RightSeg,
		some(absIncPathSeg(oldPkt.CurrSeg)),
	}
}

ghost
requires len(oldPkt.CurrSeg.Future) > 0
decreases
pure func AbsIncPath(oldPkt io.IO_pkt2) (newPkt io.IO_pkt2) {
	return io.IO_Packet2 {
		absIncPathSeg(oldPkt.CurrSeg),
		oldPkt.LeftSeg,
		oldPkt.MidSeg,
		oldPkt.RightSeg,
	}
}

ghost
requires len(currseg.Future) > 0
decreases
pure func absIncPathSeg(currseg io.IO_seg3) io.IO_seg3 {
	return io.IO_seg3_ {
		AInfo: currseg.AInfo,
		UInfo: currseg.UInfo,
		ConsDir: currseg.ConsDir,
		Peer: currseg.Peer,
		Past: seq[io.IO_HF]{currseg.Future[0]} ++ currseg.Past,
		Future: currseg.Future[1:],
		History: seq[io.IO_ahi]{currseg.Future[0].Toab()} ++ currseg.History,
	}
}

ghost
requires acc(s.Mem(ub), _)
decreases
pure func (s *Raw) IsLastHopSpec(ub []byte) bool {
	return unfolding acc(s.Mem(ub), _) in
		unfolding acc(s.Base.Mem(), _) in
		int(s.PathMeta.CurrHF) == (s.NumHops - 1)
}

ghost
opaque
requires acc(s.Mem(ub), _)
requires 0 <= idx && idx < s.GetNumINF(ub)
requires acc(sl.Bytes(ub, 0, len(ub)), R56)
decreases
pure func (s *Raw) CorrectlyDecodedInfWithIdx(ub []byte, idx int, info path.InfoField) bool {
	return unfolding acc(s.Mem(ub), _) in
		unfolding acc(s.Base.Mem(), _) in
		let infOffset := MetaLen + idx*path.InfoLen in
		infOffset+path.InfoLen <= len(ub) &&
		info.ToAbsInfoField() ==
			reveal path.BytesToAbsInfoField(ub, infOffset)
}

ghost
opaque
requires acc(s.Mem(ub), _)
requires s.ValidCurrINF(ub)
requires acc(sl.Bytes(ub, 0, len(ub)), R56)
decreases
pure func (s *Raw) CorrectlyDecodedInf(ub []byte, info path.InfoField) bool {
	return unfolding acc(s.Mem(ub), _) in
		unfolding acc(s.Base.Mem(), _) in
		let infOffset := MetaLen + int(s.Base.PathMeta.CurrINF)*path.InfoLen in
		infOffset+path.InfoLen <= len(ub) &&
		info.ToAbsInfoField() ==
			reveal path.BytesToAbsInfoField(ub, infOffset)
}

ghost
opaque
requires acc(s.Mem(ub), _)
requires 0 <= idx && idx < s.GetNumHops(ub)
requires acc(sl.Bytes(ub, 0, len(ub)), R56)
decreases
pure func (s *Raw) CorrectlyDecodedHfWithIdx(ub []byte, idx int, hop path.HopField) bool {
	return unfolding acc(s.Mem(ub), _) in
		unfolding acc(s.Base.Mem(), _) in
		let hopOffset := MetaLen + int(s.NumINF)*path.InfoLen + idx*path.HopLen in
		hopOffset+path.HopLen <= len(ub) &&
		hop.ToIO_HF() == path.BytesToIO_HF(ub, 0, hopOffset, len(ub))
}

ghost
opaque
requires acc(s.Mem(ub), _)
requires s.ValidCurrHF(ub)
requires acc(sl.Bytes(ub, 0, len(ub)), R56)
decreases
pure func (s *Raw) CorrectlyDecodedHf(ub []byte, hop path.HopField) bool {
	return unfolding acc(s.Mem(ub), _) in
		unfolding acc(s.Base.Mem(), _) in
		let hopOffset := MetaLen + int(s.NumINF)*path.InfoLen +
			int(s.Base.PathMeta.CurrHF)*path.HopLen in
		hopOffset+path.HopLen <= len(ub) &&
		hop.ToIO_HF() == path.BytesToIO_HF(ub, 0, hopOffset, len(ub))
}

ghost
preserves acc(s.Mem(ubuf), R55)
preserves s.IsLastHopSpec(ubuf)
preserves acc(sl.Bytes(ubuf, 0, len(ubuf)), R56)
preserves validPktMetaHdr(ubuf)
preserves s.EqAbsHeader(ubuf)
ensures len(s.absPkt(ubuf).CurrSeg.Future) == 1
decreases
func (s *Raw) LastHopLemma(ubuf []byte) {
	reveal validPktMetaHdr(ubuf)
	metaHdr := RawBytesToMetaHdr(ubuf)
	currInfIdx := int(metaHdr.CurrINF)
	currHfIdx := int(metaHdr.CurrHF)
	seg1Len := int(metaHdr.SegLen[0])
	seg2Len := int(metaHdr.SegLen[1])
	seg3Len := int(metaHdr.SegLen[2])
	segs := io.CombineSegLens(seg1Len, seg2Len, seg3Len)
	segLen := segs.LengthOfCurrSeg(currHfIdx)
	prevSegLen := segs.LengthOfPrevSeg(currHfIdx)
	numINF := segs.NumInfoFields()
	offset := HopFieldOffset(numINF, prevSegLen, MetaLen)
	pkt := reveal s.absPkt(ubuf)
	assert pkt.CurrSeg == reveal CurrSeg(ubuf, offset, currInfIdx, currHfIdx-prevSegLen, segLen, MetaLen)
	assert len(pkt.CurrSeg.Future) == 1
}

ghost
preserves acc(s.Mem(ubuf), R55)
preserves s.GetIsXoverSpec(ubuf)
preserves acc(sl.Bytes(ubuf, 0, len(ubuf)), R56)
preserves validPktMetaHdr(ubuf)
preserves s.EqAbsHeader(ubuf)
ensures   s.absPkt(ubuf).LeftSeg != none[io.IO_seg2]
ensures   len(s.absPkt(ubuf).CurrSeg.Future) == 1
decreases
func (s *Raw) XoverLemma(ubuf []byte) {
	reveal validPktMetaHdr(ubuf)
	metaHdr := RawBytesToMetaHdr(ubuf)
	currInfIdx := int(metaHdr.CurrINF)
	currHfIdx := int(metaHdr.CurrHF)
	seg1Len := int(metaHdr.SegLen[0])
	seg2Len := int(metaHdr.SegLen[1])
	seg3Len := int(metaHdr.SegLen[2])
	segs := io.CombineSegLens(seg1Len, seg2Len, seg3Len)
	segLen := segs.LengthOfCurrSeg(currHfIdx)
	prevSegLen := segs.LengthOfPrevSeg(currHfIdx)
	numINF := segs.NumInfoFields()
	offset := HopFieldOffset(numINF, prevSegLen, MetaLen)
	pkt := reveal s.absPkt(ubuf)
	assert pkt.CurrSeg == reveal CurrSeg(ubuf, offset, currInfIdx, currHfIdx-prevSegLen, segLen, MetaLen)
	assert pkt.LeftSeg == reveal LeftSeg(ubuf, currInfIdx + 1, segs, MetaLen)
	assert len(pkt.CurrSeg.Future) == 1
	assert pkt.LeftSeg != none[io.IO_seg2]
}

ghost
opaque
requires len(pkt.CurrSeg.Future) > 0
decreases
pure func (s *Raw) EqAbsHopField(pkt io.IO_pkt2, hop io.IO_HF) bool {
	return let currHF := pkt.CurrSeg.Future[0] in
		hop == currHF
}

ghost
opaque
decreases
pure func (s *Raw) EqAbsInfoField(pkt io.IO_pkt2, info io.AbsInfoField) bool {
	return let currseg := pkt.CurrSeg in
		info.AInfo == currseg.AInfo &&
		info.UInfo == currseg.UInfo &&
		info.ConsDir == currseg.ConsDir &&
		info.Peer == currseg.Peer
}

ghost
preserves acc(s.Mem(ubuf), R53)
preserves acc(sl.Bytes(ubuf, 0, len(ubuf)), R53)
preserves validPktMetaHdr(ubuf)
preserves s.EqAbsHeader(ubuf)
preserves len(s.absPkt(ubuf).CurrSeg.Future) > 0
preserves s.ValidCurrINF(ubuf)
preserves s.ValidCurrHF(ubuf)
preserves s.CorrectlyDecodedInf(ubuf, info)
preserves s.CorrectlyDecodedHf(ubuf, hop)
ensures   s.EqAbsInfoField(s.absPkt(ubuf), info.ToAbsInfoField())
ensures   s.EqAbsHopField(s.absPkt(ubuf), hop.ToIO_HF())
decreases
func (s *Raw) DecodingLemma(ubuf []byte, info path.InfoField, hop path.HopField) {
	reveal validPktMetaHdr(ubuf)
	metaHdr := RawBytesToMetaHdr(ubuf)
	currInfIdx := int(metaHdr.CurrINF)
	currHfIdx := int(metaHdr.CurrHF)
	seg1Len := int(metaHdr.SegLen[0])
	seg2Len := int(metaHdr.SegLen[1])
	seg3Len := int(metaHdr.SegLen[2])
	segs := io.CombineSegLens(seg1Len, seg2Len, seg3Len)
	segLen := segs.LengthOfCurrSeg(currHfIdx)
	prevSegLen := segs.LengthOfPrevSeg(currHfIdx)
	numINF := segs.NumInfoFields()
	offset := HopFieldOffset(numINF, prevSegLen, MetaLen)
	hfIdxSeg := currHfIdx-prevSegLen
	reveal s.CorrectlyDecodedInf(ubuf, info)
	reveal s.CorrectlyDecodedHf(ubuf, hop)
	pkt := reveal s.absPkt(ubuf)
	currseg := reveal CurrSeg(ubuf, offset, currInfIdx, hfIdxSeg, segLen, MetaLen)
	hopFields := hopFields(ubuf, offset, 0, segLen)
	hopFieldsBytePositionsLemma(ubuf, offset, 0, segLen, R54)
	reveal hopFieldsBytePositions(ubuf, offset, 0, segLen, hopFields)
	assert currseg.Future[0] == hopFields[hfIdxSeg]
	assert hopFields[hfIdxSeg] ==
		path.BytesToIO_HF(ubuf, 0, offset + path.HopLen * hfIdxSeg, len(ubuf))
	assert currseg.Future[0] == path.BytesToIO_HF(ubuf, 0, offset + path.HopLen * hfIdxSeg, len(ubuf))
	assert reveal s.EqAbsInfoField(s.absPkt(ubuf), info.ToAbsInfoField())
	assert reveal s.EqAbsHopField(s.absPkt(ubuf), hop.ToIO_HF())
}

ghost
requires  path.InfoFieldOffset(currInfIdx, 0) + path.InfoLen <= offset
requires  0 < segLen
requires  offset + path.HopLen * segLen <= len(raw)
requires  0 <= currHfIdx && currHfIdx < segLen
requires  0 <= currInfIdx && currInfIdx < 3
preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
ensures   len(CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0).Future) > 0
decreases
func LenCurrSeg(raw []byte, offset int, currInfIdx int, currHfIdx int, segLen int) {
	reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0)
}

ghost
requires  segs.Valid()
requires  0 < segs.Seg2Len
requires  PktLen(segs, 0) <= len(raw)
requires  0 <= currInfIdx && currInfIdx < 2
requires  1 <= currInfIdx ==> 0 < segs.Seg3Len
preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
ensures   LeftSeg(raw, currInfIdx+1, segs, 0) != none[io.IO_seg3]
ensures   RightSeg(raw, currInfIdx, segs, 0) != none[io.IO_seg3]
decreases
func XoverSegNotNone(raw []byte, currInfIdx int, segs io.SegLens) {
	reveal LeftSeg(raw, currInfIdx+1, segs, 0)
	reveal RightSeg(raw, currInfIdx, segs, 0)
}

ghost
requires  path.InfoFieldOffset(currInfIdx, 0) + path.InfoLen <= offset
requires  0 < segLen
requires  offset + path.HopLen * segLen <= len(raw)
requires  0 <= currHfIdx && currHfIdx < segLen
requires  0 <= currInfIdx && currInfIdx < 3
preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
preserves len(CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0).Future) > 0
ensures   CurrSeg(raw, offset, currInfIdx, currHfIdx+1, segLen, 0) ==
	absIncPathSeg(CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0))
decreases
func IncCurrSeg(raw []byte, offset int, currInfIdx int, currHfIdx int, segLen int) {
	currseg := reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0)
	incseg := reveal CurrSeg(raw, offset, currInfIdx, currHfIdx+1, segLen, 0)
	assert currseg.AInfo == incseg.AInfo
	assert currseg.UInfo == incseg.UInfo
	assert currseg.ConsDir == incseg.ConsDir
	assert currseg.Peer == incseg.Peer
	assert seq[io.IO_HF]{currseg.Future[0]} ++ currseg.Past == incseg.Past
	assert currseg.Future[1:] == incseg.Future
	assert seq[io.IO_ahi]{currseg.Future[0].Toab()} ++ currseg.History == incseg.History
	assert incseg == absIncPathSeg(currseg)
}

ghost
requires  segs.Valid()
requires  0 < segs.Seg2Len
requires  PktLen(segs, 0) <= len(raw)
requires  1 <= currInfIdx && currInfIdx < 3
requires  1 == currInfIdx ==> currHfIdx+1 == segs.Seg1Len
requires  2 == currInfIdx ==> 0 < segs.Seg3Len && currHfIdx+1 == segs.Seg1Len + segs.Seg2Len
requires  PktLen(segs, 0) <= len(raw)
preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
preserves LeftSeg(raw, currInfIdx, segs, 0) != none[io.IO_seg3]
ensures
	let prevSegLen := segs.LengthOfPrevSeg(currHfIdx+1) in
	let segLen := segs.LengthOfCurrSeg(currHfIdx+1) in
	let numInf := segs.NumInfoFields() in
	let offset := HopFieldOffset(numInf, prevSegLen, 0) in
	CurrSeg(raw, offset, currInfIdx, currHfIdx-prevSegLen+1, segLen, 0) ==
		get(LeftSeg(raw, currInfIdx, segs, 0))
decreases
func XoverCurrSeg(raw []byte, currInfIdx int, currHfIdx int, segs io.SegLens) {
	prevSegLen := segs.LengthOfPrevSeg(currHfIdx+1)
	segLen := segs.LengthOfCurrSeg(currHfIdx+1)
	numInf := segs.NumInfoFields()
	offset := HopFieldOffset(numInf, prevSegLen, 0)
	currseg := reveal CurrSeg(raw, offset, currInfIdx, 0, segLen, 0)
	leftseg := reveal LeftSeg(raw, currInfIdx, segs, 0)
	assert currseg == get(leftseg)
}

ghost
requires  segs.Valid()
requires  PktLen(segs, 0) <= len(raw)
requires  2 <= currInfIdx && currInfIdx < 4
preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
ensures   LeftSeg(raw, currInfIdx, segs, 0) ==
	MidSeg(raw, currInfIdx, segs, 0)
decreases
func XoverLeftSeg(raw []byte, currInfIdx int, segs io.SegLens) {
	leftseg := reveal LeftSeg(raw, currInfIdx, segs, 0)
	midseg := reveal MidSeg(raw, currInfIdx, segs, 0)
	assert leftseg == midseg
}

ghost
requires  segs.Valid()
requires  0 < segs.Seg2Len
requires  PktLen(segs, 0) <= len(raw)
requires  -1 <= currInfIdx && currInfIdx < 1
requires  0 == currInfIdx ==> 0 < segs.Seg3Len
preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
ensures   MidSeg(raw, currInfIdx+4, segs, 0) ==
	RightSeg(raw, currInfIdx, segs, 0)
decreases
func XoverMidSeg(raw []byte, currInfIdx int, segs io.SegLens) {
	midseg := reveal MidSeg(raw, currInfIdx+4, segs, 0)
	rightseg := reveal RightSeg(raw, currInfIdx, segs, 0)
	assert midseg == rightseg
}

ghost
requires  segs.Valid()
requires  0 < segs.Seg2Len
requires  PktLen(segs, 0) <= len(raw)
requires  0 <= currInfIdx && currInfIdx < 2
requires  0 == currInfIdx ==> currHfIdx+1 == segs.Seg1Len
requires  1 == currInfIdx ==> 0 < segs.Seg3Len && currHfIdx+1 == segs.Seg1Len + segs.Seg2Len
requires  PktLen(segs, 0) <= len(raw)
preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
preserves RightSeg(raw, currInfIdx, segs, 0) != none[io.IO_seg3]
ensures
	let prevSegLen := segs.LengthOfPrevSeg(currHfIdx) in
	let segLen := segs.LengthOfCurrSeg(currHfIdx) in
	let numInf := segs.NumInfoFields() in
	let offset := HopFieldOffset(numInf, prevSegLen, 0) in
	let currseg := CurrSeg(raw, offset, currInfIdx, currHfIdx-prevSegLen, segLen, 0) in
	len(currseg.Future) > 0 &&
	get(RightSeg(raw, currInfIdx, segs, 0)) == absIncPathSeg(currseg)
decreases
func XoverRightSeg(raw []byte, currInfIdx int, currHfIdx int, segs io.SegLens) {
	prevSegLen := segs.LengthOfPrevSeg(currHfIdx)
	segLen := segs.LengthOfCurrSeg(currHfIdx)
	numInf := segs.NumInfoFields()
	offset := HopFieldOffset(numInf, prevSegLen, 0)
	LenCurrSeg(raw, offset, currInfIdx, segLen - 1, segLen)
	IncCurrSeg(raw, offset, currInfIdx, segLen - 1, segLen)
	currseg := CurrSeg(raw, offset, currInfIdx, segLen - 1, segLen, 0)
	nextseg := CurrSeg(raw, offset, currInfIdx, segLen, segLen, 0)
	rightseg := reveal RightSeg(raw, currInfIdx, segs, 0)
	assert absIncPathSeg(currseg) == nextseg
	assert nextseg == get(rightseg)
	assert absIncPathSeg(currseg) == get(rightseg)
}

ghost
opaque
requires  0 <= offset
requires  0 <= currHFIdx && currHFIdx <= segLen
requires  len(hops) == segLen - currHFIdx
requires  offset + path.HopLen * segLen <= len(raw)
requires  acc(sl.Bytes(raw, 0, len(raw)), R56)
decreases
pure func hopFieldsBytePositions(raw []byte, offset int, currHFIdx int, segLen int, hops seq[io.IO_HF]) bool {
	return forall i int :: { hops[i] } 0 <= i && i < len(hops) ==>
		hops[i] == path.BytesToIO_HF(raw, 0, offset + path.HopLen * (currHFIdx + i), len(raw))
}

ghost
requires  R55 < p
requires  0 <= offset
requires  0 <= currHFIdx && currHFIdx <= segLen
requires  offset + path.HopLen * segLen <= len(raw)
preserves acc(sl.Bytes(raw, 0, len(raw)), p)
ensures   hopFieldsBytePositions(raw, offset, currHFIdx, segLen, hopFields(raw, offset, currHFIdx, segLen))
decreases segLen - currHFIdx
func hopFieldsBytePositionsLemma(
	raw []byte,
	offset int,
	currHFIdx int,
	segLen int,
	p perm) {
	newP := (p + R55)/2
	hopfields := hopFields(raw, offset, currHFIdx, segLen)
	if (currHFIdx != segLen) {
		hopFieldsBytePositionsLemma(raw, offset, currHFIdx + 1, segLen, newP)
		hopfieldsInc := hopFields(raw, offset, currHFIdx + 1, segLen)
		assert reveal hopFieldsBytePositions(raw, offset, currHFIdx + 1, segLen, hopfieldsInc)
	}
	assert reveal hopFieldsBytePositions(raw, offset, currHFIdx, segLen, hopfields)
}