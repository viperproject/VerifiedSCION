// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package scion

import (
	"github.com/scionproto/scion/pkg/slayers/path"
	. "verification/utils/definitions"
	sl "verification/utils/slices"
	"verification/dependencies/encoding/binary"
	"verification/io"
)

/**** Predicates ****/
pred (s *Raw) NonInitMem() {
	acc(&s.Raw) &&
	s.Base.NonInitMem()
}

pred (s *Raw) Mem(buf []byte) {
	s.Base.Mem() &&
	acc(&s.Raw) &&
	len(s.Raw) <= len(buf) &&
	s.Raw === buf[:len(s.Raw)] &&
	len(s.Raw) == s.Base.Len()
}
/**** End of Predicates ****/

(*Raw) implements path.Path

/**** Stubs ****/
/**
  * This method is not part of the original SCION codebase.
  * Instead, `Len` was defined in `*Raw` via embedded structs.
  * Unfortunately, Gobra does not fully support them yet, so we
  * introduced this wrapper method which acts as a wrapper.
  */
pure
requires acc(s.Mem(buf), _)
ensures  unfolding acc(s.Mem(buf), _) in t == s.Base.Type()
decreases
func (s *Raw) Type(ghost buf []byte) (t path.Type) {
	return unfolding acc(s.Mem(buf), _) in s.Base.Type()
}

/**
  * This method is not part of the original SCION codebase.
  * Instead, `Len` was defined in `*Raw` via embedded structs.
  * Unfortunately, Gobra does not fully support them yet, so we
  * introduced this wrapper method which acts as a wrapper.
  */
pure
requires acc(s.Mem(buf), _)
ensures  unfolding acc(s.Mem(buf), _) in l == s.Base.Len()
ensures  l >= 0
decreases
func (s *Raw) Len(ghost buf []byte) (l int) {
	return unfolding acc(s.Mem(buf), _) in s.Base.Len()
}

/**
  * This method is not part of the original SCION codebase.
  * Instead, `IsFirstHopAfterXover` was defined in `*Base` via embedded structs.
  * Unfortunately, Gobra does not fully support them yet, so we
  * introduced this wrapper method which acts as a wrapper.
  */
preserves acc(s.Mem(ub), R18)
ensures   res ==> 0 < s.GetCurrINF(ub) && 0 < s.GetCurrHF(ub)
decreases
func (s *Raw) IsFirstHopAfterXover(ghost ub []byte) (res bool) {
	unfold acc(s.Mem(ub), R18)
	defer fold acc(s.Mem(ub), R18)
	return s.Base.IsFirstHopAfterXover()
}

/**
  * This method is not part of the original SCION codebase.
  * Instead, `IsXover` was defined in `*Base` via embedded structs.
  * Unfortunately, Gobra does not fully support them yet, so we
  * introduced this wrapper method which acts as a wrapper.
  */
preserves acc(s.Mem(ub), R9)
ensures res == s.GetIsXoverSpec(ub)
decreases
func (s *Raw) IsXover(ghost ub []byte) (res bool) {
	unfold acc(s.Mem(ub), R9)
	defer fold acc(s.Mem(ub), R9)
	return s.Base.IsXover()
}

ghost
requires acc(s.Mem(ub), _)
decreases
pure func (s *Raw) ValidCurrINF(ghost ub []byte) bool {
	return unfolding acc(s.Mem(ub), _) in
		s.Base.ValidCurrINF()
}

ghost
requires acc(s.Mem(ub), _)
decreases
pure func (s *Raw) ValidCurrHF(ghost ub []byte) bool {
	return unfolding acc(s.Mem(ub), _) in
		s.Base.ValidCurrHF()
}

ghost
requires acc(s.Mem(ub), _)
decreases
pure func (s *Raw) ValidCurrIdxs(ghost ub []byte) bool {
	return unfolding acc(s.Mem(ub), _) in
		s.Base.ValidCurrIdxs()
}

ghost
requires acc(s.Mem(ub), _)
requires acc(sl.AbsSlice_Bytes(ub, 0, len(ub)), _)
decreases
pure func (s *Raw) EQAbsHeader(ub []byte) bool {
	return unfolding acc(s.Mem(ub), _) in
		s.Base.EQAbsHeader(ub)
}

ghost
requires acc(s.Mem(ub), _)
decreases
pure func (s *Raw) GetIsXoverSpec(ub []byte) bool {
	return unfolding acc(s.Mem(ub), _) in s.Base.IsXoverSpec()
}

ghost
requires acc(s.Mem(ub), _)
decreases
pure func (s *Raw) InBounds(ub []byte) bool {
	return unfolding acc(s.Mem(ub), _) in
		unfolding acc(s.Base.Mem(), _) in
		s.PathMeta.InBounds()
}

/**** End of Stubs ****/

/**** Lemmas ****/

ghost
requires s.Mem(buf)
ensures  s.NonInitMem()
ensures  old(s.RawBufferMem(buf)) === s.RawBufferNonInitMem()
decreases
func (s *Raw) DowngradePerm(buf []byte) {
	unfold s.Mem(buf)
	unfold s.Base.Mem()
	fold s.Base.NonInitMem()
	fold s.NonInitMem()
}

/******** Lemma: RawPerm ********/
pred (r *Raw) RawPermRemainder(ubuf []byte, p perm) {
	0 < p &&
	acc(r.Base.Mem(), p/2) &&
	acc(&r.Raw, p/2) &&
	len(r.Raw) <= len(ubuf) &&
	r.Raw === ubuf[:len(r.Raw)] &&
	acc(sl.AbsSlice_Bytes(ubuf, len(r.Raw), len(ubuf)), p) &&
	len(r.Raw) == r.Base.Len()
}

ghost
requires 0 < p
requires acc(&r.Raw, p/2) && acc(sl.AbsSlice_Bytes(r.Raw, 0, len(r.Raw)), p) && acc(r.Base.Mem(), p/2)
requires r.RawPermRemainder(ubuf, p)
ensures  acc(r.Mem(ubuf), p)
ensures  acc(sl.AbsSlice_Bytes(ubuf, 0, len(ubuf)), p)
decreases
func (r *Raw) UndoRawPerm(ubuf []byte, p perm) {
	unfold r.RawPermRemainder(ubuf, p)
	sl.Unslice_Bytes(ubuf, 0, len(r.Raw), p)
	sl.CombineAtIndex_Bytes(ubuf, 0, len(ubuf), len(r.Raw), p)
	fold acc(r.Mem(ubuf), p)
}

ghost
requires 0 < p
requires acc(r.Mem(ubuf), p)
requires acc(sl.AbsSlice_Bytes(ubuf, 0, len(ubuf)), p)
ensures  acc(&r.Raw, p/2)
ensures  acc(sl.AbsSlice_Bytes(r.Raw, 0, len(r.Raw)), p)
ensures  acc(r.Base.Mem(), p/2)
ensures  r.RawPermRemainder(ubuf, p)
ensures  r.Raw === old(unfolding acc(r.Mem(ubuf), p) in r.Raw)
decreases
func (r *Raw) RawPerm(ubuf []byte, p perm) {
	unfold acc(r.Mem(ubuf), p)
	sl.SplitByIndex_Bytes(ubuf, 0, len(ubuf), len(r.Raw), p)
	sl.Reslice_Bytes(ubuf, 0, len(r.Raw), p)
	fold r.RawPermRemainder(ubuf, p)
}
/******** End of Lemma: RawPerm ********/

/******** Lemma: RawRangePerm ********/
pred (r *Raw) RawRangePermRemainder(ubuf []byte, start, end int, p perm) {
	0 < p &&
	acc(r.Base.Mem(), p) &&
	acc(&r.Raw, p/2) &&
	0 <= start && start <= end && end <= len(r.Raw) &&
	len(r.Raw) <= len(ubuf) &&
	r.Raw === ubuf[:len(r.Raw)] &&
	acc(sl.AbsSlice_Bytes(r.Raw, 0, start), p) &&
	acc(sl.AbsSlice_Bytes(r.Raw, end, len(r.Raw)), p) &&
	acc(sl.AbsSlice_Bytes(ubuf, len(r.Raw), len(ubuf)), p) &&
	len(r.Raw) == r.Base.Len()
}

ghost
requires 0 < p
requires acc(&r.Raw, p/2)
requires 0 <= start && start <= end && end <= len(r.Raw)
requires acc(sl.AbsSlice_Bytes(r.Raw[start:end], 0, end-start), p)
requires r.RawRangePermRemainder(ubuf, start, end, p)
ensures  acc(r.Mem(ubuf), p)
ensures  acc(sl.AbsSlice_Bytes(ubuf, 0, len(ubuf)), p)
decreases
func (r *Raw) UndoRawRangePerm(ubuf []byte, start, end int, p perm) {
	unfold r.RawRangePermRemainder(ubuf, start, end, p)
	sl.Unslice_Bytes(r.Raw, start, end, p)
	sl.CombineAtIndex_Bytes(r.Raw, 0, end, start, p)
	sl.CombineAtIndex_Bytes(r.Raw, 0, len(r.Raw), end, p)
	fold r.RawPermRemainder(ubuf, p)
	r.UndoRawPerm(ubuf, p)
}

// Notice that no permission to r.Base.Mem() is provided, unlike the previous methods
ghost
requires 0 < p
requires acc(r.Mem(ubuf), p)
requires acc(sl.AbsSlice_Bytes(ubuf, 0, len(ubuf)), p)
requires 0 <= start && start <= end && end <= unfolding acc(r.Mem(ubuf), p) in len(r.Raw)
ensures  acc(&r.Raw, p/2)
ensures  r.Raw === old(unfolding acc(r.Mem(ubuf), p) in r.Raw)
ensures  acc(sl.AbsSlice_Bytes(r.Raw[start:end], 0, end-start), p)
ensures  r.RawRangePermRemainder(ubuf, start, end, p)
decreases
func (r *Raw) RawRangePerm(ubuf []byte, start, end int, p perm) {
	unfold acc(r.Mem(ubuf), p)
	sl.SplitByIndex_Bytes(ubuf, 0, len(ubuf), len(r.Raw), p)
	sl.Reslice_Bytes(ubuf, 0, len(r.Raw), p)
	sl.SplitByIndex_Bytes(r.Raw, 0, len(r.Raw), start, p)
	sl.SplitByIndex_Bytes(r.Raw, start, len(r.Raw), end, p)
	sl.Reslice_Bytes(r.Raw, start, end, p)
	fold r.RawRangePermRemainder(ubuf, start, end, p)
}
/******** End of Lemma: RawRangePerm ********/

ghost
requires r.Mem(ubuf1)
requires len(ubuf1) <= len(ubuf2)
requires ubuf1 === ubuf2[:len(ubuf1)]
ensures  r.Mem(ubuf2)
decreases
func (r *Raw) Widen(ubuf1, ubuf2 []byte) {
	unfold r.Mem(ubuf1)
	fold r.Mem(ubuf2)
}

/**** End of Lemmas ****/

/**** Start of helpful pure functions ****/
ghost
requires acc(r.Mem(ub), _)
decreases
pure func (r *Raw) GetNumINF(ghost ub []byte) int {
	return unfolding acc(r.Mem(ub), _) in (unfolding acc(r.Base.Mem(), _) in r.NumINF)
}

ghost
requires acc(r.Mem(ub), _)
decreases
pure func (r *Raw) GetNumHops(ghost ub []byte) int {
	return unfolding acc(r.Mem(ub), _) in (unfolding acc(r.Base.Mem(), _) in r.NumHops)
}

ghost
requires acc(r.Mem(ub), _)
decreases
pure func (r *Raw) GetCurrINF(ghost ub []byte) uint8 {
	return unfolding acc(r.Mem(ub), _) in (unfolding acc(r.Base.Mem(), _) in r.PathMeta.CurrINF)
}

ghost
requires acc(r.Mem(ub), _)
decreases
pure func (r *Raw) GetCurrHF(ghost ub []byte) uint8 {
	return unfolding acc(r.Mem(ub), _) in (unfolding acc(r.Base.Mem(), _) in r.PathMeta.CurrHF)
}

ghost
pure
requires acc(s.Mem(buf), _)
decreases
func (s *Raw) RawBufferMem(ghost buf []byte) []byte {
	return unfolding acc(s.Mem(buf), _) in s.Raw
}

ghost
pure
requires acc(s.NonInitMem(), _)
decreases
func (s *Raw) RawBufferNonInitMem() []byte {
	return unfolding acc(s.NonInitMem(), _) in s.Raw
}
/**** End of helpful pure functions ****/

ghost
decreases
pure func numInfoFields(seg1Len int, seg2Len int, seg3Len int) int {
	return seg3Len > 0 ? 3 : (seg2Len > 0 ? 2 : 1)
}

ghost
decreases
pure func hopFieldOffset(numINF int, currHF int, headerOffset int) int {
	return path.InfoFieldOffset(numINF, headerOffset) + path.HopLen * currHF
}

ghost
decreases
pure func pktLen(seg1Len int, seg2Len int, seg3Len int, headerOffset int) int {
	return hopFieldOffset(numInfoFields(seg1Len, seg2Len, seg3Len), 0, headerOffset) +
		path.HopLen * (seg1Len + seg2Len + seg3Len)
}


ghost
decreases
pure func lengthOfCurrSeg(currHF int, seg1Len int, seg2Len int, seg3Len int) int {
	return seg1Len > currHF ? seg1Len : ((seg1Len + seg2Len) > currHF ? seg2Len : seg3Len)
}

ghost
requires 0 <= currHF
ensures  res <= currHF
decreases
pure func lengthOfPrevSeg(currHF int, seg1Len int, seg2Len int, seg3Len int) (res int) {
	return seg1Len > currHF ? 0 : ((seg1Len + seg2Len) > currHF ? seg1Len : seg1Len + seg2Len)
}

ghost
requires  0 <= offset
requires  0 <= currHFIdx && currHFIdx <= segLen
requires  offset + path.HopLen * segLen <= len(raw)
requires  acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
ensures   len(res) == segLen - currHFIdx
decreases segLen - currHFIdx
pure func hopFieldsConsDir(
	raw []byte,
	offset int,
	currHFIdx int,
	segLen int) (res seq[io.IO_HF]) {
	return currHFIdx == segLen ? seq[io.IO_HF]{} :
		let hf := path.BytesToIO_HF(raw, 0, offset + path.HopLen * currHFIdx, len(raw)) in
		seq[io.IO_HF]{hf} ++ hopFieldsConsDir(raw, offset, currHFIdx + 1, segLen)
}

ghost
requires  0 <= offset
requires  -1 <= currHFIdx
requires  offset + path.HopLen * currHFIdx + path.HopLen <= len(raw)
requires  acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
ensures   len(res) == currHFIdx + 1
decreases currHFIdx + 1
pure func hopFieldsNotConsDir(
	raw []byte,
	offset int,
	currHFIdx int) (res seq[io.IO_HF]) {
	return currHFIdx == -1 ? seq[io.IO_HF]{} :
		let hf :=  path.BytesToIO_HF(raw, 0, offset + path.HopLen * currHFIdx, len(raw)) in
		hopFieldsNotConsDir(raw, offset, currHFIdx - 1) ++ seq[io.IO_HF]{hf}
}

ghost
requires -1 <= currHFIdx && currHFIdx < len(hopfields)
ensures len(res) == currHFIdx + 1
decreases currHFIdx + 1
pure func segPast(hopfields seq[io.IO_HF], currHFIdx int) (res seq[io.IO_HF]) {
	return currHFIdx == -1  ?
		seq[io.IO_HF]{} :
		seq[io.IO_HF]{hopfields[currHFIdx]} ++ segPast(hopfields, currHFIdx - 1)
}

ghost
requires 0 <= currHFIdx && currHFIdx <= len(hopfields)
ensures len(res) == len(hopfields) - currHFIdx
decreases len(hopfields) - currHFIdx
pure func segFuture(hopfields seq[io.IO_HF], currHFIdx int) (res seq[io.IO_HF]) {
	return currHFIdx == len(hopfields) ? seq[io.IO_HF]{} :
		seq[io.IO_HF]{hopfields[currHFIdx]} ++ segFuture(hopfields, currHFIdx + 1)
}

ghost
requires -1 <= currHFIdx && currHFIdx < len(hopfields)
ensures len(res) == currHFIdx + 1
decreases currHFIdx + 1
pure func segHistory(hopfields seq[io.IO_HF], currHFIdx int) (res seq[io.IO_ahi]) {
	return currHFIdx == -1 ? seq[io.IO_ahi]{} :
		seq[io.IO_ahi]{hopfields[currHFIdx].Toab()} ++ segHistory(hopfields, currHFIdx - 1)
}

ghost
requires 0 <= offset
requires 0 < segLen
requires 0 <= currHFIdx && currHFIdx <= segLen
requires offset + path.HopLen * segLen <= len(raw)
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
ensures len(res.Future) == segLen - currHFIdx
ensures len(res.History) == currHFIdx
ensures len(res.Past) == currHFIdx
decreases
pure func segment(raw []byte,
	offset int,
	currHFIdx int,
	ainfo io.IO_ainfo,
	uinfo set[io.IO_msgterm],
	consDir bool,
	peer bool,
	segLen int) (res io.IO_seg2) {
	return let hopfields := consDir ?
		hopFieldsConsDir(raw, offset, 0, segLen) :
		hopFieldsNotConsDir(raw, offset, segLen - 1) in
		io.IO_seg2(io.IO_seg3_{
			AInfo :ainfo,
			UInfo : uinfo,
			ConsDir : consDir,
			Peer : peer,
			Past : segPast(hopfields, currHFIdx - 1),
			Future : segFuture(hopfields, currHFIdx),
			History : segHistory(hopfields, currHFIdx - 1),
		})
}

ghost
opaque
requires 0 <= headerOffset
requires path.InfoFieldOffset(currINFIdx, headerOffset) + path.InfoLen <= offset
requires 0 < segLen
requires offset + path.HopLen * segLen <= len(raw)
requires 0 <= currHFIdx && currHFIdx <= segLen
requires 0 <= currINFIdx && currINFIdx < 3
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func currSeg(raw []byte,
	offset int,
	currINFIdx int,
	currHFIdx int,
	segLen int,
	headerOffset int) io.IO_seg3 {
	return let ainfo := path.Timestamp(raw, currINFIdx, headerOffset) in
		let consDir := path.ConsDir(raw, currINFIdx, headerOffset) in
		let peer := path.Peer(raw, currINFIdx, headerOffset) in
		let uinfo := path.AbsUinfo(raw, currINFIdx, headerOffset) in
		segment(raw, offset, currHFIdx, ainfo, uinfo, consDir, peer, segLen)
}

ghost
opaque
requires 0 <= headerOffset
requires 0 < seg1Len
requires 0 <= seg2Len
requires 0 <= seg3Len
requires pktLen(seg1Len, seg2Len, seg3Len, headerOffset) <= len(raw)
requires 1 <= currINFIdx && currINFIdx < 4
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func leftSeg(
	raw []byte,
	currINFIdx int,
	seg1Len int,
	seg2Len int,
	seg3Len int,
	headerOffset int) option[io.IO_seg3] {
	return let offset := hopFieldOffset(numInfoFields(seg1Len, seg2Len, seg3Len), 0, headerOffset) in
		(currINFIdx == 1 && seg2Len > 0) ?
			some(reveal currSeg(raw, offset + path.HopLen * seg1Len, currINFIdx, 0, seg2Len, headerOffset)) :
			((currINFIdx == 2 && seg2Len > 0 && seg3Len > 0) ?
				some(reveal currSeg(raw, offset + path.HopLen * (seg1Len + seg2Len), currINFIdx, 0, seg3Len, headerOffset)) :
				none[io.IO_seg3])
}

ghost
opaque
requires 0 <= headerOffset
requires 0 < seg1Len
requires 0 <= seg2Len
requires 0 <= seg3Len
requires pktLen(seg1Len, seg2Len, seg3Len, headerOffset) <= len(raw)
requires -1 <= currINFIdx && currINFIdx < 2
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func rightSeg(
	raw []byte,
	currINFIdx int,
	seg1Len int,
	seg2Len int,
	seg3Len int,
	headerOffset int) option[io.IO_seg3] {
	return let offset := hopFieldOffset(numInfoFields(seg1Len, seg2Len, seg3Len), 0, headerOffset) in
		(currINFIdx == 1 && seg2Len > 0 && seg3Len > 0) ?
			some(currSeg(raw, offset + path.HopLen * seg1Len, currINFIdx, seg2Len, seg2Len, headerOffset)) :
			(currINFIdx == 0 && seg2Len > 0) ?
				some(currSeg(raw, offset, currINFIdx, seg1Len, seg1Len, headerOffset)) :
				none[io.IO_seg3]
}

ghost
opaque
requires 0 <= headerOffset
requires 0 < seg1Len
requires 0 <= seg2Len
requires 0 <= seg3Len
requires pktLen(seg1Len, seg2Len, seg3Len, headerOffset) <= len(raw)
requires 2 <= currINFIdx && currINFIdx < 5
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func midSeg(
	raw []byte,
	currINFIdx int,
	seg1Len int,
	seg2Len int,
	seg3Len int,
	headerOffset int) option[io.IO_seg3] {
	return let offset := hopFieldOffset(numInfoFields(seg1Len, seg2Len, seg3Len), 0, headerOffset) in
		(currINFIdx == 4 && seg2Len > 0) ?
			some(currSeg(raw, offset, 0, seg1Len, seg1Len, headerOffset)) :
			((currINFIdx == 2 && seg2Len > 0 && seg3Len > 0) ?
				some(currSeg(raw, offset + path.HopLen * (seg1Len + seg2Len), currINFIdx, 0, seg3Len, headerOffset)) :
				none[io.IO_seg3])
}

ghost
opaque
requires dp.Valid()
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
requires validPktMetaHdr(raw)
opaque
decreases
pure func (s *Raw) absPkt(dp io.DataPlaneSpec, raw []byte) (res io.IO_pkt2) {
	return let _ := reveal validPktMetaHdr(raw) in
		let hdr := (unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56) in binary.BigEndian.Uint32(raw[:MetaLen])) in
		let metaHdr := DecodedFrom(hdr) in
		let currINFIdx := int(metaHdr.CurrINF) in
		let currHFIdx := int(metaHdr.CurrHF) in
		let seg1Len := int(metaHdr.SegLen[0]) in
		let seg2Len := int(metaHdr.SegLen[1]) in
		let seg3Len := int(metaHdr.SegLen[2]) in
		let segLen := lengthOfCurrSeg(currHFIdx, seg1Len, seg2Len, seg3Len) in
		let prevSegLen := lengthOfPrevSeg(currHFIdx, seg1Len, seg2Len, seg3Len) in
		let numINF := numInfoFields(seg1Len, seg2Len, seg3Len) in
		let offset := hopFieldOffset(numINF, 0, 0) in
		io.IO_pkt2(io.IO_Packet2{
			CurrSeg : currSeg(raw, offset+prevSegLen, currINFIdx, currHFIdx-prevSegLen, segLen, 0),
			LeftSeg : leftSeg(raw, currINFIdx + 1, seg1Len, seg2Len , seg3Len, 0),
			MidSeg : midSeg(raw, currINFIdx + 2, seg1Len, seg2Len , seg3Len, 0),
			RightSeg : rightSeg(raw, currINFIdx - 1, seg1Len, seg2Len , seg3Len, 0),
		})
}

ghost
opaque
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func validPktMetaHdr(raw []byte) bool {
	return MetaLen <= len(raw)  &&
		unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56) in
		let hdr := binary.BigEndian.Uint32(raw[:MetaLen]) in
		let metaHdr := DecodedFrom(hdr) in
		let seg1 := int(metaHdr.SegLen[0]) in
		let seg2 := int(metaHdr.SegLen[1]) in
		let seg3 := int(metaHdr.SegLen[2]) in
		let base := Base{metaHdr,
			numInfoFields(seg1, seg2, seg3),
			seg1 + seg2 + seg3} in
		metaHdr.InBounds() &&
		0 < metaHdr.SegLen[0] &&
		base.ValidCurrIdxsSpec() &&
		pktLen(seg1, seg2, seg3, 0) <= len(raw)
}

ghost
decreases
pure func AbsSetInfoField(oldPkt io.IO_pkt2, info path.IntermediateAbsInfoField) (newPkt io.IO_pkt2) {
	return io.IO_pkt2(
		io.IO_Packet2{
			io.IO_seg3(
				io.IO_seg3_{
					info.AInfo,
					info.UInfo,
					info.ConsDir,
					info.Peer,
					oldPkt.CurrSeg.Past,
					oldPkt.CurrSeg.Future,
					oldPkt.CurrSeg.History}),
			oldPkt.LeftSeg,
			oldPkt.MidSeg,
			oldPkt.RightSeg})
}