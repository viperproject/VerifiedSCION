// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package scion

import (
	"github.com/scionproto/scion/pkg/slayers/path"
	. "verification/utils/definitions"
	sl "verification/utils/slices"
	"verification/dependencies/encoding/binary"
	"verification/io"
)

/**** Predicates ****/
pred (s *Raw) NonInitMem() {
	acc(&s.Raw) &&
	s.Base.NonInitMem()
}

pred (s *Raw) Mem(buf []byte) {
	s.Base.Mem() &&
	acc(&s.Raw) &&
	len(s.Raw) <= len(buf) &&
	s.Raw === buf[:len(s.Raw)] &&
	len(s.Raw) == s.Base.Len()
}
/**** End of Predicates ****/

(*Raw) implements path.Path

/**** Stubs ****/
/**
  * This method is not part of the original SCION codebase.
  * Instead, `Len` was defined in `*Raw` via embedded structs.
  * Unfortunately, Gobra does not fully support them yet, so we
  * introduced this wrapper method which acts as a wrapper.
  */
pure
requires acc(s.Mem(buf), _)
ensures  unfolding acc(s.Mem(buf), _) in t == s.Base.Type()
decreases
func (s *Raw) Type(ghost buf []byte) (t path.Type) {
	return unfolding acc(s.Mem(buf), _) in s.Base.Type()
}

/**
  * This method is not part of the original SCION codebase.
  * Instead, `Len` was defined in `*Raw` via embedded structs.
  * Unfortunately, Gobra does not fully support them yet, so we
  * introduced this wrapper method which acts as a wrapper.
  */
pure
requires acc(s.Mem(buf), _)
ensures  unfolding acc(s.Mem(buf), _) in l == s.Base.Len()
ensures  l >= 0
decreases
func (s *Raw) Len(ghost buf []byte) (l int) {
	return unfolding acc(s.Mem(buf), _) in s.Base.Len()
}

/**
  * This method is not part of the original SCION codebase.
  * Instead, `IsFirstHopAfterXover` was defined in `*Base` via embedded structs.
  * Unfortunately, Gobra does not fully support them yet, so we
  * introduced this wrapper method which acts as a wrapper.
  */
preserves acc(s.Mem(ub), R18)
ensures   res ==> 0 < s.GetCurrINF(ub) && 0 < s.GetCurrHF(ub)
decreases
func (s *Raw) IsFirstHopAfterXover(ghost ub []byte) (res bool) {
	unfold acc(s.Mem(ub), R18)
	defer fold acc(s.Mem(ub), R18)
	return s.Base.IsFirstHopAfterXover()
}

/**
  * This method is not part of the original SCION codebase.
  * Instead, `IsXover` was defined in `*Base` via embedded structs.
  * Unfortunately, Gobra does not fully support them yet, so we
  * introduced this wrapper method which acts as a wrapper.
  */
preserves acc(s.Mem(ub), R9)
ensures res == s.GetIsXoverSpec(ub)
decreases
func (s *Raw) IsXover(ghost ub []byte) (res bool) {
	unfold acc(s.Mem(ub), R9)
	defer fold acc(s.Mem(ub), R9)
	return s.Base.IsXover()
}

ghost
requires acc(s.Mem(ub), _)
decreases
pure func (s *Raw) ValidCurrINF(ghost ub []byte) bool {
	return unfolding acc(s.Mem(ub), _) in
		s.Base.ValidCurrINF()
}

ghost
requires acc(s.Mem(ub), _)
decreases
pure func (s *Raw) ValidCurrHF(ghost ub []byte) bool {
	return unfolding acc(s.Mem(ub), _) in
		s.Base.ValidCurrHF()
}

ghost
requires acc(s.Mem(ub), _)
decreases
pure func (s *Raw) ValidCurrIdxs(ghost ub []byte) bool {
	return unfolding acc(s.Mem(ub), _) in
		s.Base.ValidCurrIdxs()
}

ghost
requires acc(s.Mem(ub), _)
requires acc(sl.AbsSlice_Bytes(ub, 0, len(ub)), R56)
decreases
pure func (s *Raw) EqAbsHeader(ub []byte) bool {
	return unfolding acc(s.Mem(ub), _) in
		unfolding acc(s.Base.Mem(), _) in
		s.Base.EqAbsHeader(ub)
}

ghost
requires acc(s.Mem(ub), _)
decreases
pure func (s *Raw) GetIsXoverSpec(ub []byte) bool {
	return unfolding acc(s.Mem(ub), _) in s.Base.IsXoverSpec()
}

ghost
requires acc(s.Mem(ub), _)
decreases
pure func (s *Raw) InBounds(ub []byte) bool {
	return unfolding acc(s.Mem(ub), _) in
		unfolding acc(s.Base.Mem(), _) in
		s.PathMeta.InBounds()
}

/**** End of Stubs ****/

/**** Lemmas ****/

ghost
requires s.Mem(buf)
ensures  s.NonInitMem()
ensures  old(s.RawBufferMem(buf)) === s.RawBufferNonInitMem()
decreases
func (s *Raw) DowngradePerm(buf []byte) {
	unfold s.Mem(buf)
	unfold s.Base.Mem()
	fold s.Base.NonInitMem()
	fold s.NonInitMem()
}

/******** Lemma: RawPerm ********/
pred (r *Raw) RawPermRemainder(ubuf []byte, p perm) {
	0 < p &&
	acc(r.Base.Mem(), p/2) &&
	acc(&r.Raw, p/2) &&
	len(r.Raw) <= len(ubuf) &&
	r.Raw === ubuf[:len(r.Raw)] &&
	acc(sl.AbsSlice_Bytes(ubuf, len(r.Raw), len(ubuf)), p) &&
	len(r.Raw) == r.Base.Len()
}

ghost
requires 0 < p
requires acc(&r.Raw, p/2) && acc(sl.AbsSlice_Bytes(r.Raw, 0, len(r.Raw)), p) && acc(r.Base.Mem(), p/2)
requires r.RawPermRemainder(ubuf, p)
ensures  acc(r.Mem(ubuf), p)
ensures  acc(sl.AbsSlice_Bytes(ubuf, 0, len(ubuf)), p)
decreases
func (r *Raw) UndoRawPerm(ubuf []byte, p perm) {
	unfold r.RawPermRemainder(ubuf, p)
	sl.Unslice_Bytes(ubuf, 0, len(r.Raw), p)
	sl.CombineAtIndex_Bytes(ubuf, 0, len(ubuf), len(r.Raw), p)
	fold acc(r.Mem(ubuf), p)
}

ghost
requires 0 < p
requires acc(r.Mem(ubuf), p)
requires acc(sl.AbsSlice_Bytes(ubuf, 0, len(ubuf)), p)
ensures  acc(&r.Raw, p/2)
ensures  acc(sl.AbsSlice_Bytes(r.Raw, 0, len(r.Raw)), p)
ensures  acc(r.Base.Mem(), p/2)
ensures  r.RawPermRemainder(ubuf, p)
ensures  r.Raw === old(unfolding acc(r.Mem(ubuf), p) in r.Raw)
decreases
func (r *Raw) RawPerm(ubuf []byte, p perm) {
	unfold acc(r.Mem(ubuf), p)
	sl.SplitByIndex_Bytes(ubuf, 0, len(ubuf), len(r.Raw), p)
	sl.Reslice_Bytes(ubuf, 0, len(r.Raw), p)
	fold r.RawPermRemainder(ubuf, p)
}
/******** End of Lemma: RawPerm ********/

/******** Lemma: RawRangePerm ********/
pred (r *Raw) RawRangePermRemainder(ubuf []byte, start, end int, p perm) {
	0 < p &&
	acc(r.Base.Mem(), p) &&
	acc(&r.Raw, p/2) &&
	0 <= start && start <= end && end <= len(r.Raw) &&
	len(r.Raw) <= len(ubuf) &&
	r.Raw === ubuf[:len(r.Raw)] &&
	acc(sl.AbsSlice_Bytes(r.Raw, 0, start), p) &&
	acc(sl.AbsSlice_Bytes(r.Raw, end, len(r.Raw)), p) &&
	acc(sl.AbsSlice_Bytes(ubuf, len(r.Raw), len(ubuf)), p) &&
	len(r.Raw) == r.Base.Len()
}

ghost
requires 0 < p
requires acc(&r.Raw, p/2)
requires 0 <= start && start <= end && end <= len(r.Raw)
requires acc(sl.AbsSlice_Bytes(r.Raw[start:end], 0, end-start), p)
requires r.RawRangePermRemainder(ubuf, start, end, p)
ensures  acc(r.Mem(ubuf), p)
ensures  acc(sl.AbsSlice_Bytes(ubuf, 0, len(ubuf)), p)
decreases
func (r *Raw) UndoRawRangePerm(ubuf []byte, start, end int, p perm) {
	unfold r.RawRangePermRemainder(ubuf, start, end, p)
	sl.Unslice_Bytes(r.Raw, start, end, p)
	sl.CombineAtIndex_Bytes(r.Raw, 0, end, start, p)
	sl.CombineAtIndex_Bytes(r.Raw, 0, len(r.Raw), end, p)
	fold r.RawPermRemainder(ubuf, p)
	r.UndoRawPerm(ubuf, p)
}

// Notice that no permission to r.Base.Mem() is provided, unlike the previous methods
ghost
requires 0 < p
requires acc(r.Mem(ubuf), p)
requires acc(sl.AbsSlice_Bytes(ubuf, 0, len(ubuf)), p)
requires 0 <= start && start <= end && end <= unfolding acc(r.Mem(ubuf), p) in len(r.Raw)
ensures  acc(&r.Raw, p/2)
ensures  r.Raw === old(unfolding acc(r.Mem(ubuf), p) in r.Raw)
ensures  acc(sl.AbsSlice_Bytes(r.Raw[start:end], 0, end-start), p)
ensures  r.RawRangePermRemainder(ubuf, start, end, p)
decreases
func (r *Raw) RawRangePerm(ubuf []byte, start, end int, p perm) {
	unfold acc(r.Mem(ubuf), p)
	sl.SplitByIndex_Bytes(ubuf, 0, len(ubuf), len(r.Raw), p)
	sl.Reslice_Bytes(ubuf, 0, len(r.Raw), p)
	sl.SplitByIndex_Bytes(r.Raw, 0, len(r.Raw), start, p)
	sl.SplitByIndex_Bytes(r.Raw, start, len(r.Raw), end, p)
	sl.Reslice_Bytes(r.Raw, start, end, p)
	fold r.RawRangePermRemainder(ubuf, start, end, p)
}
/******** End of Lemma: RawRangePerm ********/

ghost
requires r.Mem(ubuf1)
requires len(ubuf1) <= len(ubuf2)
requires ubuf1 === ubuf2[:len(ubuf1)]
ensures  r.Mem(ubuf2)
decreases
func (r *Raw) Widen(ubuf1, ubuf2 []byte) {
	unfold r.Mem(ubuf1)
	fold r.Mem(ubuf2)
}

/**** End of Lemmas ****/

/**** Start of helpful pure functions ****/
ghost
requires acc(r.Mem(ub), _)
decreases
pure func (r *Raw) GetNumINF(ghost ub []byte) int {
	return unfolding acc(r.Mem(ub), _) in (unfolding acc(r.Base.Mem(), _) in r.NumINF)
}

ghost
requires acc(r.Mem(ub), _)
decreases
pure func (r *Raw) GetNumHops(ghost ub []byte) int {
	return unfolding acc(r.Mem(ub), _) in (unfolding acc(r.Base.Mem(), _) in r.NumHops)
}

ghost
requires acc(r.Mem(ub), _)
decreases
pure func (r *Raw) GetCurrINF(ghost ub []byte) uint8 {
	return unfolding acc(r.Mem(ub), _) in (unfolding acc(r.Base.Mem(), _) in r.PathMeta.CurrINF)
}

ghost
requires acc(r.Mem(ub), _)
decreases
pure func (r *Raw) GetCurrHF(ghost ub []byte) uint8 {
	return unfolding acc(r.Mem(ub), _) in (unfolding acc(r.Base.Mem(), _) in r.PathMeta.CurrHF)
}

ghost
pure
requires acc(s.Mem(buf), _)
decreases
func (s *Raw) RawBufferMem(ghost buf []byte) []byte {
	return unfolding acc(s.Mem(buf), _) in s.Raw
}

ghost
pure
requires acc(s.NonInitMem(), _)
decreases
func (s *Raw) RawBufferNonInitMem() []byte {
	return unfolding acc(s.NonInitMem(), _) in s.Raw
}
/**** End of helpful pure functions ****/

ghost
decreases
pure func NumInfoFields(seg1Len int, seg2Len int, seg3Len int) int {
	return seg3Len > 0 ? 3 : (seg2Len > 0 ? 2 : 1)
}

ghost
decreases
pure func HopFieldOffset(numINF int, currHF int, headerOffset int) int {
	return path.InfoFieldOffset(numINF, headerOffset) + path.HopLen * currHF
}

ghost
decreases
pure func pktLen(seg1Len int, seg2Len int, seg3Len int, headerOffset int) int {
	return HopFieldOffset(NumInfoFields(seg1Len, seg2Len, seg3Len), 0, headerOffset) +
		path.HopLen * (seg1Len + seg2Len + seg3Len)
}


ghost
decreases
pure func LengthOfCurrSeg(currHF int, seg1Len int, seg2Len int, seg3Len int) int {
	return seg1Len > currHF ? seg1Len : ((seg1Len + seg2Len) > currHF ? seg2Len : seg3Len)
}

ghost
requires 0 <= currHF
ensures  res <= currHF
decreases
pure func LengthOfPrevSeg(currHF int, seg1Len int, seg2Len int, seg3Len int) (res int) {
	return seg1Len > currHF ? 0 : ((seg1Len + seg2Len) > currHF ? seg1Len : seg1Len + seg2Len)
}

ghost
requires  0 <= offset
requires  0 <= currHFIdx && currHFIdx <= segLen
requires  offset + path.HopLen * segLen <= len(raw)
requires  acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
ensures   len(res) == segLen - currHFIdx
decreases segLen - currHFIdx
pure func hopFields(
	raw []byte,
	offset int,
	currHFIdx int,
	segLen int) (res seq[io.IO_HF]) {
	return currHFIdx == segLen ? seq[io.IO_HF]{} :
		let hf := path.BytesToIO_HF(raw, 0, offset + path.HopLen * currHFIdx, len(raw)) in
		seq[io.IO_HF]{hf} ++ hopFields(raw, offset, currHFIdx + 1, segLen)
}

ghost
requires -1 <= currHFIdx && currHFIdx < len(hopfields)
ensures len(res) == currHFIdx + 1
decreases currHFIdx + 1
pure func segPast(hopfields seq[io.IO_HF], currHFIdx int) (res seq[io.IO_HF]) {
	return currHFIdx == -1  ?
		seq[io.IO_HF]{} :
		seq[io.IO_HF]{hopfields[currHFIdx]} ++ segPast(hopfields, currHFIdx - 1)
}

ghost
requires 0 <= currHFIdx && currHFIdx <= len(hopfields)
ensures len(res) == len(hopfields) - currHFIdx
decreases len(hopfields) - currHFIdx
pure func segFuture(hopfields seq[io.IO_HF], currHFIdx int) (res seq[io.IO_HF]) {
	return currHFIdx == len(hopfields) ? seq[io.IO_HF]{} :
		seq[io.IO_HF]{hopfields[currHFIdx]} ++ segFuture(hopfields, currHFIdx + 1)
}

ghost
requires -1 <= currHFIdx && currHFIdx < len(hopfields)
ensures len(res) == currHFIdx + 1
decreases currHFIdx + 1
pure func segHistory(hopfields seq[io.IO_HF], currHFIdx int) (res seq[io.IO_ahi]) {
	return currHFIdx == -1 ? seq[io.IO_ahi]{} :
		seq[io.IO_ahi]{hopfields[currHFIdx].Toab()} ++ segHistory(hopfields, currHFIdx - 1)
}

ghost
requires 0 <= offset
requires 0 < segLen
requires 0 <= currHFIdx && currHFIdx <= segLen
requires offset + path.HopLen * segLen <= len(raw)
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
ensures len(res.Future) == segLen - currHFIdx
ensures len(res.History) == currHFIdx
ensures len(res.Past) == currHFIdx
decreases
pure func segment(raw []byte,
	offset int,
	currHFIdx int,
	ainfo io.IO_ainfo,
	uinfo set[io.IO_msgterm],
	consDir bool,
	peer bool,
	segLen int) (res io.IO_seg2) {
	return let hopfields := hopFields(raw, offset, 0, segLen) in
		io.IO_seg2(io.IO_seg3_{
			AInfo :ainfo,
			UInfo : uinfo,
			ConsDir : consDir,
			Peer : peer,
			Past : segPast(hopfields, currHFIdx - 1),
			Future : segFuture(hopfields, currHFIdx),
			History : segHistory(hopfields, currHFIdx - 1),
		})
}

ghost
opaque
requires 0 <= headerOffset
requires path.InfoFieldOffset(currINFIdx, headerOffset) + path.InfoLen <= offset
requires 0 < segLen
requires offset + path.HopLen * segLen <= len(raw)
requires 0 <= currHFIdx && currHFIdx <= segLen
requires 0 <= currINFIdx && currINFIdx < 3
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func CurrSeg(raw []byte,
	offset int,
	currINFIdx int,
	currHFIdx int,
	segLen int,
	headerOffset int) io.IO_seg3 {
	return let ainfo := path.Timestamp(raw, currINFIdx, headerOffset) in
		let consDir := path.ConsDir(raw, currINFIdx, headerOffset) in
		let peer := path.Peer(raw, currINFIdx, headerOffset) in
		let uinfo := path.AbsUinfo(raw, currINFIdx, headerOffset) in
		segment(raw, offset, currHFIdx, ainfo, uinfo, consDir, peer, segLen)
}

ghost
opaque
requires 0 <= headerOffset
requires 0 < seg1Len
requires 0 <= seg2Len
requires 0 <= seg3Len
requires pktLen(seg1Len, seg2Len, seg3Len, headerOffset) <= len(raw)
requires 1 <= currINFIdx && currINFIdx < 4
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func LeftSeg(
	raw []byte,
	currINFIdx int,
	seg1Len int,
	seg2Len int,
	seg3Len int,
	headerOffset int) option[io.IO_seg3] {
	return let offset := HopFieldOffset(NumInfoFields(seg1Len, seg2Len, seg3Len), 0, headerOffset) in
		(currINFIdx == 1 && seg2Len > 0) ?
			some(reveal CurrSeg(raw, offset + path.HopLen * seg1Len, currINFIdx, 0, seg2Len, headerOffset)) :
			((currINFIdx == 2 && seg2Len > 0 && seg3Len > 0) ?
				some(reveal CurrSeg(raw, offset + path.HopLen * (seg1Len + seg2Len), currINFIdx, 0, seg3Len, headerOffset)) :
				none[io.IO_seg3])
}

ghost
opaque
requires 0 <= headerOffset
requires 0 < seg1Len
requires 0 <= seg2Len
requires 0 <= seg3Len
requires pktLen(seg1Len, seg2Len, seg3Len, headerOffset) <= len(raw)
requires -1 <= currINFIdx && currINFIdx < 2
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func RightSeg(
	raw []byte,
	currINFIdx int,
	seg1Len int,
	seg2Len int,
	seg3Len int,
	headerOffset int) option[io.IO_seg3] {
	return let offset := HopFieldOffset(NumInfoFields(seg1Len, seg2Len, seg3Len), 0, headerOffset) in
		(currINFIdx == 1 && seg2Len > 0 && seg3Len > 0) ?
			some(CurrSeg(raw, offset + path.HopLen * seg1Len, currINFIdx, seg2Len, seg2Len, headerOffset)) :
			(currINFIdx == 0 && seg2Len > 0) ?
				some(CurrSeg(raw, offset, currINFIdx, seg1Len, seg1Len, headerOffset)) :
				none[io.IO_seg3]
}

ghost
opaque
requires 0 <= headerOffset
requires 0 < seg1Len
requires 0 <= seg2Len
requires 0 <= seg3Len
requires pktLen(seg1Len, seg2Len, seg3Len, headerOffset) <= len(raw)
requires 2 <= currINFIdx && currINFIdx < 5
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func MidSeg(
	raw []byte,
	currINFIdx int,
	seg1Len int,
	seg2Len int,
	seg3Len int,
	headerOffset int) option[io.IO_seg3] {
	return let offset := HopFieldOffset(NumInfoFields(seg1Len, seg2Len, seg3Len), 0, headerOffset) in
		(currINFIdx == 4 && seg2Len > 0) ?
			some(CurrSeg(raw, offset, 0, seg1Len, seg1Len, headerOffset)) :
			((currINFIdx == 2 && seg2Len > 0 && seg3Len > 0) ?
				some(CurrSeg(raw, offset + path.HopLen * (seg1Len + seg2Len), currINFIdx, 0, seg3Len, headerOffset)) :
				none[io.IO_seg3])
}

ghost
opaque
requires dp.Valid()
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
requires validPktMetaHdr(raw)
decreases
pure func (s *Raw) absPkt(dp io.DataPlaneSpec, raw []byte) (res io.IO_pkt2) {
	return let _ := reveal validPktMetaHdr(raw) in
		let hdr := (unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56) in binary.BigEndian.Uint32(raw[:MetaLen])) in
		let metaHdr := DecodedFrom(hdr) in
		let currINFIdx := int(metaHdr.CurrINF) in
		let currHFIdx := int(metaHdr.CurrHF) in
		let seg1Len := int(metaHdr.SegLen[0]) in
		let seg2Len := int(metaHdr.SegLen[1]) in
		let seg3Len := int(metaHdr.SegLen[2]) in
		let segLen := LengthOfCurrSeg(currHFIdx, seg1Len, seg2Len, seg3Len) in
		let prevSegLen := LengthOfPrevSeg(currHFIdx, seg1Len, seg2Len, seg3Len) in
		let numINF := NumInfoFields(seg1Len, seg2Len, seg3Len) in
		let offset := HopFieldOffset(numINF, 0, 0) in
		io.IO_pkt2(io.IO_Packet2{
			CurrSeg : CurrSeg(raw, offset+prevSegLen, currINFIdx, currHFIdx-prevSegLen, segLen, 0),
			LeftSeg : LeftSeg(raw, currINFIdx + 1, seg1Len, seg2Len , seg3Len, 0),
			MidSeg : MidSeg(raw, currINFIdx + 2, seg1Len, seg2Len , seg3Len, 0),
			RightSeg : RightSeg(raw, currINFIdx - 1, seg1Len, seg2Len , seg3Len, 0),
		})
}

// In the future, this should probably use AbsMetaHdr as
// the return type.
ghost
requires MetaLen <= len(raw)
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func RawBytesToMetaHdr(raw []byte) MetaHdr {
	return unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56) in
		let hdr := binary.BigEndian.Uint32(raw[:MetaLen])          in
		DecodedFrom(hdr)
}

// In the future, this should probably use AbsBase as
// the return type.
ghost
requires MetaLen <= len(raw)
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func RawBytesToBase(raw []byte) Base {
	return let metaHdr := RawBytesToMetaHdr(raw) in
		let seg1 := int(metaHdr.SegLen[0])       in
		let seg2 := int(metaHdr.SegLen[1])       in
		let seg3 := int(metaHdr.SegLen[2])       in
		Base{metaHdr, NumInfoFields(seg1, seg2, seg3), seg1 + seg2 + seg3}
}

ghost
opaque
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func validPktMetaHdr(raw []byte) bool {
	return MetaLen <= len(raw)  &&
		let metaHdr := RawBytesToMetaHdr(raw) in
		let seg1 := int(metaHdr.SegLen[0])    in
		let seg2 := int(metaHdr.SegLen[1])    in
		let seg3 := int(metaHdr.SegLen[2])    in
		let base := RawBytesToBase(raw)       in
		0 < metaHdr.SegLen[0]           &&
		base.ValidCurrIdxsSpec()        &&
		pktLen(seg1, seg2, seg3, 0) <= len(raw)
}

ghost
requires  MetaLen <= idx && idx <= len(raw)
preserves acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
preserves acc(sl.AbsSlice_Bytes(raw[:idx], 0, idx), R56)
ensures   RawBytesToMetaHdr(raw) == RawBytesToMetaHdr(raw[:idx])
ensures   RawBytesToBase(raw) == RawBytesToBase(raw[:idx])
decreases
func ValidPktMetaHdrSublice(raw []byte, idx int) {
	reveal validPktMetaHdr(raw)
	reveal validPktMetaHdr(raw[:idx])
	unfold acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
	unfold acc(sl.AbsSlice_Bytes(raw[:idx], 0, idx), R56)
	assert forall i int :: { &raw[:MetaLen][i] } 0 <= i && i < MetaLen ==>
		&raw[:MetaLen][i] == &raw[:idx][:MetaLen][i]
	fold acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
	fold acc(sl.AbsSlice_Bytes(raw[:idx], 0, idx), R56)
}

ghost
decreases
pure func AbsSetInfoField(oldPkt io.IO_pkt2, info path.IntermediateAbsInfoField) (newPkt io.IO_pkt2) {
	return let newCurrSeg := io.IO_seg3(io.IO_seg3_{
		info.AInfo,
		info.UInfo,
		info.ConsDir,
		info.Peer,
		oldPkt.CurrSeg.Past,
		oldPkt.CurrSeg.Future,
		oldPkt.CurrSeg.History}) in
	io.IO_pkt2(io.IO_Packet2{newCurrSeg, oldPkt.LeftSeg, oldPkt.MidSeg, oldPkt.RightSeg})
}

ghost
requires acc(s.Mem(ub), _)
decreases
pure func (s *Raw) IsLastHopSpec(ub []byte) bool {
	return unfolding acc(s.Mem(ub), _) in
		unfolding acc(s.Base.Mem(), _) in
		int(s.PathMeta.CurrHF) == (s.NumHops - 1)
}

ghost
preserves acc(s.Mem(ubuf), R55)
preserves s.IsLastHopSpec(ubuf)
preserves acc(sl.AbsSlice_Bytes(ubuf, 0, len(ubuf)), R56)
preserves dp.Valid()
preserves validPktMetaHdr(ubuf)
preserves s.EqAbsHeader(ubuf)
ensures len(s.absPkt(dp, ubuf).CurrSeg.Future) == 1
decreases
func (s *Raw) LastHopLemma(ubuf []byte, dp io.DataPlaneSpec) {
	reveal validPktMetaHdr(ubuf)
	hdr := (unfolding acc(sl.AbsSlice_Bytes(ubuf, 0, len(ubuf)), R56) in
			binary.BigEndian.Uint32(ubuf[:MetaLen]))
	metaHdr := DecodedFrom(hdr)
	currINFIdx := int(metaHdr.CurrINF)
	currHFIdx := int(metaHdr.CurrHF)
	seg1Len := int(metaHdr.SegLen[0])
	seg2Len := int(metaHdr.SegLen[1])
	seg3Len := int(metaHdr.SegLen[2])
	segLen := LengthOfCurrSeg(currHFIdx, seg1Len, seg2Len, seg3Len)
	prevSegLen := LengthOfPrevSeg(currHFIdx, seg1Len, seg2Len, seg3Len)
	numINF := NumInfoFields(seg1Len, seg2Len, seg3Len)
	offset := HopFieldOffset(numINF, 0, 0)
	pkt := reveal s.absPkt(dp, ubuf)
	assert pkt.CurrSeg == reveal CurrSeg(ubuf, offset+prevSegLen, currINFIdx, currHFIdx-prevSegLen, segLen, 0)
	assert len(pkt.CurrSeg.Future) == 1
}