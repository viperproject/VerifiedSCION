// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package scion

import (
	"github.com/scionproto/scion/pkg/slayers/path"
	. "verification/utils/definitions"
	sl "verification/utils/slices"
	"verification/io"
)

// ===============
// Hopfields lemma
// ===============

ghost
opaque
requires  0 <= offset
requires  0 <= currHFIdx && currHFIdx <= segLen
requires  len(hopFields) == segLen - currHFIdx
requires  offset + path.HopLen * segLen <= len(raw)
requires  acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func HopFieldsConsDirBytePositions(
	raw []byte,
	offset int,
	currHFIdx int,
	segLen int,
	hopFields seq[io.IO_HF]) bool {
	return forall i int :: { hopFields[i] } 0 <= i && i < len(hopFields) ==> hopFields[i] == path.BytesToIO_HF(raw, 0, offset + path.HopLen * (currHFIdx + i), len(raw))
}

ghost
requires  0 <= offset
requires  0 <= currHFIdx && currHFIdx <= segLen
requires  offset + path.HopLen * segLen <= len(raw)
preserves acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
ensures  forall i int :: { &raw[i] } 0 <= i && i < len(raw) ==> old(unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56) in raw[i]) == (unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56) in raw[i])
ensures   HopFieldsConsDirBytePositions(raw, offset, currHFIdx, segLen, hopFieldsConsDir(raw, offset, currHFIdx, segLen))
decreases segLen - currHFIdx
func hopFieldsConsDirBytePositionsLemma_Rec(
	raw []byte,
	offset int,
	currHFIdx int,
	segLen int) {
	
	if (currHFIdx == segLen) {
		assert reveal HopFieldsConsDirBytePositions(raw, offset, currHFIdx, segLen, hopFieldsConsDir(raw, offset, currHFIdx, segLen))
	} else {
		hopFieldsConsDirBytePositionsLemma_Rec(raw, offset, currHFIdx + 1, segLen)
		assert reveal HopFieldsConsDirBytePositions(raw, offset, currHFIdx + 1, segLen, hopFieldsConsDir(raw, offset, currHFIdx + 1, segLen))
		assert reveal HopFieldsConsDirBytePositions(raw, offset, currHFIdx, segLen, hopFieldsConsDir(raw, offset, currHFIdx, segLen))
	}
}

// Wrapper lemma to get rid of ugly postcondition that preserves the contents of raw
ghost
requires  0 <= offset
requires  0 <= currHFIdx && currHFIdx <= segLen
requires  offset + path.HopLen * segLen <= len(raw)
preserves acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
ensures   HopFieldsConsDirBytePositions(raw, offset, currHFIdx, segLen, hopFieldsConsDir(raw, offset, currHFIdx, segLen))
decreases segLen - currHFIdx
func HopFieldsConsDirBytePositionsLemma(
	raw []byte,
	offset int,
	currHFIdx int,
	segLen int) {
	hopFieldsConsDirBytePositionsLemma_Rec(raw, offset, currHFIdx, segLen)
}

// ====================
// Segment future lemma
// ====================


ghost
requires 0 <= currHFIdx && currHFIdx <= len(hopfields)
ensures  segFuture(hopfields, currHFIdx) == hopfields[currHFIdx:]
decreases len(hopfields) - currHFIdx
func segFutureSubSequenceLemma(hopfields seq[io.IO_HF], currHFIdx int) {
	if (currHFIdx != len(hopfields)) {
		segFutureSubSequenceLemma(hopfields, currHFIdx + 1)
	}
}

ghost
requires 0 <= offset
requires 0 < segLen
requires 0 <= currHFIdx && currHFIdx <= segLen
requires offset + path.HopLen * segLen <= len(raw)
preserves acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R55)
ensures let seg := segment(raw, offset, currHFIdx, ainfo, uinfo, consDir, peer, segLen) in HopFieldsConsDirBytePositions(raw, offset, currHFIdx, segLen, seg.Future)
decreases
func segmentFutureBytePosition(
	raw []byte,
	offset int,
	currHFIdx int,
	ainfo io.IO_ainfo,
	uinfo set[io.IO_msgterm],
	consDir bool,
	peer bool,
	segLen int) {
	
	hopfields := hopFieldsConsDir(raw, offset, 0, segLen)
	HopFieldsConsDirBytePositionsLemma(raw, offset, 0, segLen)
	assert reveal HopFieldsConsDirBytePositions(raw, offset, 0, segLen, hopfields)
	seg := io.IO_seg2(io.IO_seg3_{
		AInfo :ainfo,
		UInfo : uinfo,
		ConsDir : consDir,
		Peer : peer,
		Past : segPast(hopfields, currHFIdx - 1),
		Future : segFuture(hopfields, currHFIdx),
		History : segHistory(hopfields, currHFIdx - 1),
	})
	segFutureSubSequenceLemma(hopfields, currHFIdx)
	assert reveal HopFieldsConsDirBytePositions(raw, offset, currHFIdx, segLen, seg.Future)

}
