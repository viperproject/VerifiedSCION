// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package scion

import (
	"github.com/scionproto/scion/pkg/slayers/path"
	. "verification/utils/definitions"
	sl "verification/utils/slices"
	"verification/io"
)

ghost
requires 0 <= currInfIdx
requires path.InfoFieldOffset(currInfIdx, MetaLen) + path.InfoLen <= len(raw)
decreases
pure func InfofieldByteSlice(raw []byte, currInfIdx int) ([]byte) {
    return let infOffset := currInfIdx == 4 ?
        path.InfoFieldOffset(0, MetaLen) :
        path.InfoFieldOffset(currInfIdx, MetaLen) in
        raw[infOffset:infOffset+path.InfoLen]
}

ghost
requires s.Valid()
requires 0 <= currInfIdx
decreases
pure func HopfieldsStartIdx(currInfIdx int, s io.SegLens) int {
    return let numInf := NumInfoFields(s.SegLen[0], s.SegLen[1], s.SegLen[2]) in
        let infOffset := path.InfoFieldOffset(numInf, MetaLen) in
        (currInfIdx == 0 || currInfIdx == 4) ? infOffset :
        currInfIdx == 1 ? infOffset+s.SegLen[0]*path.HopLen :
        infOffset+(s.SegLen[0]+s.SegLen[1])*path.HopLen
}

ghost
requires s.Valid()
requires 0 <= currInfIdx
decreases
pure func HopfieldsEndIdx(currInfIdx int, s io.SegLens) int {
    return let numInf := NumInfoFields(s.SegLen[0], s.SegLen[1], s.SegLen[2]) in
        let infOffset := path.InfoFieldOffset(numInf, MetaLen) in
        (currInfIdx == 0 || currInfIdx == 4) ? infOffset+s.SegLen[0]*path.HopLen :
        currInfIdx == 1 ? infOffset+(s.SegLen[0]+s.SegLen[1])*path.HopLen :
        infOffset+(s.SegLen[0]+s.SegLen[1]+s.SegLen[2])*path.HopLen
}

ghost
requires s.Valid()
requires 0 <= currInfIdx
requires pktLen(s.SegLen[0], s.SegLen[1], s.SegLen[2], MetaLen) <= len(raw)
decreases
pure func HopfieldsByteSlice(raw []byte, currInfIdx int, s io.SegLens) ([]byte) {
    return let numInf := NumInfoFields(s.SegLen[0], s.SegLen[1], s.SegLen[2]) in
        let infOffset := path.InfoFieldOffset(numInf, MetaLen) in
        let start := HopfieldsStartIdx(currInfIdx, s) in
        let end := HopfieldsEndIdx(currInfIdx, s) in
        raw[start:end]
}

// SliceBytesIntoSegments splits the raw bytes of a packet into its hopfield segments
ghost
requires 0 < p
requires s.Valid()
requires pktLen(s.SegLen[0], s.SegLen[1], s.SegLen[2], MetaLen) <= len(raw)
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), p)
ensures  acc(sl.AbsSlice_Bytes(raw[:HopfieldsStartIdx(0, s)], 0, HopfieldsStartIdx(0, s)), p)
ensures  acc(sl.AbsSlice_Bytes(HopfieldsByteSlice(raw, 0, s), 0, s.SegLen[0]*path.HopLen), p)
ensures  acc(sl.AbsSlice_Bytes(HopfieldsByteSlice(raw, 1, s), 0, s.SegLen[1]*path.HopLen), p)
ensures  acc(sl.AbsSlice_Bytes(HopfieldsByteSlice(raw, 2, s), 0, s.SegLen[2]*path.HopLen), p)
ensures  acc(sl.AbsSlice_Bytes(raw[HopfieldsEndIdx(2, s):], 0, len(raw[HopfieldsEndIdx(2, s):])), p)
decreases
func SliceBytesIntoSegments(raw []byte, s io.SegLens, p perm) {
	sl.SplitByIndex_Bytes(raw, 0, len(raw), HopfieldsStartIdx(0, s), p)
	sl.SplitByIndex_Bytes(raw, HopfieldsStartIdx(0, s), len(raw), HopfieldsEndIdx(0, s), p)
    sl.SplitByIndex_Bytes(raw, HopfieldsStartIdx(1, s), len(raw), HopfieldsEndIdx(1, s), p)
    sl.SplitByIndex_Bytes(raw, HopfieldsStartIdx(2, s), len(raw), HopfieldsEndIdx(2, s), p)
	sl.Reslice_Bytes(raw, 0, HopfieldsStartIdx(0, s), p)
    sl.Reslice_Bytes(raw, HopfieldsStartIdx(0, s), HopfieldsEndIdx(0, s), p)
	sl.Reslice_Bytes(raw, HopfieldsStartIdx(1, s), HopfieldsEndIdx(1, s), p)
	sl.Reslice_Bytes(raw, HopfieldsStartIdx(2, s), HopfieldsEndIdx(2, s), p)
	sl.Reslice_Bytes(raw, HopfieldsEndIdx(2, s), len(raw), p)
}

// CombineBytesFromSegments combines the three hopfield segments of a packet into a single slice of bytes.
ghost
requires 0 < p
requires s.Valid()
requires pktLen(s.SegLen[0], s.SegLen[1], s.SegLen[2], MetaLen) <= len(raw)
requires acc(sl.AbsSlice_Bytes(raw[:HopfieldsStartIdx(0, s)], 0, HopfieldsStartIdx(0, s)), p)
requires acc(sl.AbsSlice_Bytes(HopfieldsByteSlice(raw, 0, s), 0, s.SegLen[0]*path.HopLen), p)
requires acc(sl.AbsSlice_Bytes(HopfieldsByteSlice(raw, 1, s), 0, s.SegLen[1]*path.HopLen), p)
requires acc(sl.AbsSlice_Bytes(HopfieldsByteSlice(raw, 2, s), 0, s.SegLen[2]*path.HopLen), p)
requires acc(sl.AbsSlice_Bytes(raw[HopfieldsEndIdx(2, s):], 0, len(raw[HopfieldsEndIdx(2, s):])), p)
ensures  acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), p)
decreases
func CombineBytesFromSegments(raw []byte, s io.SegLens, p perm) {
	sl.Unslice_Bytes(raw, HopfieldsEndIdx(2, s), len(raw), p)
	sl.Unslice_Bytes(raw, HopfieldsStartIdx(2, s), HopfieldsEndIdx(2, s), p)
	sl.Unslice_Bytes(raw, HopfieldsStartIdx(1, s), HopfieldsEndIdx(1, s), p)
    sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, s), HopfieldsEndIdx(0, s), p)
	sl.Unslice_Bytes(raw, 0, HopfieldsStartIdx(0, s), p)
    sl.CombineAtIndex_Bytes(raw, HopfieldsStartIdx(2, s), len(raw), HopfieldsEndIdx(2, s), p)
    sl.CombineAtIndex_Bytes(raw, HopfieldsStartIdx(1, s), len(raw), HopfieldsEndIdx(1, s), p)
	sl.CombineAtIndex_Bytes(raw, HopfieldsStartIdx(0, s), len(raw), HopfieldsEndIdx(0, s), p)
    sl.CombineAtIndex_Bytes(raw, 0, len(raw), HopfieldsStartIdx(0, s), p)
}

// SliceBytesIntoInfoFields splits the raw bytes of a packet into its infofields
ghost
requires 0 < p
requires s.Valid()
requires pktLen(s.SegLen[0], s.SegLen[1], s.SegLen[2], MetaLen) <= len(raw)
requires numInf == NumInfoFields(s.SegLen[0], s.SegLen[1], s.SegLen[2])
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), p)
ensures  acc(sl.AbsSlice_Bytes(raw[:MetaLen], 0, MetaLen), p)
ensures  acc(sl.AbsSlice_Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
ensures  1 < numInf ==> acc(sl.AbsSlice_Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
ensures  2 < numInf ==> acc(sl.AbsSlice_Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
ensures  acc(sl.AbsSlice_Bytes(raw[HopfieldsStartIdx(0, s):], 0, len(raw[HopfieldsStartIdx(0, s):])), p)
decreases
func SliceBytesIntoInfoFields(raw []byte, numInf int, s io.SegLens, p perm) {
	sl.SplitByIndex_Bytes(raw, 0, len(raw), MetaLen, p)
	sl.SplitByIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
    sl.Reslice_Bytes(raw, 0, MetaLen, p)
	sl.Reslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
	if(numInf > 1) {
		sl.SplitByIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
            path.InfoFieldOffset(2, MetaLen), p)
		sl.Reslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
            path.InfoFieldOffset(2, MetaLen), p)
	}
    if(numInf > 2) {
            sl.SplitByIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
                HopfieldsStartIdx(0, s), p)
            sl.Reslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, s), p)
    }
	sl.Reslice_Bytes(raw, HopfieldsStartIdx(0, s), len(raw), p)
}

// CombineBytesFromInfoFields combines the infofields of a packet into a single slice of bytes.
ghost
requires 0 < p
requires s.Valid()
requires pktLen(s.SegLen[0], s.SegLen[1], s.SegLen[2], MetaLen) <= len(raw)
requires numInf == NumInfoFields(s.SegLen[0], s.SegLen[1], s.SegLen[2])
requires acc(sl.AbsSlice_Bytes(raw[:MetaLen], 0, MetaLen), p)
requires acc(sl.AbsSlice_Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
requires 1 < numInf ==> acc(sl.AbsSlice_Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
requires 2 < numInf ==> acc(sl.AbsSlice_Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
requires acc(sl.AbsSlice_Bytes(raw[HopfieldsStartIdx(0, s):], 0, len(raw[HopfieldsStartIdx(0, s):])), p)
ensures  acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), p)
decreases
func CombineBytesFromInfoFields(raw []byte, numInf int, s io.SegLens, p perm) {
	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, s), len(raw), p)
	if(numInf > 2) {
		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, s), p)
		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
            HopfieldsStartIdx(0, s), p)
	}
	if(numInf > 1) {
		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
            path.InfoFieldOffset(2, MetaLen), p)
		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
            path.InfoFieldOffset(2, MetaLen), p)
	}
	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
	sl.Unslice_Bytes(raw, 0, MetaLen, p)
	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
}

// CurrSegWithInfo depends only on the hopfield segment rather than the entire raw bytes of the packet.
// This simplifies proving changes within a segment after updates to the packet's raw bytes.
ghost
opaque
requires 0 < SegLen
requires 0 <= currHfIdx && currHfIdx <= SegLen
requires SegLen*path.HopLen == len(hopfields)
requires acc(sl.AbsSlice_Bytes(hopfields, 0, len(hopfields)), R56)
decreases
pure func CurrSegWithInfo(hopfields []byte, currHfIdx int, SegLen int, inf io.AbsInfoField) io.IO_seg3 {
	return segment(hopfields, 0, currHfIdx, inf.AInfo, inf.UInfo, inf.ConsDir, inf.Peer, SegLen)
}

// LeftSegWithInfo depends only on the hopfield segment rather than the entire raw bytes of the packet.
// Depending on which segment of the packet is represented by the left segment (currInfIdx), it requires
// permissions to a different slice of the packet's bytes.
ghost
opaque
requires s.Valid()
requires (currInfIdx == 1 && s.SegLen[1] > 0) ||
    (currInfIdx == 2 && s.SegLen[1] > 0 && s.SegLen[2] > 0) ==>
    let start := HopfieldsStartIdx(currInfIdx, s) in
    let end := HopfieldsEndIdx(currInfIdx, s) in
    inf != none[io.AbsInfoField] &&
    len(hopfields) == end-start &&
	acc(sl.AbsSlice_Bytes(hopfields, 0, len(hopfields)), R49)
decreases
pure func LeftSegWithInfo(
	hopfields []byte,
	currInfIdx int,
	s io.SegLens,
	inf option[io.AbsInfoField]) option[io.IO_seg3] {
	return (currInfIdx == 1 && s.SegLen[1] > 0) ?
			some(CurrSegWithInfo(hopfields, 0, s.SegLen[1], get(inf))) :
			(currInfIdx == 2 && s.SegLen[1] > 0 && s.SegLen[2] > 0) ?
				some(CurrSegWithInfo(hopfields, 0, s.SegLen[2], get(inf))) :
				none[io.IO_seg3]
}

// RightSegWithInfo depends only on the hopfield segment rather than the entire raw bytes of the packet.
// Depending on which segment of the packet is represented by the right segment (currInfIdx), it
// requires permissions to a different slice of the packet's bytes.
ghost
opaque
requires s.Valid()
requires (currInfIdx == 0 && s.SegLen[1] > 0) ||
   (currInfIdx == 1 && s.SegLen[1] > 0 && s.SegLen[2] > 0) ==>
    let start := HopfieldsStartIdx(currInfIdx, s) in
    let end := HopfieldsEndIdx(currInfIdx, s) in
    inf != none[io.AbsInfoField] &&
    len(hopfields) == end-start &&
	acc(sl.AbsSlice_Bytes(hopfields, 0, len(hopfields)), R49)
decreases
pure func RightSegWithInfo(
	hopfields []byte,
	currInfIdx int,
	s io.SegLens,
	inf option[io.AbsInfoField]) option[io.IO_seg3] {
	return (currInfIdx == 1 && s.SegLen[1] > 0 && s.SegLen[2] > 0) ?
			some(CurrSegWithInfo(hopfields, s.SegLen[1], s.SegLen[1], get(inf))) :
			(currInfIdx == 0 && s.SegLen[1] > 0) ?
				some(CurrSegWithInfo(hopfields, s.SegLen[0], s.SegLen[0], get(inf))) :
				none[io.IO_seg3]
}

// MidSegWithInfo depends only on the hopfield segment rather than the entire raw bytes of the packet.
// Depending on which segment of the packet is represented by the mid segment (currInfIdx), it requires
// permissions to a different slice of the packet's bytes.
ghost
opaque
requires s.Valid()
requires (s.SegLen[1] > 0 && s.SegLen[2] > 0 &&
    (currInfIdx == 2 || currInfIdx == 4)) ==>
    let start := HopfieldsStartIdx(currInfIdx, s) in
    let end := HopfieldsEndIdx(currInfIdx, s) in
    inf != none[io.AbsInfoField] &&
    len(hopfields) == end-start &&
	acc(sl.AbsSlice_Bytes(hopfields, 0, len(hopfields)), R49)
decreases
pure func MidSegWithInfo(
	hopfields []byte,
	currInfIdx int,
	s io.SegLens,
	inf option[io.AbsInfoField]) option[io.IO_seg3] {
	return (currInfIdx == 4 && s.SegLen[1] > 0 && s.SegLen[2] > 0) ?
			some(CurrSegWithInfo(hopfields, s.SegLen[0], s.SegLen[0], get(inf))) :
			(currInfIdx == 2 && s.SegLen[1] > 0 && s.SegLen[2] > 0) ?
				some(CurrSegWithInfo(hopfields, 0, s.SegLen[2], get(inf))) :
				none[io.IO_seg3]
}

// CurrSegEquality ensures that the two definitions of abstract segments, CurrSegWithInfo(..)
// and CurrSeg(..), represent the same abstract segment.
ghost
requires path.InfoFieldOffset(currInfIdx, MetaLen) + path.InfoLen <= offset
requires 0 < SegLen
requires offset + path.HopLen * SegLen <= len(raw)
requires 0 <= currHfIdx && currHfIdx <= SegLen
requires 0 <= currInfIdx && currInfIdx < 3
preserves acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R50)
preserves acc(sl.AbsSlice_Bytes(raw[offset:offset+SegLen*path.HopLen], 0, SegLen*path.HopLen), R50)
preserves acc(sl.AbsSlice_Bytes(InfofieldByteSlice(raw, currInfIdx), 0, path.InfoLen), R50)
ensures let inf := path.BytesToAbsInfoField(InfofieldByteSlice(raw, currInfIdx), 0) in
	CurrSegWithInfo(raw[offset:offset+SegLen*path.HopLen], currHfIdx, SegLen, inf) ==
	CurrSeg(raw, offset, currInfIdx, currHfIdx, SegLen, MetaLen)
decreases
func CurrSegEquality(raw []byte, offset int, currInfIdx int, currHfIdx int, SegLen int) {
    infoBytes := InfofieldByteSlice(raw, currInfIdx)
	inf := path.BytesToAbsInfoField(infoBytes, 0)
    infOffset := path.InfoFieldOffset(currInfIdx, MetaLen)
	unfold acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
	unfold acc(sl.AbsSlice_Bytes(infoBytes, 0, path.InfoLen), R56)
	assert reveal path.BytesToAbsInfoField(raw, infOffset) ==
        reveal path.BytesToAbsInfoField(infoBytes, 0)
	reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, SegLen, MetaLen)
	reveal CurrSegWithInfo(raw[offset:offset+SegLen*path.HopLen], currHfIdx, SegLen, inf)
	fold acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
	fold acc(sl.AbsSlice_Bytes(infoBytes, 0, path.InfoLen), R56)
	widenSegment(raw, offset, currHfIdx, inf.AInfo, inf.UInfo, inf.ConsDir,
        inf.Peer, SegLen, offset, offset+SegLen*path.HopLen)
}

// UpdateCurrSegInfo proves that updating the infofield from inf1 to inf2 does not alter the hopfields
// of the current segment.
ghost
requires 0 < SegLen
requires 0 <= currHfIdx && currHfIdx <= SegLen
requires SegLen*path.HopLen == len(raw)
preserves acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R50)
ensures CurrSegWithInfo(raw, currHfIdx, SegLen, inf1).UpdateCurrSeg(inf2) ==
	CurrSegWithInfo(raw, currHfIdx, SegLen, inf2)
decreases
func UpdateCurrSegInfo(raw []byte, currHfIdx int, SegLen int,
	inf1 io.AbsInfoField, inf2 io.AbsInfoField) {
	seg1 := reveal CurrSegWithInfo(raw, currHfIdx, SegLen, inf1)
	seg2 := reveal CurrSegWithInfo(raw, currHfIdx, SegLen, inf2)
}

ghost
requires s.Valid()
requires pktLen(s.SegLen[0], s.SegLen[1], s.SegLen[2], MetaLen) <= len(raw)
requires 1 <= currInfIdx && currInfIdx < 4
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R49)
requires (currInfIdx == 1 && s.SegLen[1] > 0) ||
    (currInfIdx == 2 && s.SegLen[1] > 0 && s.SegLen[2] > 0) ==>
    let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
    let hopBytes := HopfieldsByteSlice(raw, currInfIdx, s) in
	acc(sl.AbsSlice_Bytes(infoBytes, 0, path.InfoLen), R49) &&
	acc(sl.AbsSlice_Bytes(hopBytes, 0, len(hopBytes)), R49)
decreases
pure func LeftSegEqualitySpec(raw []byte, currInfIdx int, s io.SegLens) bool {
    return (currInfIdx == 1 && s.SegLen[1] > 0) || (currInfIdx == 2 && s.SegLen[1] > 0 && s.SegLen[2] > 0) ?
        let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
        let hopBytes := HopfieldsByteSlice(raw, currInfIdx, s) in
        let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
        LeftSeg(raw, currInfIdx, s.SegLen[0], s.SegLen[1], s.SegLen[2], MetaLen) ==
        LeftSegWithInfo(hopBytes, currInfIdx, s, inf) :
        LeftSeg(raw, currInfIdx, s.SegLen[0], s.SegLen[1], s.SegLen[2], MetaLen) ==
        LeftSegWithInfo(nil, currInfIdx, s, none[io.AbsInfoField])
}

// LeftSegEquality ensures that the two definitions of abstract segments, LeftSegWithInfo(..)
// and LeftSeg(..), represent the same abstract segment.
// The left segment corresponds to different segments of the packet depending on the currInfIdx.
// To address this, we need to consider all possible cases of currInfIdx. This results in fairly
// complex preconditions and postconditions because, for every currInfIdx, we need an offset for
// its infofield and one for its hopfields.
ghost
requires s.Valid()
requires pktLen(s.SegLen[0], s.SegLen[1], s.SegLen[2], MetaLen) <= len(raw)
requires 1 <= currInfIdx && currInfIdx < 4
preserves acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R49)
preserves (currInfIdx == 1 && s.SegLen[1] > 0) ||
    (currInfIdx == 2 && s.SegLen[1] > 0 && s.SegLen[2] > 0) ==>
    let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
    let hopBytes := HopfieldsByteSlice(raw, currInfIdx, s) in
	acc(sl.AbsSlice_Bytes(infoBytes, 0, path.InfoLen), R49) &&
	acc(sl.AbsSlice_Bytes(hopBytes, 0, len(hopBytes)), R49)
ensures LeftSegEqualitySpec(raw, currInfIdx, s)
decreases
func LeftSegEquality(raw []byte, currInfIdx int, s io.SegLens) {
	reveal LeftSeg(raw, currInfIdx, s.SegLen[0], s.SegLen[1], s.SegLen[2], MetaLen)
	if ((currInfIdx == 1 && s.SegLen[1] > 0) ||
        (currInfIdx == 2 && s.SegLen[1] > 0 && s.SegLen[2] > 0)) {
        infoBytes := InfofieldByteSlice(raw, currInfIdx)
        hopBytes := HopfieldsByteSlice(raw, currInfIdx, s)
		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
		offset := HopfieldsStartIdx(currInfIdx, s)
        segLen := currInfIdx == 1 ? s.SegLen[1] : s.SegLen[2]
		reveal LeftSegWithInfo(hopBytes, currInfIdx, s, inf)
		CurrSegEquality(raw, offset, currInfIdx, 0, segLen)
	} else {
		reveal LeftSegWithInfo(nil, currInfIdx, s, none[io.AbsInfoField])
	}
}

ghost
requires s.Valid()
requires pktLen(s.SegLen[0], s.SegLen[1], s.SegLen[2], MetaLen) <= len(raw)
requires -1 <= currInfIdx && currInfIdx < 2
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R49)
requires (currInfIdx == 0 && s.SegLen[1] > 0) ||
   (currInfIdx == 1 && s.SegLen[1] > 0 && s.SegLen[2] > 0) ==>
    let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
    let hopBytes := HopfieldsByteSlice(raw, currInfIdx, s) in
	acc(sl.AbsSlice_Bytes(infoBytes, 0, path.InfoLen), R49) &&
	acc(sl.AbsSlice_Bytes(hopBytes, 0, len(hopBytes)), R49)
decreases
pure func RightSegEqualitySpec(raw []byte, currInfIdx int, s io.SegLens) bool {
    return (currInfIdx == 0 && s.SegLen[1] > 0) ||
        (currInfIdx == 1 && s.SegLen[1] > 0 && s.SegLen[2] > 0) ?
        let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
        let hopBytes := HopfieldsByteSlice(raw, currInfIdx, s) in
        let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
        RightSeg(raw, currInfIdx, s.SegLen[0], s.SegLen[1], s.SegLen[2], MetaLen) ==
        RightSegWithInfo(hopBytes, currInfIdx, s, inf) :
        RightSeg(raw, currInfIdx, s.SegLen[0], s.SegLen[1], s.SegLen[2], MetaLen) ==
        RightSegWithInfo(nil, currInfIdx, s, none[io.AbsInfoField])
}

// RightSegEquality ensures that the two definitions of abstract segments, RightSegWithInfo(..)
// and RightSeg(..), represent the same abstract segment.
// The right segment corresponds to different segments of the packet depending on the currInfIdx.
// To address this, we need to consider all possible cases of currInfIdx. This results in fairly
// complex preconditions and postconditions because, for every currInfIdx, we need an offset for
// its infofield and one for its hopfields.
ghost
requires s.Valid()
requires pktLen(s.SegLen[0], s.SegLen[1], s.SegLen[2], MetaLen) <= len(raw)
requires -1 <= currInfIdx && currInfIdx < 2
preserves acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R49)
preserves (currInfIdx == 0 && s.SegLen[1] > 0) ||
   (currInfIdx == 1 && s.SegLen[1] > 0 && s.SegLen[2] > 0) ==>
    let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
    let hopBytes := HopfieldsByteSlice(raw, currInfIdx, s) in
	acc(sl.AbsSlice_Bytes(infoBytes, 0, path.InfoLen), R49) &&
	acc(sl.AbsSlice_Bytes(hopBytes, 0, len(hopBytes)), R49)
ensures RightSegEqualitySpec(raw, currInfIdx, s)
decreases
func RightSegEquality(raw []byte, currInfIdx int, s io.SegLens) {
	reveal RightSeg(raw, currInfIdx, s.SegLen[0], s.SegLen[1], s.SegLen[2], MetaLen)
	if ((currInfIdx == 0 && s.SegLen[1] > 0) ||
        (currInfIdx == 1 && s.SegLen[1] > 0 && s.SegLen[2] > 0)) {
        infoBytes := InfofieldByteSlice(raw, currInfIdx)
        hopBytes := HopfieldsByteSlice(raw, currInfIdx, s)
		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
		offset := HopfieldsStartIdx(currInfIdx, s)
        segLen := currInfIdx == 0 ? s.SegLen[0] : s.SegLen[1]
		reveal RightSegWithInfo(hopBytes, currInfIdx, s, inf)
		CurrSegEquality(raw, offset, currInfIdx, segLen, segLen)
	} else {
		reveal RightSegWithInfo(nil, currInfIdx, s, none[io.AbsInfoField])
	}
}

ghost
requires s.Valid()
requires pktLen(s.SegLen[0], s.SegLen[1], s.SegLen[2], MetaLen) <= len(raw)
requires 2 <= currInfIdx && currInfIdx < 5
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R49)
requires (s.SegLen[1] > 0 && s.SegLen[2] > 0 &&
    (currInfIdx == 2 || currInfIdx == 4)) ==>
    let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
    let hopBytes := HopfieldsByteSlice(raw, currInfIdx, s) in
	acc(sl.AbsSlice_Bytes(infoBytes, 0, path.InfoLen), R49) &&
	acc(sl.AbsSlice_Bytes(hopBytes, 0, len(hopBytes)), R49)
decreases
pure func MidSegEqualitySpec(raw []byte, currInfIdx int, s io.SegLens) bool {
    return (s.SegLen[1] > 0 && s.SegLen[2] > 0 &&
        (currInfIdx == 2 || currInfIdx == 4)) ?
        let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
        let hopBytes := HopfieldsByteSlice(raw, currInfIdx, s) in
        let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
        MidSeg(raw, currInfIdx, s.SegLen[0], s.SegLen[1], s.SegLen[2], MetaLen) ==
        MidSegWithInfo(hopBytes, currInfIdx, s, inf) :
        MidSeg(raw, currInfIdx, s.SegLen[0], s.SegLen[1], s.SegLen[2], MetaLen) ==
        MidSegWithInfo(nil, currInfIdx, s, none[io.AbsInfoField])
}

// MidSegEquality ensures that the two definitions of abstract segments, MidSegWithInfo(..)
// and MidSeg(..), represent the same abstract segment.
// The mid segment corresponds to different segments of the packet depending on the currInfIdx.
// To address this, we need to consider all possible cases of currInfIdx. This results in fairly
// complex preconditions and postconditions because, for every currInfIdx, we need an offset for
// its infofield and one for its hopfields.
ghost
requires s.Valid()
requires pktLen(s.SegLen[0], s.SegLen[1], s.SegLen[2], MetaLen) <= len(raw)
requires 2 <= currInfIdx && currInfIdx < 5
preserves acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R49)
preserves (s.SegLen[1] > 0 && s.SegLen[2] > 0 &&
    (currInfIdx == 2 || currInfIdx == 4)) ==>
    let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
    let hopBytes := HopfieldsByteSlice(raw, currInfIdx, s) in
	acc(sl.AbsSlice_Bytes(infoBytes, 0, path.InfoLen), R49) &&
	acc(sl.AbsSlice_Bytes(hopBytes, 0, len(hopBytes)), R49)
ensures MidSegEqualitySpec(raw, currInfIdx, s)
decreases
func MidSegEquality(raw []byte, currInfIdx int, s io.SegLens) {
	reveal MidSeg(raw, currInfIdx, s.SegLen[0], s.SegLen[1], s.SegLen[2], MetaLen)
	if (currInfIdx == 4 && s.SegLen[1] > 0 && s.SegLen[2] > 0) {
		infoBytes := InfofieldByteSlice(raw, 0)
        hopBytes := HopfieldsByteSlice(raw, 0, s)
		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
		offset := HopfieldsStartIdx(currInfIdx, s)
		reveal MidSegWithInfo(hopBytes, currInfIdx, s, inf)
		CurrSegEquality(raw, offset, 0, s.SegLen[0], s.SegLen[0])
	} else if (currInfIdx == 2 && s.SegLen[1] > 0 && s.SegLen[2] > 0) {
		infoBytes := InfofieldByteSlice(raw, currInfIdx)
        hopBytes := HopfieldsByteSlice(raw, currInfIdx, s)
		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
		offset := HopfieldsStartIdx(currInfIdx, s)
		reveal MidSegWithInfo(hopBytes, currInfIdx, s, inf)
		CurrSegEquality(raw, offset, currInfIdx, 0, s.SegLen[2])
	} else {
		reveal MidSegWithInfo(nil, currInfIdx, s, none[io.AbsInfoField])
	}
}