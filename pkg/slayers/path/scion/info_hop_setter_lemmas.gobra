// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package scion

import (
    "github.com/scionproto/scion/pkg/slayers/path"
    . "verification/utils/definitions"
    sl "verification/utils/slices"
    "verification/io"
)

/*** This file contains helpful lemmas for proving SetInfoField and SetHopfield. ***/
// Our abstract translation functions (CurrSeg, LeftSeg, RightSeg, MidSeg) are defined based on the
// entire byte slice of the concrete packet. This approach makes proving updates to the bytes very difficult.
// In this file, we introduce new translation functions that rely only on the hopfields byte slice and
// the infofield of a segment. We prove that these new functions are equivalent to the original ones
// and can be translated to each other. With these new functions, the proofs for SetInfoField and SetHopfield
// are greatly simplified.


// InfofieldByteSlice returns the byte slice of the infofield corresponding to the
// specified currInfIdx argument. Although a packet can have only three infofields,
// we use currInfIdx == 4 to represent the first infofield in our translation from
// concrete packets to abstract packets. This requires the special case that
// currInfIdx == 4 returns the same as currInfIdx == 0.
ghost
requires 0 <= currInfIdx
requires path.InfoFieldOffset(currInfIdx, MetaLen) + path.InfoLen <= len(raw)
decreases
pure func InfofieldByteSlice(raw []byte, currInfIdx int) ([]byte) {
    return let infOffset := currInfIdx == 4 ?
        path.InfoFieldOffset(0, MetaLen) :
        path.InfoFieldOffset(currInfIdx, MetaLen) in
        raw[infOffset:infOffset+path.InfoLen]
}

// HopfieldsStartIdx returns index of the first byte of the hopfields of a segment
// specified by the currInfIdx argument. Although a packet can have only three segments,
// we use currInfIdx == 4 to represent the first segment in our translation from
// concrete packets to abstract packets. This requires the special case that
// currInfIdx == 4 returns the same as currInfIdx == 0.
ghost
requires s.Valid()
requires 0 <= currInfIdx
decreases
pure func HopfieldsStartIdx(currInfIdx int, s io.SegLens) int {
    return let numInf := s.NumInfoFields() in
        let infOffset := path.InfoFieldOffset(numInf, MetaLen) in
        (currInfIdx == 0 || currInfIdx == 4) ? infOffset :
        currInfIdx == 1 ? infOffset+s.Seg1Len*path.HopLen :
        infOffset+(s.Seg1Len+s.Seg2Len)*path.HopLen
}

// HopfieldsStartIdx returns index of the last byte of the hopfields of a segment
// specified by the currInfIdx argument. Although a packet can have only three segments,
// we use currInfIdx == 4 to represent the first segment in our translation from
// concrete packets to abstract packets. This requires the special case that
// currInfIdx == 4 returns the same as currInfIdx == 0.
ghost
requires s.Valid()
requires 0 <= currInfIdx
decreases
pure func HopfieldsEndIdx(currInfIdx int, s io.SegLens) int {
    return let numInf := s.NumInfoFields() in
        let infOffset := path.InfoFieldOffset(numInf, MetaLen) in
        (currInfIdx == 0 || currInfIdx == 4) ? infOffset+s.Seg1Len*path.HopLen :
        currInfIdx == 1 ? infOffset+(s.Seg1Len+s.Seg2Len)*path.HopLen :
        infOffset+(s.Seg1Len+s.Seg2Len+s.Seg3Len)*path.HopLen
}

// HopfieldsStartIdx returns returns the byte slice of the hopfields of a segment
// specified by the currInfIdx argument. Although a packet can have only three segments,
// we use currInfIdx == 4 to represent the first segment in our translation from
// concrete packets to abstract packets. This requires the special case that
// currInfIdx == 4 returns the same as currInfIdx == 0.
ghost
requires s.Valid()
requires 0 <= currInfIdx
requires pktLen(s.Seg1Len, s.Seg2Len, s.Seg3Len, MetaLen) <= len(raw)
decreases
pure func HopfieldsByteSlice(raw []byte, currInfIdx int, s io.SegLens) ([]byte) {
    return let numInf := s.NumInfoFields() in
        let infOffset := path.InfoFieldOffset(numInf, MetaLen) in
        let start := HopfieldsStartIdx(currInfIdx, s) in
        let end := HopfieldsEndIdx(currInfIdx, s) in
        raw[start:end]
}

// SliceBytesIntoSegments splits the raw bytes of a packet into its hopfield segments
ghost
requires 0 < p
requires s.Valid()
requires pktLen(s.Seg1Len, s.Seg2Len, s.Seg3Len, MetaLen) <= len(raw)
requires acc(sl.Bytes(raw, 0, len(raw)), p)
ensures  acc(sl.Bytes(raw[:HopfieldsStartIdx(0, s)], 0, HopfieldsStartIdx(0, s)), p)
ensures  acc(sl.Bytes(HopfieldsByteSlice(raw, 0, s), 0, s.Seg1Len*path.HopLen), p)
ensures  acc(sl.Bytes(HopfieldsByteSlice(raw, 1, s), 0, s.Seg2Len*path.HopLen), p)
ensures  acc(sl.Bytes(HopfieldsByteSlice(raw, 2, s), 0, s.Seg3Len*path.HopLen), p)
ensures  acc(sl.Bytes(raw[HopfieldsEndIdx(2, s):], 0, len(raw[HopfieldsEndIdx(2, s):])), p)
decreases
func SliceBytesIntoSegments(raw []byte, s io.SegLens, p perm) {
    sl.SplitByIndex_Bytes(raw, 0, len(raw), HopfieldsStartIdx(0, s), p)
    sl.SplitByIndex_Bytes(raw, HopfieldsStartIdx(0, s), len(raw), HopfieldsEndIdx(0, s), p)
    sl.SplitByIndex_Bytes(raw, HopfieldsStartIdx(1, s), len(raw), HopfieldsEndIdx(1, s), p)
    sl.SplitByIndex_Bytes(raw, HopfieldsStartIdx(2, s), len(raw), HopfieldsEndIdx(2, s), p)
    sl.Reslice_Bytes(raw, 0, HopfieldsStartIdx(0, s), p)
    sl.Reslice_Bytes(raw, HopfieldsStartIdx(0, s), HopfieldsEndIdx(0, s), p)
    sl.Reslice_Bytes(raw, HopfieldsStartIdx(1, s), HopfieldsEndIdx(1, s), p)
    sl.Reslice_Bytes(raw, HopfieldsStartIdx(2, s), HopfieldsEndIdx(2, s), p)
    sl.Reslice_Bytes(raw, HopfieldsEndIdx(2, s), len(raw), p)
}

// CombineBytesFromSegments combines the three hopfield segments of a packet into a single slice of bytes.
ghost
requires 0 < p
requires s.Valid()
requires pktLen(s.Seg1Len, s.Seg2Len, s.Seg3Len, MetaLen) <= len(raw)
requires acc(sl.Bytes(raw[:HopfieldsStartIdx(0, s)], 0, HopfieldsStartIdx(0, s)), p)
requires acc(sl.Bytes(HopfieldsByteSlice(raw, 0, s), 0, s.Seg1Len*path.HopLen), p)
requires acc(sl.Bytes(HopfieldsByteSlice(raw, 1, s), 0, s.Seg2Len*path.HopLen), p)
requires acc(sl.Bytes(HopfieldsByteSlice(raw, 2, s), 0, s.Seg3Len*path.HopLen), p)
requires acc(sl.Bytes(raw[HopfieldsEndIdx(2, s):], 0, len(raw[HopfieldsEndIdx(2, s):])), p)
ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
decreases
func CombineBytesFromSegments(raw []byte, s io.SegLens, p perm) {
    sl.Unslice_Bytes(raw, HopfieldsEndIdx(2, s), len(raw), p)
    sl.Unslice_Bytes(raw, HopfieldsStartIdx(2, s), HopfieldsEndIdx(2, s), p)
    sl.Unslice_Bytes(raw, HopfieldsStartIdx(1, s), HopfieldsEndIdx(1, s), p)
    sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, s), HopfieldsEndIdx(0, s), p)
    sl.Unslice_Bytes(raw, 0, HopfieldsStartIdx(0, s), p)
    sl.CombineAtIndex_Bytes(raw, HopfieldsStartIdx(2, s), len(raw), HopfieldsEndIdx(2, s), p)
    sl.CombineAtIndex_Bytes(raw, HopfieldsStartIdx(1, s), len(raw), HopfieldsEndIdx(1, s), p)
    sl.CombineAtIndex_Bytes(raw, HopfieldsStartIdx(0, s), len(raw), HopfieldsEndIdx(0, s), p)
    sl.CombineAtIndex_Bytes(raw, 0, len(raw), HopfieldsStartIdx(0, s), p)
}

// SliceBytesIntoInfoFields splits the raw bytes of a packet into its infofields
ghost
requires 0 < p
requires s.Valid()
requires pktLen(s.Seg1Len, s.Seg2Len, s.Seg3Len, MetaLen) <= len(raw)
requires numInf == s.NumInfoFields()
requires acc(sl.Bytes(raw, 0, len(raw)), p)
ensures  acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
ensures  acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
ensures  1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
ensures  2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
ensures  acc(sl.Bytes(raw[HopfieldsStartIdx(0, s):], 0, len(raw[HopfieldsStartIdx(0, s):])), p)
decreases
func SliceBytesIntoInfoFields(raw []byte, numInf int, s io.SegLens, p perm) {
    sl.SplitByIndex_Bytes(raw, 0, len(raw), MetaLen, p)
    sl.SplitByIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
    sl.Reslice_Bytes(raw, 0, MetaLen, p)
    sl.Reslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
    if(numInf > 1) {
        sl.SplitByIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
            path.InfoFieldOffset(2, MetaLen), p)
        sl.Reslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
            path.InfoFieldOffset(2, MetaLen), p)
    }
    if(numInf > 2) {
        sl.SplitByIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
            HopfieldsStartIdx(0, s), p)
        sl.Reslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, s), p)
    }
    sl.Reslice_Bytes(raw, HopfieldsStartIdx(0, s), len(raw), p)
}

// CombineBytesFromInfoFields combines the infofields of a packet into a single slice of bytes.
ghost
requires 0 < p
requires s.Valid()
requires pktLen(s.Seg1Len, s.Seg2Len, s.Seg3Len, MetaLen) <= len(raw)
requires numInf == s.NumInfoFields()
requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, s):], 0, len(raw[HopfieldsStartIdx(0, s):])), p)
ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
decreases
func CombineBytesFromInfoFields(raw []byte, numInf int, s io.SegLens, p perm) {
    sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, s), len(raw), p)
    if(numInf > 2) {
        sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, s), p)
        sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
            HopfieldsStartIdx(0, s), p)
    }
    if(numInf > 1) {
        sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
            path.InfoFieldOffset(2, MetaLen), p)
        sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
            path.InfoFieldOffset(2, MetaLen), p)
    }
    sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
    sl.Unslice_Bytes(raw, 0, MetaLen, p)
    sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
    sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
}

// CurrSegWithInfo returns the abstract representation of the current segment of a packet.
// Unlike CurrSeg, it relies solely on the hopfield byte slice and an infofield instead of
// the entire raw bytes of the packet. This approach simplifies the verification of changes
// within a segment after updates to the packet's raw bytes.
ghost
opaque
requires 0 < SegLen
requires 0 <= currHfIdx && currHfIdx <= SegLen
requires SegLen*path.HopLen == len(hopfields)
requires acc(sl.Bytes(hopfields, 0, len(hopfields)), R56)
decreases
pure func CurrSegWithInfo(hopfields []byte, currHfIdx int, SegLen int, inf io.AbsInfoField) io.IO_seg3 {
    return segment(hopfields, 0, currHfIdx, inf.AInfo, inf.UInfo, inf.ConsDir, inf.Peer, SegLen)
}


// LeftSegWithInfo returns the abstract representation of the next segment of a packet.
// Unlike LeftSeg, it relies solely on the hopfields byte slice and an infofield instead of
// the entire bytes of the packet. Whenever the return value is not none, LeftSegWithInfo
// requires permissions to the hopfields byte slice of the segment specified by currInfIdx.
ghost
opaque
requires s.Valid()
requires (currInfIdx == 1 && s.Seg2Len > 0) ||
    (currInfIdx == 2 && s.Seg2Len > 0 && s.Seg3Len > 0) ==>
    let start := HopfieldsStartIdx(currInfIdx, s) in
    let end := HopfieldsEndIdx(currInfIdx, s) in
    inf != none[io.AbsInfoField] &&
    len(hopfields) == end-start &&
    acc(sl.Bytes(hopfields, 0, len(hopfields)), R49)
decreases
pure func LeftSegWithInfo(
    hopfields []byte,
    currInfIdx int,
    s io.SegLens,
    inf option[io.AbsInfoField]) option[io.IO_seg3] {
    return (currInfIdx == 1 && s.Seg2Len > 0) ?
            some(CurrSegWithInfo(hopfields, 0, s.Seg2Len, get(inf))) :
            (currInfIdx == 2 && s.Seg2Len > 0 && s.Seg3Len > 0) ?
                some(CurrSegWithInfo(hopfields, 0, s.Seg3Len, get(inf))) :
                none[io.IO_seg3]
}

// RightSegWithInfo returns the abstract representation of the previous segment of a packet.
// Unlike RightSeg, it relies solely on the hopfields byte slice and an infofield instead of
// the entire bytes of the packet. Whenever the return value is not none, RightSegWithInfo
// requires permissions to the hopfields byte slice of the segment specified by currInfIdx.
ghost
opaque
requires s.Valid()
requires (currInfIdx == 0 && s.Seg2Len > 0) ||
   (currInfIdx == 1 && s.Seg2Len > 0 && s.Seg3Len > 0) ==>
    let start := HopfieldsStartIdx(currInfIdx, s) in
    let end := HopfieldsEndIdx(currInfIdx, s) in
    inf != none[io.AbsInfoField] &&
    len(hopfields) == end-start &&
    acc(sl.Bytes(hopfields, 0, len(hopfields)), R49)
decreases
pure func RightSegWithInfo(
    hopfields []byte,
    currInfIdx int,
    s io.SegLens,
    inf option[io.AbsInfoField]) option[io.IO_seg3] {
    return (currInfIdx == 1 && s.Seg2Len > 0 && s.Seg3Len > 0) ?
            some(CurrSegWithInfo(hopfields, s.Seg2Len, s.Seg2Len, get(inf))) :
            (currInfIdx == 0 && s.Seg2Len > 0) ?
                some(CurrSegWithInfo(hopfields, s.Seg1Len, s.Seg1Len, get(inf))) :
                none[io.IO_seg3]
}

// MidSegWithInfo returns the abstract representation of the last or first segment of a packet.
// Unlike MidSeg, it relies solely on the hopfields byte slice and an infofield instead of
// the entire bytes of the packet. Whenever the return value is not none, MidSegWithInfo
// requires permissions to the hopfields byte slice of the segment specified by currInfIdx.
ghost
opaque
requires s.Valid()
requires (s.Seg2Len > 0 && s.Seg3Len > 0 &&
    (currInfIdx == 2 || currInfIdx == 4)) ==>
    let start := HopfieldsStartIdx(currInfIdx, s) in
    let end := HopfieldsEndIdx(currInfIdx, s) in
    inf != none[io.AbsInfoField] &&
    len(hopfields) == end-start &&
    acc(sl.Bytes(hopfields, 0, len(hopfields)), R49)
decreases
pure func MidSegWithInfo(
    hopfields []byte,
    currInfIdx int,
    s io.SegLens,
    inf option[io.AbsInfoField]) option[io.IO_seg3] {
    return (currInfIdx == 4 && s.Seg2Len > 0 && s.Seg3Len > 0) ?
            some(CurrSegWithInfo(hopfields, s.Seg1Len, s.Seg1Len, get(inf))) :
            (currInfIdx == 2 && s.Seg2Len > 0 && s.Seg3Len > 0) ?
                some(CurrSegWithInfo(hopfields, 0, s.Seg3Len, get(inf))) :
                none[io.IO_seg3]
}

// CurrSegEquality ensures that the two definitions of abstract segments, CurrSegWithInfo(..)
// and CurrSeg(..), represent the same abstract segment.
ghost
requires  path.InfoFieldOffset(currInfIdx, MetaLen) + path.InfoLen <= offset
requires  0 < SegLen
requires  offset + path.HopLen * SegLen <= len(raw)
requires  0 <= currHfIdx && currHfIdx <= SegLen
requires  0 <= currInfIdx && currInfIdx < 3
preserves acc(sl.Bytes(raw, 0, len(raw)), R50)
preserves acc(sl.Bytes(raw[offset:offset+SegLen*path.HopLen], 0, SegLen*path.HopLen), R50)
preserves acc(sl.Bytes(InfofieldByteSlice(raw, currInfIdx), 0, path.InfoLen), R50)
ensures let inf := path.BytesToAbsInfoField(InfofieldByteSlice(raw, currInfIdx), 0) in
    CurrSegWithInfo(raw[offset:offset+SegLen*path.HopLen], currHfIdx, SegLen, inf) ==
    CurrSeg(raw, offset, currInfIdx, currHfIdx, SegLen, MetaLen)
decreases
func CurrSegEquality(raw []byte, offset int, currInfIdx int, currHfIdx int, SegLen int) {
    infoBytes := InfofieldByteSlice(raw, currInfIdx)
    inf := path.BytesToAbsInfoField(infoBytes, 0)
    infOffset := path.InfoFieldOffset(currInfIdx, MetaLen)
    unfold acc(sl.Bytes(raw, 0, len(raw)), R56)
    unfold acc(sl.Bytes(infoBytes, 0, path.InfoLen), R56)
    assert reveal path.BytesToAbsInfoField(raw, infOffset) ==
        reveal path.BytesToAbsInfoField(infoBytes, 0)
    reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, SegLen, MetaLen)
    reveal CurrSegWithInfo(raw[offset:offset+SegLen*path.HopLen], currHfIdx, SegLen, inf)
    fold acc(sl.Bytes(raw, 0, len(raw)), R56)
    fold acc(sl.Bytes(infoBytes, 0, path.InfoLen), R56)
    widenSegment(raw, offset, currHfIdx, inf.AInfo, inf.UInfo, inf.ConsDir,
        inf.Peer, SegLen, offset, offset+SegLen*path.HopLen)
}

// UpdateCurrSegInfo proves that updating the infofield from inf1 to inf2 does not alter the hopfields
// of the current segment.
ghost
requires  0 < SegLen
requires  0 <= currHfIdx && currHfIdx <= SegLen
requires  SegLen*path.HopLen == len(raw)
preserves acc(sl.Bytes(raw, 0, len(raw)), R50)
ensures   CurrSegWithInfo(raw, currHfIdx, SegLen, inf1).UpdateCurrSeg(inf2) ==
    CurrSegWithInfo(raw, currHfIdx, SegLen, inf2)
decreases
func UpdateCurrSegInfo(raw []byte, currHfIdx int, SegLen int,
    inf1 io.AbsInfoField, inf2 io.AbsInfoField) {
    seg1 := reveal CurrSegWithInfo(raw, currHfIdx, SegLen, inf1)
    seg2 := reveal CurrSegWithInfo(raw, currHfIdx, SegLen, inf2)
}


// LeftSegEqualitySpec defines the conditions that must hold for LeftSegWithInfo(..)
// and LeftSeg(..) to represent the same abstract segment.
ghost
requires s.Valid()
requires pktLen(s.Seg1Len, s.Seg2Len, s.Seg3Len, MetaLen) <= len(raw)
requires 1 <= currInfIdx && currInfIdx < 4
requires acc(sl.Bytes(raw, 0, len(raw)), R49)
requires (currInfIdx == 1 && s.Seg2Len > 0) ||
    (currInfIdx == 2 && s.Seg2Len > 0 && s.Seg3Len > 0) ==>
    let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
    let hopBytes := HopfieldsByteSlice(raw, currInfIdx, s) in
    acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
    acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
decreases
pure func LeftSegEqualitySpec(raw []byte, currInfIdx int, s io.SegLens) bool {
    return (currInfIdx == 1 && s.Seg2Len > 0) ||
        (currInfIdx == 2 && s.Seg2Len > 0 && s.Seg3Len > 0) ?
        let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
        let hopBytes := HopfieldsByteSlice(raw, currInfIdx, s) in
        let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
        LeftSeg(raw, currInfIdx, s.Seg1Len, s.Seg2Len, s.Seg3Len, MetaLen) ==
        LeftSegWithInfo(hopBytes, currInfIdx, s, inf) :
        LeftSeg(raw, currInfIdx, s.Seg1Len, s.Seg2Len, s.Seg3Len, MetaLen) ==
        LeftSegWithInfo(nil, currInfIdx, s, none[io.AbsInfoField])
}

// LeftSegEquality ensures that the two definitions of abstract segments, LeftSegWithInfo(..)
// and LeftSeg(..), represent the same abstract segment.
// The left segment corresponds to different segments of the packet depending on the currInfIdx.
// To address this, we need to consider all possible cases of currInfIdx. This results in fairly
// complex preconditions and postconditions because, for every currInfIdx, we need an offset for
// its infofield and one for its hopfields.
ghost
requires  s.Valid()
requires  pktLen(s.Seg1Len, s.Seg2Len, s.Seg3Len, MetaLen) <= len(raw)
requires  1 <= currInfIdx && currInfIdx < 4
preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
preserves (currInfIdx == 1 && s.Seg2Len > 0) ||
    (currInfIdx == 2 && s.Seg2Len > 0 && s.Seg3Len > 0) ==>
    let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
    let hopBytes := HopfieldsByteSlice(raw, currInfIdx, s) in
    acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
    acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
ensures   LeftSegEqualitySpec(raw, currInfIdx, s)
decreases
func LeftSegEquality(raw []byte, currInfIdx int, s io.SegLens) {
    reveal LeftSeg(raw, currInfIdx, s.Seg1Len, s.Seg2Len, s.Seg3Len, MetaLen)
    if ((currInfIdx == 1 && s.Seg2Len > 0) ||
        (currInfIdx == 2 && s.Seg2Len > 0 && s.Seg3Len > 0)) {
        infoBytes := InfofieldByteSlice(raw, currInfIdx)
        hopBytes := HopfieldsByteSlice(raw, currInfIdx, s)
        inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
        offset := HopfieldsStartIdx(currInfIdx, s)
        segLen := currInfIdx == 1 ? s.Seg2Len : s.Seg3Len
        reveal LeftSegWithInfo(hopBytes, currInfIdx, s, inf)
        CurrSegEquality(raw, offset, currInfIdx, 0, segLen)
    } else {
        reveal LeftSegWithInfo(nil, currInfIdx, s, none[io.AbsInfoField])
    }
}

// RightSegEqualitySpec defines the conditions that must hold for RightSegWithInfo(..)
// and RightSeg(..) to represent the same abstract segment.
ghost
requires s.Valid()
requires pktLen(s.Seg1Len, s.Seg2Len, s.Seg3Len, MetaLen) <= len(raw)
requires -1 <= currInfIdx && currInfIdx < 2
requires acc(sl.Bytes(raw, 0, len(raw)), R49)
requires (currInfIdx == 0 && s.Seg2Len > 0) ||
   (currInfIdx == 1 && s.Seg2Len > 0 && s.Seg3Len > 0) ==>
    let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
    let hopBytes := HopfieldsByteSlice(raw, currInfIdx, s) in
    acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
    acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
decreases
pure func RightSegEqualitySpec(raw []byte, currInfIdx int, s io.SegLens) bool {
    return (currInfIdx == 0 && s.Seg2Len > 0) ||
        (currInfIdx == 1 && s.Seg2Len > 0 && s.Seg3Len > 0) ?
        let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
        let hopBytes := HopfieldsByteSlice(raw, currInfIdx, s) in
        let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
        RightSeg(raw, currInfIdx, s.Seg1Len, s.Seg2Len, s.Seg3Len, MetaLen) ==
        RightSegWithInfo(hopBytes, currInfIdx, s, inf) :
        RightSeg(raw, currInfIdx, s.Seg1Len, s.Seg2Len, s.Seg3Len, MetaLen) ==
        RightSegWithInfo(nil, currInfIdx, s, none[io.AbsInfoField])
}

// RightSegEquality ensures that the two definitions of abstract segments, RightSegWithInfo(..)
// and RightSeg(..), represent the same abstract segment.
// The right segment corresponds to different segments of the packet depending on the currInfIdx.
// To address this, we need to consider all possible cases of currInfIdx. This results in fairly
// complex preconditions and postconditions because, for every currInfIdx, we need an offset for
// its infofield and one for its hopfields.
ghost
requires  s.Valid()
requires  pktLen(s.Seg1Len, s.Seg2Len, s.Seg3Len, MetaLen) <= len(raw)
requires  -1 <= currInfIdx && currInfIdx < 2
preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
preserves (currInfIdx == 0 && s.Seg2Len > 0) ||
   (currInfIdx == 1 && s.Seg2Len > 0 && s.Seg3Len > 0) ==>
    let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
    let hopBytes := HopfieldsByteSlice(raw, currInfIdx, s) in
    acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
    acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
ensures   RightSegEqualitySpec(raw, currInfIdx, s)
decreases
func RightSegEquality(raw []byte, currInfIdx int, s io.SegLens) {
    reveal RightSeg(raw, currInfIdx, s.Seg1Len, s.Seg2Len, s.Seg3Len, MetaLen)
    if ((currInfIdx == 0 && s.Seg2Len > 0) ||
        (currInfIdx == 1 && s.Seg2Len > 0 && s.Seg3Len > 0)) {
        infoBytes := InfofieldByteSlice(raw, currInfIdx)
        hopBytes := HopfieldsByteSlice(raw, currInfIdx, s)
        inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
        offset := HopfieldsStartIdx(currInfIdx, s)
        segLen := currInfIdx == 0 ? s.Seg1Len : s.Seg2Len
        reveal RightSegWithInfo(hopBytes, currInfIdx, s, inf)
        CurrSegEquality(raw, offset, currInfIdx, segLen, segLen)
    } else {
        reveal RightSegWithInfo(nil, currInfIdx, s, none[io.AbsInfoField])
    }
}

// MidSegEqualitySpec defines the conditions that must hold for MidSegWithInfo(..)
// and MidSeg(..) to represent the same abstract segment.
ghost
requires s.Valid()
requires pktLen(s.Seg1Len, s.Seg2Len, s.Seg3Len, MetaLen) <= len(raw)
requires 2 <= currInfIdx && currInfIdx < 5
requires acc(sl.Bytes(raw, 0, len(raw)), R49)
requires (s.Seg2Len > 0 && s.Seg3Len > 0 &&
    (currInfIdx == 2 || currInfIdx == 4)) ==>
    let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
    let hopBytes := HopfieldsByteSlice(raw, currInfIdx, s) in
    acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
    acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
decreases
pure func MidSegEqualitySpec(raw []byte, currInfIdx int, s io.SegLens) bool {
    return (s.Seg2Len > 0 && s.Seg3Len > 0 &&
        (currInfIdx == 2 || currInfIdx == 4)) ?
        let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
        let hopBytes := HopfieldsByteSlice(raw, currInfIdx, s) in
        let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
        MidSeg(raw, currInfIdx, s.Seg1Len, s.Seg2Len, s.Seg3Len, MetaLen) ==
        MidSegWithInfo(hopBytes, currInfIdx, s, inf) :
        MidSeg(raw, currInfIdx, s.Seg1Len, s.Seg2Len, s.Seg3Len, MetaLen) ==
        MidSegWithInfo(nil, currInfIdx, s, none[io.AbsInfoField])
}

// MidSegEquality ensures that the two definitions of abstract segments, MidSegWithInfo(..)
// and MidSeg(..), represent the same abstract segment.
// The mid segment corresponds to different segments of the packet depending on the currInfIdx.
// To address this, we need to consider all possible cases of currInfIdx. This results in fairly
// complex preconditions and postconditions because, for every currInfIdx, we need an offset for
// its infofield and one for its hopfields.
ghost
requires  s.Valid()
requires  pktLen(s.Seg1Len, s.Seg2Len, s.Seg3Len, MetaLen) <= len(raw)
requires  2 <= currInfIdx && currInfIdx < 5
preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
preserves (s.Seg2Len > 0 && s.Seg3Len > 0 &&
    (currInfIdx == 2 || currInfIdx == 4)) ==>
    let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
    let hopBytes := HopfieldsByteSlice(raw, currInfIdx, s) in
    acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
    acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
ensures   MidSegEqualitySpec(raw, currInfIdx, s)
decreases
func MidSegEquality(raw []byte, currInfIdx int, s io.SegLens) {
    reveal MidSeg(raw, currInfIdx, s.Seg1Len, s.Seg2Len, s.Seg3Len, MetaLen)
    if (currInfIdx == 4 && s.Seg2Len > 0 && s.Seg3Len > 0) {
        infoBytes := InfofieldByteSlice(raw, 0)
        hopBytes := HopfieldsByteSlice(raw, 0, s)
        inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
        offset := HopfieldsStartIdx(currInfIdx, s)
        reveal MidSegWithInfo(hopBytes, currInfIdx, s, inf)
        CurrSegEquality(raw, offset, 0, s.Seg1Len, s.Seg1Len)
    } else if (currInfIdx == 2 && s.Seg2Len > 0 && s.Seg3Len > 0) {
        infoBytes := InfofieldByteSlice(raw, currInfIdx)
        hopBytes := HopfieldsByteSlice(raw, currInfIdx, s)
        inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
        offset := HopfieldsStartIdx(currInfIdx, s)
        reveal MidSegWithInfo(hopBytes, currInfIdx, s, inf)
        CurrSegEquality(raw, offset, currInfIdx, 0, s.Seg3Len)
    } else {
        reveal MidSegWithInfo(nil, currInfIdx, s, none[io.AbsInfoField])
    }
}