// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package path

import (
	"verification/io"
	"verification/utils/slices"
	"verification/dependencies/encoding/binary"
	. "verification/utils/definitions"
)

pred (h *HopField) Mem() {
	acc(h) && h.ConsIngress >= 0 && h.ConsEgress >= 0
}


ghost
decreases
pure func ifsToIO_ifs(ifs uint16) option[io.IO_ifs]{
	return ifs == 0 ? none[io.IO_ifs] : some(io.IO_ifs(ifs))
}

ghost
requires 0 <= start && start <= middle
requires middle + HopLen <= end && end <= len(raw)
requires acc(slices.AbsSlice_Bytes(raw, start, end), _)
decreases
pure func BytesToIO_HF(raw [] byte, start int, middle int, end int) (io.IO_HF) {
	return let _ := Asserting(forall k int :: {&raw[middle+2:middle+4][k]} 0 <= k && k < 2 ==> &raw[middle+2:middle+4][k] == &raw[middle + 2 + k]) in
		let _ := Asserting(forall k int :: {&raw[middle+4:middle+6][k]} 0 <= k && k < 4 ==> &raw[middle+4:middle+6][k] == &raw[middle + 4 + k]) in
		unfolding acc(slices.AbsSlice_Bytes(raw, start, end), _) in
		let inif2 := binary.BigEndian.Uint16(raw[middle+2:middle+4]) in
		let egif2 := binary.BigEndian.Uint16(raw[middle+4:middle+6]) in
		let op_inif2 := ifsToIO_ifs(inif2) in
		let op_egif2 := ifsToIO_ifs(egif2) in
		io.IO_HF(io.IO_HF_{
			InIF2 : op_inif2,
			EgIF2 : op_egif2,
			HVF : AbsMac(raw[6:6+MacLen]),
		})
}

ghost
decreases
pure func (h HopField) ToIO_HF() (io.IO_HF) {
	return io.IO_HF(io.IO_HF_{
			InIF2 : ifsToIO_ifs(h.ConsIngress),
			EgIF2 : ifsToIO_ifs(h.ConsEgress),
			HVF : AbsMac2(h.Mac),
		})
}

ghost
decreases
pure func AbsMac(mac []byte) (io.IO_msgterm)


ghost
decreases
pure func AbsMac2(mac [MacLen]byte) (io.IO_msgterm)


// Express that AbsMac and AbsMac2 return the same abstract mac with buffers of the same contents
ghost
requires forall i int :: { &mac1[i] } 0 <= i && i < MacLen ==> acc(&mac1[i], R47)
requires forall i int :: { &mac1[i] } 0 <= i && i < MacLen ==> mac1[i] == mac2[i]
ensures  forall i int :: { &mac1[i] } 0 <= i && i < MacLen ==> acc(&mac1[i], R47)
ensures  AbsMac(mac1) == AbsMac2(mac2)
decreases
func AbsMac_Lemma(mac1 []byte, mac2 [MacLen]byte)

ghost
opaque
requires 0 <= start && start <= middle
requires middle + HopLen <= end && end <= len(raw)
requires acc(slices.AbsSlice_Bytes(raw, start, end), R50)
requires h.Mem()
decreases
pure func (h *HopField) CorrectlyDecodedHF(raw []byte, start int, middle int, end int) bool {
	return unfolding h.Mem() in unfolding acc(slices.AbsSlice_Bytes(raw, start, end), R51) in BytesToIO_HF(raw, start, middle, end) == h.ToIO_HF()
}
