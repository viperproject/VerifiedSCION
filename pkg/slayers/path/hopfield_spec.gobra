// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package path

import (
	"verification/io"
	"verification/utils/slices"
	"verification/dependencies/encoding/binary"
	. "verification/utils/definitions"
)

pred (h *HopField) Mem() {
	acc(h) && h.ConsIngress >= 0 && h.ConsEgress >= 0
}


ghost
decreases
pure func ifsToIO_ifs(ifs uint16) option[io.IO_ifs]{
	return ifs == 0 ? none[io.IO_ifs] : some(io.IO_ifs(ifs))
}

ghost
requires 0 <= start && start <= middle
requires middle + HopLen <= end && end <= len(raw)
requires acc(slices.AbsSlice_Bytes(raw, start, end), _)
decreases
pure func BytesToIO_HF(raw [] byte, start int, middle int, end int) (io.IO_HF) {
	return let _ := Asserting(forall k int :: {&raw[middle+2:middle+4][k]} 0 <= k && k < 2 ==> &raw[middle+2:middle+4][k] == &raw[middle + 2 + k]) in
		let _ := Asserting(forall k int :: {&raw[middle+4:middle+6][k]} 0 <= k && k < 4 ==> &raw[middle+4:middle+6][k] == &raw[middle + 4 + k]) in
		let _ := Asserting(forall k int :: {&raw[middle+6:middle+6+MacLen][k]} 0 <= k && k < MacLen ==> &raw[middle+6:middle+6+MacLen][k] == &raw[middle + 6 + k]) in
		unfolding acc(slices.AbsSlice_Bytes(raw, start, end), _) in
		let inif2 := binary.BigEndian.Uint16(raw[middle+2:middle+4]) in
		let egif2 := binary.BigEndian.Uint16(raw[middle+4:middle+6]) in
		let op_inif2 := ifsToIO_ifs(inif2) in
		let op_egif2 := ifsToIO_ifs(egif2) in
		io.IO_HF(io.IO_HF_{
			InIF2 : op_inif2,
			EgIF2 : op_egif2,
			HVF : AbsMac(FromSliceToMacArray(raw[middle+6:middle+6+MacLen])),
		})
}

ghost
decreases
pure func (h HopField) ToIO_HF() (io.IO_HF) {
	return io.IO_HF(io.IO_HF_{
			InIF2 : ifsToIO_ifs(h.ConsIngress),
			EgIF2 : ifsToIO_ifs(h.ConsEgress),
			HVF : AbsMac(h.Mac),
		})
}

ghost
opaque
requires 0 <= start && start <= middle
requires middle + HopLen <= end && end <= len(raw)
requires acc(slices.AbsSlice_Bytes(raw, start, end), R50)
requires h.Mem()
decreases
pure func (h *HopField) CorrectlyDecodedHF(raw []byte, start int, middle int, end int) bool {
	return unfolding h.Mem() in unfolding acc(slices.AbsSlice_Bytes(raw, start, end), R51) in BytesToIO_HF(raw, start, middle, end) == h.ToIO_HF()
}

ghost
opaque
requires 0 <= start && start <= middle
requires middle + HopLen <= end && end <= len(raw)
requires acc(slices.AbsSlice_Bytes(raw, 0, len(raw)), R50)
decreases
pure func CorrectlyDecodedHF_FullBuf(h HopField, raw []byte, start int, middle int, end int) bool {
	return unfolding acc(slices.AbsSlice_Bytes(raw, 0, len(raw)), R51) in
	let hop := (let _ := Asserting(forall k int :: {&raw[middle+2:middle+4][k]} 0 <= k && k < 2 ==> &raw[middle+2:middle+4][k] == &raw[middle + 2 + k]) in
		let _ := Asserting(forall k int :: {&raw[middle+4:middle+6][k]} 0 <= k && k < 4 ==> &raw[middle+4:middle+6][k] == &raw[middle + 4 + k]) in
		let _ := Asserting(forall k int :: {&raw[middle+6:middle+6+MacLen][k]} 0 <= k && k < MacLen ==> &raw[middle+6:middle+6+MacLen][k] == &raw[middle + 6 + k]) in
		let inif2 := binary.BigEndian.Uint16(raw[middle+2:middle+4]) in
		let egif2 := binary.BigEndian.Uint16(raw[middle+4:middle+6]) in
		let op_inif2 := ifsToIO_ifs(inif2) in
		let op_egif2 := ifsToIO_ifs(egif2) in
		io.IO_HF(io.IO_HF_{
			InIF2 : op_inif2,
			EgIF2 : op_egif2,
			HVF : AbsMac(FromSliceToMacArray(raw[middle+6:middle+6+MacLen])),
		})) in
	hop == h.ToIO_HF()
}

ghost
requires  0 <= start && start <= middle
requires  middle + HopLen <= end && end <= slice_end-slice_start
requires  0 <= slice_start && slice_start < slice_end && slice_end <= len(raw)
requires  slice_start + HopLen <= slice_end
requires  acc(slices.AbsSlice_Bytes(raw[slice_start : slice_end], start, end), R45)
requires  acc(slices.AbsSlice_Bytes(raw, start+slice_start, end+slice_start), R45)
requires  h.Mem()
requires  h.CorrectlyDecodedHF(raw[slice_start : slice_end], start, middle, end)
ensures   acc(slices.AbsSlice_Bytes(raw[slice_start : slice_end], start, end), R45)
ensures   acc(slices.AbsSlice_Bytes(raw, start+slice_start, end+slice_start), R45)
ensures   h.Mem()
ensures   h.CorrectlyDecodedHF(raw, start+slice_start, middle+slice_start, end+slice_start)
decreases
func (h *HopField) CorrectlyDecodedHF_Lemma(raw []byte, slice_start int, slice_end int, start int, middle int, end int) bool {
	assert reveal h.CorrectlyDecodedHF(raw[slice_start : slice_end], start, middle, end)
	unfold acc(slices.AbsSlice_Bytes(raw[slice_start : slice_end], start, end), R46)
	unfold acc(slices.AbsSlice_Bytes(raw, start+slice_start, end+slice_start), R46)
	assert BytesToIO_HF(raw[slice_start : slice_end], start, middle, end) == BytesToIO_HF(raw, start+slice_start, middle+slice_start, end+slice_start)
	assert reveal h.CorrectlyDecodedHF(raw, start+slice_start, middle+slice_start, end+slice_start)
	fold acc(slices.AbsSlice_Bytes(raw[slice_start : slice_end], start, end), R46)
	fold acc(slices.AbsSlice_Bytes(raw, start+slice_start, end+slice_start), R46)
}

ghost
requires  0 <= start && start <= middle
requires  middle + HopLen <= end && end <= len(raw)
requires  acc(slices.AbsSlice_Bytes(ubuf, 0, len(ubuf)), R45)
requires  acc(slices.AbsSlice_Bytes(raw, start, end), R45)
requires  h.Mem()
requires  len(ubuf) >= len(raw)
requires  raw === ubuf[:len(raw)]
requires  h.CorrectlyDecodedHF(raw, start, middle, end)
ensures   acc(slices.AbsSlice_Bytes(raw, start, end), R45)
ensures   acc(slices.AbsSlice_Bytes(ubuf, 0, len(ubuf)), R45)
ensures   h.Mem()
ensures   CorrectlyDecodedHF_FullBuf(unfolding h.Mem() in *h, ubuf, start, middle, end)
decreases
func (h *HopField) CorrectlyDecodedHF_WidenLemma(raw []byte, start int, middle int, end int, ubuf []byte) bool {
	assert reveal h.CorrectlyDecodedHF(raw, start, middle, end)
	assert (unfolding h.Mem() in h.ToIO_HF()) == (unfolding h.Mem() in *h).ToIO_HF()
	assert forall i int :: { &ubuf[i] } 0 <= i && i < len(raw) ==> raw[i] == ubuf[i]
	assert reveal CorrectlyDecodedHF_FullBuf(unfolding h.Mem() in *h, ubuf, start, middle, end)
}
