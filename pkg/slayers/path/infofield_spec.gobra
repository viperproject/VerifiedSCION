// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package path

import (
	"verification/io"
	sl "verification/utils/slices"
	"verification/dependencies/encoding/binary"
	. "verification/utils/definitions"
)

ghost const MetaLen = 4

ghost
decreases
pure func InfoFieldOffset(currINF, headerOffset int) int {
	return headerOffset + MetaLen + InfoLen * currINF
}

ghost
requires 0 <= currINF && 0 <= headerOffset
requires InfoFieldOffset(currINF, headerOffset) < len(raw)
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func ConsDir(raw []byte, currINF int, headerOffset int) bool {
	return unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56) in
		raw[InfoFieldOffset(currINF, headerOffset)] & 0x1 == 0x1
}

ghost
requires 0 <= currINF && 0 <= headerOffset
requires InfoFieldOffset(currINF, headerOffset) < len(raw)
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func Peer(raw []byte, currINF int, headerOffset int) bool {
	return unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56) in
		raw[InfoFieldOffset(currINF, headerOffset)] & 0x2 == 0x2
}

ghost
requires 0 <= currINF && 0 <= headerOffset
requires InfoFieldOffset(currINF, headerOffset) + InfoLen < len(raw)
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func Timestamp(raw []byte, currINF int, headerOffset int) io.IO_ainfo {
	return let idx := InfoFieldOffset(currINF, headerOffset) + 4 in
		unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56) in
		let _ := Asserting(forall i int :: { &raw[idx+i] } { &raw[idx:idx+4][i] } 0 <= i && i < 4 ==>
			&raw[idx+i] == &raw[idx:idx+4][i]) in
		io.IO_ainfo(binary.BigEndian.Uint32(raw[idx : idx + 4]))
}

ghost
requires 0 <= currINF && 0 <= headerOffset
requires InfoFieldOffset(currINF, headerOffset) + InfoLen < len(raw)
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func AbsUinfo(raw []byte, currINF int, headerOffset int) set[io.IO_msgterm] {
	return 	let idx := InfoFieldOffset(currINF, headerOffset) + 2 in
		unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56) in
		let _ := Asserting(forall k int :: {&raw[idx:idx+2][k]} 0 <= k && k < 2 ==>
			&raw[idx:idx+4][k] == &raw[idx + k]) in
		absUinfo_(binary.BigEndian.Uint16(raw[idx:idx+2]))
}

ghost
decreases
pure func absUinfo_(SegID uint16) set[io.IO_msgterm]

// intermediate type, not in IO-spec
type IntermediateAbsInfoField adt {
	IntermediateAbsInfoField_ {
		AInfo io.IO_ainfo
		UInfo set[io.IO_msgterm]
		ConsDir bool
		Peer bool
	}
}

ghost
requires 0 <= start && start <= middle
requires middle+InfoLen <= end && end <= len(raw)
requires acc(sl.AbsSlice_Bytes(raw, start, end), _)
decreases
pure func BytesToIntermediateAbsInfoField(raw [] byte, start int, middle int, end int) (IntermediateAbsInfoField) {
	return unfolding acc(sl.AbsSlice_Bytes(raw, start, end), _) in
		let _ := Asserting(forall k int :: {&raw[middle+2:middle+4][k]} 0 <= k && k < 2 ==> &raw[middle+2:middle+4][k] == &raw[middle+2 + k]) in
		let _ := Asserting(forall k int :: {&raw[middle+4:middle+8][k]} 0 <= k && k < 4 ==> &raw[middle+4:middle+8][k] == &raw[middle+4 + k]) in
		IntermediateAbsInfoField(IntermediateAbsInfoField_{
			AInfo : io.IO_ainfo(binary.BigEndian.Uint32(raw[middle+4:middle+8])),
			UInfo : absUinfo_(binary.BigEndian.Uint16(raw[middle+2:middle+4])),
			ConsDir : raw[middle] & 0x1 == 0x1,
			Peer : raw[middle] & 0x2  == 0x2,
		})
}

ghost
requires acc(inf, _)
decreases
pure func (inf *InfoField) ToIntermediateAbsInfoField() (IntermediateAbsInfoField) {
	return IntermediateAbsInfoField(IntermediateAbsInfoField_{
		AInfo : io.IO_ainfo(inf.Timestamp),
		UInfo : absUinfo_(inf.SegID),
		ConsDir : inf.ConsDir,
		Peer : inf.Peer,
	})
}

ghost
decreases
pure func (inf InfoField) ToIntermediateAbsInfoField2() (IntermediateAbsInfoField) {
	return IntermediateAbsInfoField(IntermediateAbsInfoField_{
		AInfo : io.IO_ainfo(inf.Timestamp),
		UInfo : absUinfo_(inf.SegID),
		ConsDir : inf.ConsDir,
		Peer : inf.Peer,
	})
}