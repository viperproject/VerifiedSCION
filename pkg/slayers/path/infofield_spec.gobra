// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package path

import (
	"verification/io"
	sl "verification/utils/slices"
	"verification/dependencies/encoding/binary"
	. "verification/utils/definitions"
)

ghost const MetaLen = 4

ghost
decreases
pure func InfoFieldOffset(currINF, headerOffset int) int {
	return headerOffset + MetaLen + InfoLen * currINF
}

ghost
requires 0 <= currINF && 0 <= headerOffset
requires InfoFieldOffset(currINF, headerOffset) < len(raw)
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func ConsDir(raw []byte, currINF int, headerOffset int) bool {
	return unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56) in
		ConsDirHelper(raw, currINF, headerOffset)
}

ghost
requires 0 <= currINF && 0 <= headerOffset
requires InfoFieldOffset(currINF, headerOffset) < len(raw)
requires acc(&raw[InfoFieldOffset(currINF, headerOffset)], R56)
decreases
pure func ConsDirHelper(raw []byte, currINF int, headerOffset int) bool {
	return raw[InfoFieldOffset(currINF, headerOffset)] & 0x1 == 0x1
}

ghost
requires 0 <= currINF && 0 <= headerOffset
requires InfoFieldOffset(currINF, headerOffset) < len(raw)
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func Peer(raw []byte, currINF int, headerOffset int) bool {
	return unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56) in
		PeerHelper(raw, currINF, headerOffset)
}

ghost
requires 0 <= currINF && 0 <= headerOffset
requires InfoFieldOffset(currINF, headerOffset) < len(raw)
requires acc(&raw[InfoFieldOffset(currINF, headerOffset)], R56)
decreases
pure func PeerHelper(raw []byte, currINF int, headerOffset int) bool {
	return raw[InfoFieldOffset(currINF, headerOffset)] & 0x2 == 0x2
}

ghost
requires 0 <= currINF && 0 <= headerOffset
requires InfoFieldOffset(currINF, headerOffset) + InfoLen < len(raw)
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func Timestamp(raw []byte, currINF int, headerOffset int) io.IO_ainfo {
	return unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56) in
		TimestampHelper(raw, currINF, headerOffset)
}

ghost
requires 0 <= currINF && 0 <= headerOffset
requires InfoFieldOffset(currINF, headerOffset) + InfoLen < len(raw)
requires let idx := InfoFieldOffset(currINF, headerOffset)+4 in
	forall i int :: { &raw[i] } idx <= i && i < idx+4 ==> acc(&raw[i], R56)
decreases
pure func TimestampHelper(raw []byte, currINF int, headerOffset int) io.IO_ainfo {
	return let idx := InfoFieldOffset(currINF, headerOffset)+4 in
		// ---- triggering terms ----
		let _ := Asserting(&raw[idx]   == &raw[idx:idx+4][0]) in
		let _ := Asserting(&raw[idx+1] == &raw[idx:idx+4][1]) in
		let _ := Asserting(&raw[idx+2] == &raw[idx:idx+4][2]) in
		let _ := Asserting(&raw[idx+3] == &raw[idx:idx+4][3]) in
		// ---- end of triggering terms ----
		io.IO_ainfo(binary.BigEndian.Uint32(raw[idx:idx+4]))
}

ghost
requires 0 <= currINF && 0 <= headerOffset
requires InfoFieldOffset(currINF, headerOffset) + InfoLen < len(raw)
requires acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56)
decreases
pure func AbsUinfo(raw []byte, currINF int, headerOffset int) set[io.IO_msgterm] {
	return unfolding acc(sl.AbsSlice_Bytes(raw, 0, len(raw)), R56) in
		AbsUinfoHelper(raw, currINF, headerOffset)
}

ghost
requires 0 <= currINF && 0 <= headerOffset
requires InfoFieldOffset(currINF, headerOffset) + InfoLen < len(raw)
requires let idx := InfoFieldOffset(currINF, headerOffset) + 2 in
	forall i int :: { &raw[i] } idx <= i && i < idx+2 ==> acc(&raw[i], R56)
decreases
pure func AbsUinfoHelper(raw []byte, currINF int, headerOffset int) set[io.IO_msgterm] {
	return let idx := InfoFieldOffset(currINF, headerOffset) + 2 in
		let _ := Asserting(forall k int :: {&raw[idx:idx+2][k]} 0 <= k && k < 2 ==>
			&raw[idx:idx+4][k] == &raw[idx + k]) in
		AbsUInfoFromUint16(binary.BigEndian.Uint16(raw[idx:idx+2]))
}

// This type simplifies the infoField, making it easier
// to use than the IO_seg3 from the IO-spec.
type IntermediateAbsInfoField adt {
	IntermediateAbsInfoField_ {
		AInfo io.IO_ainfo
		UInfo set[io.IO_msgterm]
		ConsDir bool
		Peer bool
	}
}

ghost
requires 0 <= start && start <= middle
requires middle+InfoLen <= end && end <= len(raw)
requires acc(sl.AbsSlice_Bytes(raw, start, end), _)
decreases
pure func BytesToIntermediateAbsInfoField(raw [] byte, start int, middle int, end int) (IntermediateAbsInfoField) {
	return unfolding acc(sl.AbsSlice_Bytes(raw, start, end), _) in
		BytesToIntermediateAbsInfoFieldHelper(raw, middle, end)
}

ghost
requires 0 <= middle
requires middle+InfoLen <= end && end <= len(raw)
requires forall i int :: { &raw[i] } middle <= i && i < end ==>
	acc(&raw[i], _)
decreases
pure func BytesToIntermediateAbsInfoFieldHelper(raw [] byte, middle int, end int) (IntermediateAbsInfoField) {
	return let _ := Asserting(forall k int :: {&raw[middle+2:middle+4][k]} 0 <= k && k < 2 ==> &raw[middle+2:middle+4][k] == &raw[middle+2 + k]) in
		let _ := Asserting(forall k int :: {&raw[middle+4:middle+8][k]} 0 <= k && k < 4 ==> &raw[middle+4:middle+8][k] == &raw[middle+4 + k]) in
		IntermediateAbsInfoField(IntermediateAbsInfoField_{
			AInfo : io.IO_ainfo(binary.BigEndian.Uint32(raw[middle+4:middle+8])),
			UInfo : AbsUInfoFromUint16(binary.BigEndian.Uint16(raw[middle+2:middle+4])),
			ConsDir : raw[middle] & 0x1 == 0x1,
			Peer : raw[middle] & 0x2  == 0x2,
		})
}

ghost
decreases
pure func (inf InfoField) ToIntermediateAbsInfoField() (IntermediateAbsInfoField) {
	return IntermediateAbsInfoField(IntermediateAbsInfoField_{
		AInfo : io.IO_ainfo(inf.Timestamp),
		UInfo : AbsUInfoFromUint16(inf.SegID),
		ConsDir : inf.ConsDir,
		Peer : inf.Peer,
	})
}