// Copyright 2020 Anapaya Systems
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package path

import (
	"verification/io"
	. "github.com/scionproto/scion/verification/utils/definitions"
)

// At the moment, we assume that all cryptographic operations performed at the code level
// imply the desired properties at the IO spec level because we cannot currently prove in
// Gobra the correctness of these operations. Given that we do not prove any properties
// about this function, we currently do not provide a definition for it.

ghost
decreases
pure func AbsUInfoFromUint16(SegID uint16) set[io.IO_msgterm]

ghost
ensures len(res) == MacLen
ensures forall i int :: { mac[i] } 0 <= i && i < MacLen ==> res[i] == mac[i]
decreases
pure func macSequence(mac [MacLen]byte) (res seq[byte])

ghost
requires len(mac) == MacLen
decreases
pure func absMac_Internal(mac seq[byte]) (io.IO_msgterm)

ghost
opaque
decreases
pure func AbsMac(mac [MacLen]byte) (io.IO_msgterm) {
	return absMac_Internal(macSequence(mac))
}

// The following function converts a slice with at least `MacLen` elements into
// an (exclusive) array containing the mac. Note that there are no permissions
// involved for accessing exclusive arrays. This functions is abstract for now
// because Gobra does not allow for array literals in pure functions, even though
// they are no more side-effectful than creating an instance of a struct type.
// This will soon be fixed in Gobra.
ghost
requires MacLen <= len(mac)
requires forall i int :: { &mac[i] } 0 <= i && i < MacLen ==> acc(&mac[i], _)
ensures  len(res) == MacLen
ensures  forall i int :: { res[i] } 0 <= i && i < MacLen ==> mac[i] == res[i]
decreases
pure func FromSliceToMacArray(mac []byte) (res [MacLen]byte)


ghost
requires len(mac1) == MacLen
requires forall i int :: { &mac1[i] } 0 <= i && i < MacLen ==> acc(&mac1[i], R50)
requires forall i int :: { &mac1[i] } 0 <= i && i < MacLen ==> mac1[i] == mac2[i]
ensures  forall i int :: { &mac1[i] } 0 <= i && i < MacLen ==> acc(&mac1[i], R50)
ensures  AbsMac(FromSliceToMacArray(mac1)) == AbsMac(mac2)
decreases
func AbsMac_Lemma(mac1 []byte, mac2 [MacLen]byte) {
	mac1a := FromSliceToMacArray(mac1)
	assert forall i int :: { mac2[i] } 0 <= i && i < MacLen ==> mac1a[i] == mac2[i]
	assert len(mac1a) == len(mac2)
	assert len(mac1a) == 6
	mac1s := macSequence(mac1a)
	mac2s := macSequence(mac2)
	assert forall i int :: { mac1s[i] } 0 <= i && i < MacLen ==> mac1s[i] == mac1a[i]
	assert forall i int :: { mac1s[i] } 0 <= i && i < MacLen ==> mac2s[i] == mac2[i]
	assert macSequence(FromSliceToMacArray(mac1)) == macSequence(mac2)
	assert reveal AbsMac(FromSliceToMacArray(mac1)) == reveal AbsMac(mac2)
}