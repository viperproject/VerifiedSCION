// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package slayers

import (
	"github.com/google/gopacket"

	"github.com/scionproto/scion/pkg/slayers/path"
	"github.com/scionproto/scion/verification/utils/slices"
)

type PathMemLoc uint8

const (
	New PathMemLoc = iota
	Pool
	Raw
)

pred (b *BaseLayer) Mem() {
	acc(b) &&
	slices.AbsSlice_Bytes(b.Contents, 0, len(b.Contents)) &&
	slices.AbsSlice_Bytes(b.Payload, 0, len(b.Payload))
}

pred (b *BaseLayer) LayerMem() {
	acc(b) && slices.AbsSlice_Bytes(b.Contents, 0, len(b.Contents))
}

pred (b *BaseLayer) PayloadMem() {
	acc(b) && slices.AbsSlice_Bytes(b.Payload, 0, len(b.Payload))
}

pred (s *SCION) LayerMem() {
	true
}

pred (s *SCION) PayloadMem() {
	true
}

pred (s *SCION) NonInitMem() {
	acc(s) &&
		(s.pathPool == nil ==> s.pathPoolRaw == nil) &&
		(s.pathPool != nil ==> s.pathPoolRaw != nil && s.pathPoolRaw.NonInitMem()) &&
		(s.pathPool != nil ==> (forall i int :: 0 <= i && i < len(s.pathPool) ==>
			(acc(&s.pathPool[i]) && s.pathPool[i] != nil && s.pathPool[i].NonInitMem())))
}

pred (s *SCION) LenMem() {
	acc(&s.HdrLen) &&
		acc(&s.PayloadLen)
}

pred (s *SCION) Mem() {
	// TODO (gavinleroy) this is a ghost field and should
	// be treated as one.
	acc(&s.pathMemLoc) && isValidPathMemLoc(s.pathMemLoc) &&
		acc(&s.hdrBytes) &&
		// 0 <= s.hdrBytes && s.hdrBytes < len(s.GetUnderlyingBuf()) &&
	// ---

			acc(&s.Contents) &&
			acc(&s.Payload) &&
			acc(&s.Version) &&
			acc(&s.TrafficClass) &&
			acc(&s.FlowID) &&
			acc(&s.NextHdr) &&
			acc(&s.HdrLen) &&
			acc(&s.PayloadLen) &&
			acc(&s.PathType) &&
			acc(&s.DstAddrType) &&
			acc(&s.DstAddrLen) &&
			acc(&s.SrcAddrType) &&
			acc(&s.SrcAddrLen) &&
			acc(&s.DstIA) &&
			acc(&s.SrcIA) &&
			acc(&s.RawDstAddr) &&
			acc(&s.RawSrcAddr) &&
			slices.AbsSlice_Bytes(s.RawDstAddr, 0, len(s.RawDstAddr)) &&
			slices.AbsSlice_Bytes(s.RawSrcAddr, 0, len(s.RawSrcAddr)) &&

			// Mem ensures we have Mem resources for Path, this could be
			// borrowed from the s.pathPool / s.pathPoolRaw as indicated
			// by the memory location demonstrated below.
			acc(&s.Path) && s.Path != nil && s.Path.Mem() &&
			(s.pathMemLoc == New ==> s.PathPoolNone()) &&
			(s.pathMemLoc == Raw ==> s.PathPoolFull() && s.PathPoolRawPartial(s.Path)) &&
			(s.pathMemLoc == Pool ==> s.PathPoolPartial(s.Path, s.PathType) && s.PathPoolRawFull()) &&

			// Well-formedness for values
			s.DstAddrLen >= 0 &&
			s.SrcAddrLen >= 0

			// s.Contents == s.GetUnderlyingBuf()[:s.hdrBytes] &&
			// s.Payload == s.GetUnderlyingBuf()[s.hdrBytes:]
}

pred (s *SCION) AddrHdrInitMem() {
		acc(&s.RawDstAddr) &&
		acc(&s.RawSrcAddr) &&
		acc(&s.DstAddrLen) &&
		acc(&s.SrcAddrLen) &&
		acc(&s.DstIA) &&
		acc(&s.SrcIA) &&
		s.DstAddrLen >= 0 &&
		s.SrcAddrLen >= 0
}

pred (s *SCION) AddrHdrMem() {
		acc(&s.RawDstAddr) &&
		acc(&s.RawSrcAddr) &&
		acc(&s.DstAddrLen) &&
		acc(&s.SrcAddrLen) &&
		acc(&s.DstIA) &&
		acc(&s.SrcIA) &&
		slices.AbsSlice_Bytes(s.RawDstAddr, 0, len(s.RawDstAddr)) &&
		slices.AbsSlice_Bytes(s.RawSrcAddr, 0, len(s.RawSrcAddr)) &&
		s.DstAddrLen >= 0 &&
		s.SrcAddrLen >= 0
}

pred (s *SCION) PathMem() {
	acc(&s.Path) && s.Path != nil && s.Path.Mem()
}

// Indicates that paths should be recycled and full permissions are
// held to each location in the path pool.
pred (s *SCION) PathPoolFull() {
	acc(&s.pathPool) &&
		s.pathPool != nil &&
		(forall i int :: 0 <= i && i < len(s.pathPool) ==>
			(acc(&s.pathPool[i]) && s.pathPool[i] != nil && s.pathPool[i].NonInitMem()))
}

// Indicates that paths should be recycled and the current s.Path is
// aliasing location `pathType` in the pool.
pred (s *SCION) PathPoolPartial(aliasedPath path.Path, pathType path.Type) {
	acc(&s.pathPool) &&
		s.pathPool != nil &&
		0 <= int(pathType) && int(pathType) < len(s.pathPool) &&
		(forall i int :: (0 <= i && i < len(s.pathPool)) ==>
			(acc(&s.pathPool[i]) && s.pathPool[i] != nil &&
				((i == int(pathType) ==> s.pathPool[i] === aliasedPath) &&
					(i != int(pathType) ==> (s.pathPool[i] !== aliasedPath && s.pathPool[i].NonInitMem())))))
}

// Indicates that RecyclePaths was not called and the path pool is nil.
pred (s *SCION) PathPoolNone() {
	acc(&s.pathPool) && acc(&s.pathPoolRaw) &&
		s.pathPool == nil && s.pathPoolRaw == nil
}

// Indicates that paths should be Recycled and full permissions are held
// to the Raw version of the path pool.
pred (s *SCION) PathPoolRawFull() {
	acc(&s.pathPoolRaw) && s.pathPoolRaw != nil && s.pathPoolRaw.NonInitMem()
}

// Indicates that paths should be recycled and the current s.Path is
// aliasing the s.pathPoolRaw field.
pred (s *SCION) PathPoolRawPartial(aliasingPath path.Path) {
	acc(&s.pathPoolRaw) &&
		s.pathPoolRaw != nil &&
		aliasingPath === s.pathPoolRaw
}

// TODO SCION must implement the following interfaces
// - gopacket.NetworkLayer
// - gopacket.DecodingLayer
// - gopacket.SerializingLayer

// (*SCION) implements gopacket.DecodingLayer
// (*SCION) implements gopacket.NetworkLayer

// NOTE (gavinleroy) Methods for exchanging Mem access for a
// subset of the predicate. These are useful when unfoldings
// are required, but you don't want to refold the whole predicate.
ghost
requires s.Mem()
requires s.GetUnderlyingBuf() === buf
ensures  slices.AbsSlice_Bytes(buf, 0, len(buf))
ensures  slices.AbsSlice_Bytes(buf, 0, len(buf)) --* s.Mem()
decreases
func (s *SCION) ExchangeMemBuf(buf []byte)

ghost
requires s.Mem()
ensures  s.LenMem()
ensures  s.LenMem() --* s.Mem()
decreases
func (s *SCION) ExchangeLenMem() {
	unfold s.Mem()
	fold s.LenMem()
	package s.LenMem() --* s.Mem() {
		unfold s.LenMem()
		fold s.Mem()
	}
}

ghost
requires 0 <= p && p <= writePerm
requires acc(s.Mem(), p)
ensures  acc(s.AddrHdrMem(), p)
ensures  acc(s.AddrHdrMem(), p) --* acc(s.Mem(), p)
decreases
func (s *SCION) ExchangeAddrHdrMem(p perm) {
	unfold acc(s.Mem(), p)
	fold acc(s.AddrHdrMem(), p)
	package acc(s.AddrHdrMem(), p) --* acc(s.Mem(), p) {
		unfold acc(s.AddrHdrMem(), p)
		fold acc(s.Mem(), p)
	}
}

ghost
requires s.Mem()
ensures  s.PathMem()
ensures  s.PathMem() --* s.Mem()
decreases
func (s *SCION) ExchangePathMem() {
	unfold s.Mem()
	fold s.PathMem()
	package s.PathMem() --* s.Mem() {
		unfold s.PathMem()
		fold s.Mem()
	}
}

ghost
requires acc(s.Mem(), _)
decreases
pure func (s *SCION) GetUnderlyingBuf() (buf []byte)

ghost
preserves s.Mem()
ensures   s.GetUnderlyingBuf() === buf
decreases
func (s *SCION) SetUnderlyingBuf(buf []byte)

ghost
requires acc(&s.pathMemLoc, _)
decreases
pure func (s *SCION) getPathLoc() PathMemLoc {
	return s.pathMemLoc
}

ghost
requires  isValidPathMemLoc(l)
preserves acc(&s.pathMemLoc)
ensures   s.getPathLoc() == l
decreases
func (s *SCION) setPathLoc(l PathMemLoc) {
	s.pathMemLoc = l
}

ghost
ensures (l == New || l == Raw || l == Pool) == res
pure func isValidPathMemLoc(l PathMemLoc) (res bool) {
	return l == New || l == Raw || l == Pool
}

pure
requires acc(s.Mem(), _)
ensures  res == unfolding acc(s.Mem(), _) in len(s.RawSrcAddr)
// ensures  res % 2 == 0
decreases
func (s *SCION) getLenRawSrcAddr() (res int) {
	return unfolding acc(s.Mem(), _) in len(s.RawSrcAddr)
}

pure
requires acc(s.Mem(), _)
ensures  res == unfolding acc(s.Mem(), _) in len(s.RawDstAddr)
// ensures  res % 2 == 0
decreases
func (s *SCION) getLenRawDstAddr() (res int) {
	return unfolding acc(s.Mem(), _) in len(s.RawDstAddr)
}

ghost
requires acc(s.Mem(), _)
pure func (s *SCION) PathLen() int {
	return unfolding acc(s.Mem(), _) in s.Path.Len()
}
