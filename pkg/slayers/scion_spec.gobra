// Copyright 2022 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package slayers

import (
	"github.com/scionproto/scion/pkg/addr"
	"github.com/scionproto/scion/pkg/slayers/path"
	"github.com/scionproto/scion/pkg/slayers/path/empty"
	"github.com/scionproto/scion/pkg/slayers/path/epic"
	"github.com/scionproto/scion/pkg/slayers/path/onehop"
	"github.com/scionproto/scion/pkg/slayers/path/scion"

	def "github.com/scionproto/scion/verification/utils/definitions"
)

pred (s *SCION) NonInitPathPool() {
	acc(&s.pathPool) &&
	acc(&s.pathPoolRaw)
}

pred (s *SCION) InitPathPool() {
	acc(&s.pathPool) &&
	acc(&s.pathPoolRaw) &&
	// entry per path type
	// empty
	acc(&s.pathPool[empty.PathType]) &&
	s.pathPool[empty.PathType].NonInitMem() &&
	// typeOf(s.pathPool[empty.PathType]) == type[empty.Path] &&
	// onehop
	acc(&s.pathPool[onehop.PathType]) &&
	s.pathPool[empty.PathType].NonInitMem() &&
	// scion
	acc(&s.pathPool[scion.PathType]) &&
	s.pathPool[empty.PathType].NonInitMem() &&
	// epic
	acc(&s.pathPool[epic.PathType]) &&
	s.pathPool[empty.PathType].NonInitMem() &&
	// raw path
	s.pathPoolRaw.NonInitMem()
}

// TODO: should have NonInitHeaderMem (TBD) and another predicate for the remaining fields,
// except for the path pool!
pred (s *SCION) NonInitMem() {
	true
	/*
		BaseLayer
	// Common Header fields

	// Version is version of the SCION Header. Currently, only 0 is supported.
	Version uint8
	// TrafficClass denotes the traffic class. Its value in a received packet or fragment might be
	// different from the value sent by the packet’s source. The current use of the Traffic Class
	// field for Differentiated Services and Explicit Congestion Notification is specified in
	// RFC2474 and RFC3168
	TrafficClass uint8
	// FlowID is a 20-bit field used by a source to label sequences of packets to be treated in the
	// network as a single flow. It is mandatory to be set.
	FlowID uint32
	// NextHdr  encodes the type of the first header after the SCION header. This can be either a
	// SCION extension or a layer-4 protocol such as TCP or UDP. Values of this field respect and
	// extend IANA’s assigned internet protocol numbers.
	NextHdr L4ProtocolType
	// HdrLen is the length of the SCION header in multiples of 4 bytes. The SCION header length is
	// computed as HdrLen * 4 bytes. The 8 bits of the HdrLen field limit the SCION header to a
	// maximum of 255 * 4 == 1020 bytes.
	HdrLen uint8
	// PayloadLen is the length of the payload in bytes. The payload includes extension headers and
	// the L4 payload. This field is 16 bits long, supporting a maximum payload size of 64KB.
	PayloadLen uint16
	// PathType specifies the type of path in this SCION header.
	PathType path.Type
	// DstAddrType (2 bit) is the type of the destination address.
	DstAddrType AddrType
	// DstAddrLen (2 bit) is the length of the destination address. Supported address length are 4B
	// (0), 8B (1), 12B (2), and 16B (3).
	DstAddrLen AddrLen
	// SrcAddrType (2 bit) is the type of the source address.
	SrcAddrType AddrType
	// SrcAddrLen (2 bit) is the length of the source address. Supported address length are 4B (0),
	// 8B (1), 12B (2), and 16B (3).
	SrcAddrLen AddrLen

	// Address header fields.

	// DstIA is the destination ISD-AS.
	DstIA addr.IA
	// SrcIA is the source ISD-AS.
	SrcIA addr.IA
	// RawDstAddr is the destination address.
	RawDstAddr []byte
	// RawSrcAddr is the source address.
	RawSrcAddr []byte

	// Path is the path contained in the SCION header. It depends on the PathType field.
	Path path.Path
	*/
}

// TODO: put buffer as param
pred (s *SCION) Mem(ubuf []byte) {
	// TODO: complete; put description of fields from BaseLayer; put permissions to the entire ubuf as a clause here
	CmnHdrLen <= len(ubuf) &&
	s.HeaderMem(ubuf[CmnHdrLen:])
}

pred (s *SCION) HeaderMem(ubuf []byte) {
	acc(&s.DstIA) &&
	acc(&s.SrcIA) &&
	// these fields are not parsed during DecodeAddrHd
	acc(&s.DstAddrLen, def.ReadL1) && s.DstAddrLen.isValid() &&
	acc(&s.SrcAddrLen, def.ReadL1) && s.SrcAddrLen.isValid() &&
	// RawDstAddr & RawSrcAddr locations. The memory for these is kept
	// outside of HeaderMem, in the Mem predicate where we just keep
	// access to the entire slice.
	s.addrHdrLenAbstractionLeak() <= len(ubuf) &&
	// helper facts to deal with incompletnesses when establising the bounds of s.RawDstAddr and s.RawSrcAddr
	0 < addrBytes(s.DstAddrLen) && 0 < addrBytes(s.SrcAddrLen) &&
	0 < 2*addr.IABytes && 2*addr.IABytes < 2*addr.IABytes+addrBytes(s.DstAddrLen) &&
	2*addr.IABytes+addrBytes(s.DstAddrLen) < 2*addr.IABytes+addrBytes(s.DstAddrLen)+addrBytes(s.SrcAddrLen) &&
	2*addr.IABytes+addrBytes(s.DstAddrLen)+addrBytes(s.SrcAddrLen) <= len(ubuf) &&
	// end of helper facts to deal with incompletnesses when establising the bounds of s.RawDstAddr and s.RawSrcAddr
	acc(&s.RawDstAddr) && acc(&s.RawSrcAddr) &&
	s.RawDstAddr === ubuf[2*addr.IABytes:2*addr.IABytes+addrBytes(s.DstAddrLen)] &&
	s.RawSrcAddr === ubuf[2*addr.IABytes+addrBytes(s.DstAddrLen):2*addr.IABytes+addrBytes(s.DstAddrLen)+addrBytes(s.SrcAddrLen)]
}

ghost
pure
decreases
func (a AddrLen) isValid() bool {
	// takes advantage of the knowledge (non-modular) that all definitions are contiguoues
	// to introduce an interval instead of an enequality:
	// 		return a == AddrLen4 || a == AddrLen8 || a == AddrLen12 || a == AddrLen16
	return AddrLen4 <= a && a <= AddrLen16
}

ghost
requires acc(&s.DstAddrLen, _) && acc(&s.SrcAddrLen, _)
decreases
pure
func (s *SCION) addrHdrLenAbstractionLeak() int {
	return 2*addr.IABytes + addrBytes(s.DstAddrLen) + addrBytes(s.SrcAddrLen)
}

ghost
requires acc(s.Mem(ubuf), _)
decreases
pure
func (s *SCION) AddrHdrLenNoAbstractionLeak(ubuf []byte) int {
	return unfolding acc(s.Mem(ubuf), _) in (unfolding s.HeaderMem(ubuf[CmnHdrLen:]) in (2*addr.IABytes + addrBytes(s.DstAddrLen) + addrBytes(s.SrcAddrLen)))
}